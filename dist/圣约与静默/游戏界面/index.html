<!doctype html><html lang="zh-CN"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/><meta name="theme-color" content="#2a2a2a"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/><title>修道院箱庭 - 百合恋爱文字冒险</title><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/><link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600;700&family=Lato:ital,wght@0,300;0,400;0,700;1,300;1,400&display=swap" rel="stylesheet"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css"/><script src="https://code.jquery.com/jquery-3.6.0.min.js"></script><script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/toastr.min.css"/><script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script><script type="module">;// ./src/圣约与静默/游戏界面/scripts/components/backgroundManager.ts
/**
 * 背景管理器组件
 * 负责管理游戏中的背景图片显示和切换
 */
class BackgroundManager {
    // 背景图片映射
    backgroundMap = {};
    constructor() {
        // 初始化背景图片映射
        this.initBackgroundMap();
        console.log('背景管理器初始化完成');
    }
    /**
     * 初始化背景图片映射
     */
    initBackgroundMap() {
        // 设置基本背景映射
        this.backgroundMap = {
            公园_白天: 'https://gitgud.io/lolodesu/lolobabytutorial/-/raw/master/lologame/%E8%83%8C%E6%99%AF/%E5%85%AC%E5%9B%AD/%E7%99%BD%E5%A4%A9.jpg?ref_type=heads',
            公园_黄昏: 'https://gitgud.io/lolodesu/lolobabytutorial/-/raw/master/lologame/%E8%83%8C%E6%99%AF/%E5%85%AC%E5%9B%AD/%E9%BB%84%E6%98%8F.jpg?ref_type=heads',
            书店_内部: 'https://gitgud.io/lolodesu/lolobabytutorial/-/raw/master/lologame/%E8%83%8C%E6%99%AF/%E4%B9%A6%E5%BA%97%E5%86%85/%E4%B9%A6%E5%BA%97.jpg?ref_type=heads',
            修道院_图书室: 'https://gitgud.io/lolodesu/lolobabytutorial/-/raw/master/lologame/%E8%83%8C%E6%99%AF/%E4%B9%A6%E5%BA%97%E5%86%85/%E4%B9%A6%E5%BA%97.jpg?ref_type=heads',
            修道院_办公室: 'https://gitgud.io/lolodesu/lolobabytutorial/-/raw/master/lologame/%E8%83%8C%E6%99%AF/%E5%85%AC%E5%9B%AD/%E9%BB%84%E6%98%8F.jpg?ref_type=heads',
            修道院_花园: 'https://gitgud.io/lolodesu/lolobabytutorial/-/raw/master/lologame/%E8%83%8C%E6%99%AF/%E5%85%AC%E5%9B%AD/%E7%99%BD%E5%A4%A9.jpg?ref_type=heads',
        };
    }
    /**
     * 设置背景图片
     * @param location 位置
     * @param scene 场景
     */
    setBackground(location, scene) {
        // 生成背景键
        const backgroundKey = `${location}_${scene}`;
        // 获取背景图片URL
        let backgroundUrl = this.backgroundMap[backgroundKey];
        // 如果没有找到特定的背景，尝试使用该位置的默认背景
        if (!backgroundUrl) {
            backgroundUrl = this.backgroundMap[`${location}_默认`];
        }
        // 如果还是没有找到，使用第一张图片作为默认
        if (!backgroundUrl && !_.isEmpty(this.backgroundMap)) {
            backgroundUrl = _.values(this.backgroundMap)[0];
        }
        if (backgroundUrl) {
            // 设置背景图片
            $('.background-container').css('backgroundImage', `url('${backgroundUrl}')`);
            console.log(`已设置背景: ${backgroundKey}`);
        }
        else {
            console.warn(`未找到背景: ${backgroundKey}`);
            // 设置默认背景颜色
            $('.background-container').css({
                backgroundImage: 'none',
                backgroundColor: '#2a2a2a',
            });
        }
    }
    /**
     * 添加背景图片映射
     * @param key 背景键
     * @param url 图片URL
     */
    addBackground(key, url) {
        this.backgroundMap[key] = url;
    }
    /**
     * 应用背景切换特效
     * @param effect 特效名称
     */
    applyBackgroundEffect(effect) {
        // 移除所有特效类
        $('.background-container').removeClass('effect-fade effect-slide effect-zoom');
        if (effect) {
            // 添加指定特效类并使用jQuery UI的效果
            const $bg = $('.background-container');
            switch (effect) {
                case 'fade':
                    $bg.addClass('effect-fade');
                    $bg.hide().fadeIn(1000);
                    break;
                case 'slide':
                    $bg.addClass('effect-slide');
                    $bg.hide().slideDown(1000);
                    break;
                case 'zoom':
                    $bg.addClass('effect-zoom');
                    $bg.hide().show('scale', {}, 1000);
                    break;
            }
            // 一段时间后移除特效类
            setTimeout(() => {
                $bg.removeClass(`effect-${effect}`);
            }, 1000);
        }
    }
    /**
     * 获取所有背景键
     */
    getAllBackgroundKeys() {
        return _.keys(this.backgroundMap);
    }
}

;// ./src/圣约与静默/游戏界面/scripts/components/characterManager.ts
/**
 * 角色管理器组件
 * 负责管理游戏中的角色立绘显示
 */
class CharacterManager {
    // 角色资源服务
    characterResourceService;
    // 当前显示的角色
    currentCharacters = {};
    constructor(characterResourceService) {
        this.characterResourceService = characterResourceService;
        console.log('角色管理器初始化完成');
    }
    /**
     * 设置角色立绘
     * @param characterId 角色ID
     * @param emotion 表情差分
     * @param position 位置 ('left' 或 'right')
     */
    setCharacter(characterId, emotion = 'default', position) {
        const $element = $(`.character-${position}`);
        if ($element.length === 0) {
            console.error(`未找到${position}侧角色容器元素`);
            return;
        }
        // 获取角色资源
        const character = this.characterResourceService.getCharacter(characterId);
        if (!character) {
            console.error(`未找到ID为${characterId}的角色资源`);
            this.hideCharacter(position);
            return;
        }
        // 获取对应表情的立绘URL
        const imageUrl = this.characterResourceService.getCharacterEmotionUrl(characterId, emotion);
        if (!imageUrl) {
            console.error(`角色${characterId}没有${emotion}表情差分`);
            // 尝试使用默认表情
            const defaultImageUrl = this.characterResourceService.getCharacterEmotionUrl(characterId);
            if (!defaultImageUrl) {
                this.hideCharacter(position);
                return;
            }
            // 使用默认表情
            this.setCharacterImage($element, character, defaultImageUrl, position, 'default');
        }
        else {
            // 使用指定表情
            this.setCharacterImage($element, character, imageUrl, position, emotion);
        }
    }
    /**
     * 设置角色图像
     */
    setCharacterImage($element, character, imageUrl, position, emotion) {
        // 设置角色立绘
        $element
            .css({
            backgroundImage: `url('${imageUrl}')`,
            opacity: 1,
        })
            .data({
            characterId: character.id,
            characterName: character.name,
        });
        // 存储当前显示的角色
        this.currentCharacters[position] = {
            id: character.id,
            emotion: emotion,
        };
        console.log(`已设置${character.name}的${emotion}表情立绘在${position}侧`);
    }
    /**
     * 更新角色表情
     * @param characterId 角色ID
     * @param emotion 表情差分
     */
    updateEmotion(characterId, emotion = 'default') {
        // 查找角色当前在哪一侧
        let position = null;
        if (this.currentCharacters.left?.id === characterId) {
            position = 'left';
        }
        else if (this.currentCharacters.right?.id === characterId) {
            position = 'right';
        }
        if (!position) {
            console.warn(`未找到ID为${characterId}的角色在场景中`);
            return;
        }
        // 更新表情
        this.setCharacter(characterId, emotion, position);
    }
    /**
     * 隐藏角色立绘
     * @param position 位置 ('left', 'right' 或 'all')
     */
    hideCharacter(position) {
        if (position === 'left' || position === 'all') {
            $('.character-left').css({
                backgroundImage: 'none',
                opacity: 0,
            });
            delete this.currentCharacters.left;
        }
        if (position === 'right' || position === 'all') {
            $('.character-right').css({
                backgroundImage: 'none',
                opacity: 0,
            });
            delete this.currentCharacters.right;
        }
    }
    /**
     * 设置角色立绘特效
     * @param position 位置 ('left' 或 'right')
     * @param effect 特效名称 ('shake', 'focus', 'blur', 等)
     */
    setCharacterEffect(position, effect) {
        const $element = $(`.character-${position}`);
        if ($element.length === 0) {
            console.error(`未找到${position}侧角色容器元素`);
            return;
        }
        // 移除所有效果类
        $element.removeClass('effect-shake effect-focus effect-blur');
        // 添加指定效果类
        if (effect) {
            $element.addClass(`effect-${effect}`);
            // 使用jQuery UI的效果
            switch (effect) {
                case 'shake':
                    $element.effect('shake', { times: 3, distance: 5 }, 500);
                    break;
                case 'focus':
                    $('.characters-container .character').not($element).animate({ opacity: 0.5 }, 500);
                    $element.animate({ opacity: 1 }, 500);
                    break;
                case 'blur':
                    $element.fadeOut(250).fadeIn(250);
                    break;
            }
        }
    }
    /**
     * 交换角色立绘位置
     */
    swapCharacters() {
        const $leftChar = $('.character-left');
        const $rightChar = $('.character-right');
        if ($leftChar.length === 0 || $rightChar.length === 0)
            return;
        // 保存当前角色状态
        const leftChar = this.currentCharacters.left;
        const rightChar = this.currentCharacters.right;
        // 如果两边都有角色，交换它们
        if (leftChar && rightChar) {
            this.setCharacter(rightChar.id, rightChar.emotion, 'left');
            this.setCharacter(leftChar.id, leftChar.emotion, 'right');
            // 添加过渡动画
            $leftChar.add($rightChar).css('transition', 'all 0.5s ease-in-out');
        }
    }
    /**
     * 根据对话更新角色显示
     * @param speakerId 发言角色ID
     * @param emotion 表情差分
     */
    updateCharactersByDialogue(speakerId, emotion = 'default') {
        // 如果是旁白，不更新角色
        if (speakerId === 'narrator')
            return;
        // 获取角色资源
        const character = this.characterResourceService.getCharacter(speakerId);
        if (!character) {
            // 对于未预定义的角色，不执行立绘更新
            console.log(`未找到ID为${speakerId}的角色资源，跳过立绘更新`);
            return;
        }
        // 检查角色是否已在场景中
        let position = 'right'; // 默认位置
        if (this.currentCharacters.left?.id === speakerId) {
            position = 'left';
        }
        else if (this.currentCharacters.right?.id === speakerId) {
            position = 'right';
        }
        else {
            // 如果角色不在场景中，根据角色预设位置添加
            if (character.position === 'left' || character.position === 'right') {
                position = character.position;
            }
            // 添加角色到场景
            this.setCharacter(speakerId, emotion, position);
            return;
        }
        // 更新已在场景中的角色表情
        this.updateEmotion(speakerId, emotion);
    }
}

;// ./src/圣约与静默/游戏界面/scripts/components/choiceManager.ts
/**
 * 选项管理器组件
 * 负责管理游戏中的选项显示和处理
 */
class ChoiceManager {
    // 选项数据
    choices = [];
    // 记录选项是否已经显示过
    choicesShown = false;
    // 是否已隐藏选项
    choicesHidden = false;
    // 选项选择回调
    onChoiceSelectedCallback = null;
    constructor() {
        // 绑定自定义选项按钮事件
        $('#custom-choice-button').on('click', () => {
            const customChoice = $('#custom-choice-input').val();
            if (customChoice && customChoice.trim()) {
                this.selectChoice(customChoice.trim());
                $('#custom-choice-input').val('');
            }
        });
        // 绑定自定义选项输入框回车事件
        $('#custom-choice-input').on('keypress', e => {
            if (e.key === 'Enter') {
                const customChoice = $('#custom-choice-input').val();
                if (customChoice && customChoice.trim()) {
                    this.selectChoice(customChoice.trim());
                    $('#custom-choice-input').val('');
                }
            }
        });
        // 绑定隐藏按钮事件
        $(document).on('click', '#hide-choices-btn', e => {
            e.stopPropagation(); // 防止触发其他点击事件
            this.hideChoices();
        });
        console.log('选项管理器初始化完成');
    }
    /**
     * 设置选项列表
     */
    setChoices(choices) {
        this.choices = choices;
        this.choicesShown = false;
        this.choicesHidden = false;
    }
    /**
     * 渲染选项
     */
    renderChoices() {
        const $presetChoices = $('.preset-choices');
        if ($presetChoices.length === 0)
            return;
        // 清空现有选项
        $presetChoices.empty();
        // 渲染每个选项按钮，添加索引数据属性以便于样式控制
        _.forEach(this.choices, (choice, index) => {
            $('<button>', {
                class: 'choice-button',
                text: choice,
                'data-index': index,
                'data-choice': choice,
                click: () => this.selectChoice(choice),
            }).appendTo($presetChoices);
        });
        // 根据选项数量设置容器宽度和样式
        const $choicesContainer = $('.choices-container');
        if (this.choices.length <= 2) {
            $choicesContainer.addClass('compact-choices');
        }
        else {
            $choicesContainer.removeClass('compact-choices');
        }
    }
    /**
     * 显示选项
     */
    showChoices() {
        const $choicesContainer = $('.choices-container');
        const $presetChoices = $('.preset-choices');
        if ($choicesContainer.length === 0 || $presetChoices.length === 0)
            return;
        // 渲染选项
        this.renderChoices();
        // 显示选项容器并添加动画效果
        $choicesContainer.removeClass('hidden').hide().fadeIn(300);
        // 标记选项已显示
        this.choicesShown = true;
        this.choicesHidden = false;
        // 聚焦自定义输入框
        setTimeout(() => {
            $('#custom-choice-input').focus();
        }, 300);
    }
    /**
     * 隐藏选项
     */
    hideChoices() {
        const self = this;
        $('.choices-container').fadeOut(300, function () {
            $(this).addClass('hidden').show();
            // 标记选项已隐藏
            self.choicesHidden = true;
        });
    }
    /**
     * 检查是否可以重新显示选项
     */
    canReshowChoices() {
        return this.choicesShown && this.choicesHidden && this.choices.length > 0;
    }
    /**
     * 重新显示上次的选项
     */
    reshowChoices() {
        if (this.canReshowChoices()) {
            this.showChoices();
        }
    }
    /**
     * 选择选项
     */
    selectChoice(choice) {
        // 调用选择回调
        if (this.onChoiceSelectedCallback) {
            this.onChoiceSelectedCallback(choice);
        }
        // 隐藏选项
        this.hideChoices();
    }
    /**
     * 设置选项选择回调
     */
    setOnChoiceSelected(callback) {
        this.onChoiceSelectedCallback = callback;
    }
    /**
     * 添加选项
     */
    addChoice(choice) {
        if (!_.includes(this.choices, choice)) {
            this.choices.push(choice);
            // 如果选项容器已显示，更新选项
            if (!$('.choices-container').hasClass('hidden')) {
                this.renderChoices();
            }
        }
    }
    /**
     * 移除选项
     */
    removeChoice(choice) {
        _.pull(this.choices, choice);
        // 如果选项容器已显示，更新选项
        if (!$('.choices-container').hasClass('hidden')) {
            this.renderChoices();
        }
    }
    /**
     * 清空所有选项
     */
    clearChoices() {
        this.choices = [];
        // 如果选项容器已显示，更新选项
        if (!$('.choices-container').hasClass('hidden')) {
            this.renderChoices();
        }
    }
    /**
     * 获取所有选项
     */
    getAllChoices() {
        return _.clone(this.choices);
    }
    /**
     * 检查选项当前是否可见
     * @returns 选项是否可见
     */
    areChoicesVisible() {
        // 如果选项已显示且未被隐藏，则认为选项当前可见
        return this.choicesShown && !this.choicesHidden;
    }
}

;// ./src/圣约与静默/游戏界面/scripts/components/dialogueManager.ts
/**
 * 对话管理器组件
 * 负责管理游戏中的对话显示、控制和效果
 */
class DialogueManager {
    // 对话数据
    dialogues = [];
    currentDialogueIndex = 0;
    // 服务引用
    characterResourceService;
    characterManager;
    backgroundManager;
    // 自动播放设置
    isAutoPlaying = false;
    autoPlayInterval = null;
    autoPlaySpeed = 3000; // 毫秒
    constructor(characterResourceService, characterManager, backgroundManager) {
        this.characterResourceService = characterResourceService;
        this.characterManager = characterManager;
        this.backgroundManager = backgroundManager;
        // 绑定自动播放按钮
        $('#auto-play').on('click', () => {
            this.toggleAutoPlay();
        });
        // 不再需要绑定下一步按钮，改为在GameController中绑定对话框点击
        // $('.dialogue-next-button').on('click', () => {
        //   this.showNextDialogue();
        // });
        console.log('对话管理器初始化完成');
    }
    /**
     * 设置对话列表
     */
    setDialogues(dialogues) {
        this.dialogues = dialogues;
        this.currentDialogueIndex = 0;
    }
    /**
     * 显示特定索引的对话
     */
    showDialogue(index) {
        if (index < 0 || index >= this.dialogues.length) {
            console.error('无效的对话索引');
            return;
        }
        // 更新当前索引
        this.currentDialogueIndex = index;
        const dialogue = this.dialogues[index];
        // 更新发言人名称 - 直接使用speaker属性，不做处理
        const speakerName = dialogue.speaker;
        $('.speaker-name').text(speakerName);
        // 创建新对话文本元素
        const $dialogueText = $('<div>', {
            class: `dialogue-text style-${dialogue.style || 'normal'}`,
            text: dialogue.content,
        });
        // 清空并添加新内容
        $('.dialogue-content').empty().append($dialogueText);
        // 滚动到底部
        $('.dialogue-content').scrollTop($('.dialogue-content')[0].scrollHeight);
        // 更新角色立绘
        this.updateCharacterDisplay(dialogue);
        // 更新背景（如果有指定）
        this.updateBackground(dialogue);
    }
    /**
     * 更新角色立绘显示
     */
    updateCharacterDisplay(dialogue) {
        // 如果对话没有指定portrait，尝试使用默认规则
        if (!dialogue.portrait) {
            // 判断角色是否在预设名单中
            const character = this.characterResourceService.getCharacter(dialogue.speaker);
            if (character) {
                // 如果是预设角色，按原有逻辑显示
                this.characterManager.updateCharactersByDialogue(dialogue.speaker, 'default');
            }
            else {
                // 如果不是预设角色，只显示名字，不显示立绘
                this.characterManager.hideCharacter('all');
            }
            return;
        }
        // 如果有指定portrait，使用指定的角色和表情
        const { character, emotion } = dialogue.portrait;
        // 判断这个角色在左边还是右边
        let position = 'right'; // 默认右侧
        // 尝试获取角色资源来确定位置
        const characterResource = this.characterResourceService.getCharacter(character);
        if (characterResource && characterResource.position) {
            position = characterResource.position;
        }
        // 设置角色立绘
        this.characterManager.setCharacter(character, emotion, position);
    }
    /**
     * 更新背景显示
     */
    updateBackground(dialogue) {
        // 如果对话指定了背景，则更新背景
        if (dialogue.background) {
            const { location, scene } = dialogue.background;
            this.backgroundManager.setBackground(location, scene);
        }
    }
    /**
     * 显示下一条对话
     */
    showNextDialogue() {
        if (this.currentDialogueIndex < this.dialogues.length - 1) {
            this.showDialogue(this.currentDialogueIndex + 1);
            return true;
        }
        return false; // 没有更多对话了
    }
    /**
     * 显示上一条对话
     */
    showPreviousDialogue() {
        if (this.currentDialogueIndex > 0) {
            this.showDialogue(this.currentDialogueIndex - 1);
            return true;
        }
        return false; // 已经是第一条对话
    }
    /**
     * 渲染对话内容
     * 用于初始化或重新渲染对话界面
     */
    renderDialogue(index = this.currentDialogueIndex) {
        this.showDialogue(index);
    }
    /**
     * 添加新对话
     */
    addDialogue(dialogue) {
        this.dialogues.push(dialogue);
        // 如果添加的是第一条对话，则显示它
        if (this.dialogues.length === 1) {
            this.renderDialogue(0);
        }
    }
    /**
     * 清空所有对话
     */
    clearDialogues() {
        this.dialogues = [];
        this.currentDialogueIndex = 0;
        // 清空对话内容
        $('.dialogue-content').empty();
        $('.speaker-name').text('');
        // 清空角色显示
        this.characterManager.hideCharacter('all');
    }
    /**
     * 切换自动播放
     */
    toggleAutoPlay() {
        this.isAutoPlaying = !this.isAutoPlaying;
        // 获取自动播放按钮
        const $autoPlayButton = $('#auto-play');
        if (this.isAutoPlaying) {
            // 启动自动播放
            this.autoPlayInterval = window.setInterval(() => {
                const hasMoreDialogue = this.showNextDialogue();
                if (!hasMoreDialogue) {
                    // 没有更多对话了，停止自动播放
                    this.stopAutoPlay();
                }
            }, this.autoPlaySpeed);
            // 更新按钮样式
            $autoPlayButton.addClass('active').html('<i class="fas fa-pause"></i>');
        }
        else {
            // 停止自动播放
            this.stopAutoPlay();
            // 更新按钮样式
            $autoPlayButton.removeClass('active').html('<i class="fas fa-play"></i>');
        }
    }
    /**
     * 停止自动播放
     */
    stopAutoPlay() {
        if (this.autoPlayInterval !== null) {
            clearInterval(this.autoPlayInterval);
            this.autoPlayInterval = null;
        }
        this.isAutoPlaying = false;
        // 更新按钮样式
        $('#auto-play').removeClass('active').html('<i class="fas fa-play"></i>');
    }
    /**
     * 设置自动播放速度
     */
    setAutoPlaySpeed(speed) {
        this.autoPlaySpeed = speed;
        // 如果自动播放正在进行，重启它以应用新速度
        if (this.isAutoPlaying) {
            this.stopAutoPlay();
            this.toggleAutoPlay();
        }
    }
    /**
     * 获取当前对话
     */
    getCurrentDialogue() {
        if (this.currentDialogueIndex >= 0 && this.currentDialogueIndex < this.dialogues.length) {
            return this.dialogues[this.currentDialogueIndex];
        }
        return null;
    }
    /**
     * 获取所有对话
     */
    getAllDialogues() {
        return _.cloneDeep(this.dialogues);
    }
    /**
     * 显示对话历史记录
     * @param externalDialogues 可选的外部对话历史数据
     */
    showDialogueHistory(externalDialogues) {
        // 保存当前索引
        const currentIndex = this.currentDialogueIndex;
        // 显示所有对话
        const $dialogueContent = $('.dialogue-content');
        $dialogueContent.empty();
        // 决定使用哪个对话历史数据源
        const dialoguesToShow = externalDialogues || this.dialogues;
        // 使用lodash遍历对话
        _.forEach(dialoguesToShow, (dialogue, index) => {
            // 创建对话项容器
            const $dialogueItem = $('<div>', {
                class: 'dialogue-history-item',
                'data-index': index,
            });
            // 创建发言人元素
            const $speakerName = $('<div>', {
                class: 'speaker-name-history',
                text: dialogue.speaker,
            });
            // 创建对话内容元素
            const $dialogueText = $('<div>', {
                class: `dialogue-text-history style-${dialogue.style || 'normal'}`,
                text: dialogue.content,
            });
            // 添加到容器
            $dialogueItem.append($speakerName).append($dialogueText);
            // 添加到对话内容区域
            $dialogueContent.append($dialogueItem);
        });
        // 显示历史记录模式通知
        $('#dialogue-history-notice').show();
        // 添加"返回"按钮
        const $returnButton = $('<button>', {
            id: 'return-from-history',
            class: 'btn btn-primary',
            text: '返回对话',
            click: () => {
                // 隐藏通知
                $('#dialogue-history-notice').hide();
                // 移除历史记录样式
                $dialogueContent.removeClass('history-mode');
                // 渲染当前对话
                this.renderDialogue(currentIndex);
            },
        });
        // 添加返回按钮
        $dialogueContent.append($returnButton);
        // 添加历史记录样式
        $dialogueContent.addClass('history-mode');
    }
    /**
     * 获取当前对话索引
     */
    getCurrentDialogueIndex() {
        return this.currentDialogueIndex;
    }
    /**
     * 对话是否已结束
     */
    isDialogueFinished() {
        return this.currentDialogueIndex >= this.dialogues.length - 1;
    }
}

;// ./src/圣约与静默/游戏界面/scripts/components/journalManager.ts
/**
 * 日记管理器
 * 负责处理游戏中的日记功能，仅显示空白占位页
 */
class JournalManager {
    // 游戏数据引用
    gameData = null;
    constructor() {
        console.log('日记管理器初始化完成');
    }
    /**
     * 设置游戏数据
     * @param gameData 游戏数据
     */
    setGameData(gameData) {
        this.gameData = gameData;
    }
    /**
     * 切换日记部分
     */
    switchJournalSection(sectionId) {
        // 移除所有导航项的激活状态
        $('.journal-nav-item').removeClass('active');
        // 移除所有内容区域的激活状态
        $('.journal-section').removeClass('active');
        // 激活选中的导航项和内容区域
        $(`[data-section="${sectionId}"]`).addClass('active');
        $(`#${sectionId}-section`).addClass('active');
        // 显示所有部分的空白占位页
        this.showPlaceholder(sectionId);
    }
    /**
     * 刷新日记内容
     */
    refreshJournalContent() {
        // 默认显示角色信息部分
        this.showPlaceholder('characters');
    }
    /**
     * 显示对应区域的空白占位页
     * @param sectionId 区域ID
     */
    showPlaceholder(sectionId) {
        const $container = $(`#${sectionId}-section`);
        if (!$container.length)
            return;
        // 清空现有内容
        $container.empty();
        // 获取显示标题
        let title = '日记';
        switch (sectionId) {
            case 'characters':
                title = '角色信息';
                break;
            case 'monastery':
                title = '修道院';
                break;
            case 'knowledge':
                title = '知识库';
                break;
        }
        // 添加空白页占位内容
        $('<div>', {
            class: 'journal-placeholder',
            css: {
                padding: '20px',
                textAlign: 'center',
            },
        })
            .append($('<h3>', {
            text: title,
            css: { marginBottom: '15px' },
        }))
            .append($('<p>', {
            text: '内容暂未实现',
            css: {
                color: '#888',
                fontStyle: 'italic',
            },
        }))
            .appendTo($container);
        console.log(`日记${title}部分已清空，仅保留占位符`);
    }
    /**
     * 选择角色
     * 保留方法签名但简化实现
     */
    selectCharacter(characterId) {
        // 仅记录交互，不执行实际操作
        console.log(`尝试选择角色: ${characterId}，但该功能已简化为占位符`);
    }
}

;// ./src/圣约与静默/游戏界面/scripts/components/memoryManager.ts
/**
 * 记忆管理器组件
 * 负责管理游戏中的记忆系统和时间旅行机制
 */
class MemoryManager {
    // 记忆数据
    memories = [];
    selectedMemoryId = null;
    // 使用会话存储跟踪是否已经保存过场景
    hasCreatedMemory = false;
    alreadySavedKey = 'memory_already_saved';
    // 标记是否正在处理切换标签的操作
    isTabSwitching = false;
    // 记忆选择回调
    onMemorySelectedCallback = null;
    onMemorySavedCallback = null;
    onMemoryTravelCallback = null;
    constructor() {
        // 绑定穿越按钮事件
        $('#travel-to-memory').on('click', () => {
            this.travelToSelectedMemory();
        });
        // 检查是否已保存过场景
        this.checkIfAlreadySaved();
        // 设置标签切换事件监听，确保只在需要时刷新
        $('a[data-bs-toggle="tab"]').on('hide.bs.tab', e => {
            if ($(e.target).attr('href') === '#memory-tab') {
                this.isTabSwitching = true;
            }
        });
        $('a[data-bs-toggle="tab"]').on('shown.bs.tab', e => {
            if ($(e.target).attr('href') === '#memory-tab') {
                // 在切换回记忆标签时，确保正确刷新数据而不是UI
                // 重要：使用setTimeout是为了让DOM完全更新
                setTimeout(() => {
                    // 先清空时间轴，防止重复
                    $('#memory-timeline').empty();
                    this.renderMemories();
                    this.isTabSwitching = false;
                }, 50);
            }
        });
        console.log('记忆管理器初始化完成');
    }
    /**
     * 检查是否已经保存过场景
     */
    checkIfAlreadySaved() {
        const saved = sessionStorage.getItem(this.alreadySavedKey);
        if (saved === 'true') {
            this.hasCreatedMemory = true;
            // 更新UI状态
            this.updateSaveButtonState();
        }
    }
    /**
     * 更新保存按钮状态
     */
    updateSaveButtonState() {
        if (this.hasCreatedMemory) {
            $('.memory-button')
                .prop('disabled', true)
                .css('opacity', '0.5')
                .attr('title', '此场景已保存，每个场景只能保存一次')
                .text('已保存');
        }
    }
    /**
     * 设置记忆列表
     */
    setMemories(memories) {
        // 去重处理，确保每个ID只存在一次
        const uniqueMemories = {};
        // 使用对象键值对去重
        memories.forEach(memory => {
            uniqueMemories[memory.id] = memory;
        });
        // 转换回数组
        this.memories = Object.values(uniqueMemories);
        console.log(`设置了${this.memories.length}个记忆点（去重后）`);
    }
    /**
     * 渲染记忆时间轴
     */
    renderMemories() {
        const $timeline = $('#memory-timeline');
        if ($timeline.length === 0)
            return;
        // 如果正在切换标签，不立即渲染
        if (this.isTabSwitching) {
            return;
        }
        // 清空现有时间轴
        $timeline.empty();
        // 去重并按时间轴顺序排序记忆（按ID递增）
        const uniqueMemories = {};
        this.memories.forEach(memory => {
            uniqueMemories[memory.id] = memory;
        });
        const sortedMemories = _.sortBy(Object.values(uniqueMemories), 'id');
        // 确保内存中的记忆也是去重的
        this.memories = sortedMemories;
        // 没有记忆点时显示提示
        if (sortedMemories.length === 0) {
            $timeline.html('<div class="memory-empty-timeline">尚未创建记忆点。保存当前场景来创建一个新的记忆点。</div>');
            return;
        }
        // 创建记忆节点 - 简化为纯圆点设计
        _.forEach(sortedMemories, (memory, index) => {
            // 创建简单的记忆节点
            const $node = $('<div>', {
                class: `memory-node-simple ${this.selectedMemoryId === memory.id ? 'selected' : ''}`,
                'data-id': memory.id,
                title: this.formatTimestamp(memory.timestamp || ''),
                click: () => this.selectMemory(memory.id),
            }).appendTo($timeline);
        });
        console.log(`已渲染${sortedMemories.length}个记忆点`);
        // 更新保存按钮状态
        this.updateSaveButtonState();
    }
    /**
     * 格式化时间戳为更简短的格式
     */
    formatTimestamp(timestamp) {
        // 提取日期和时间的关键部分
        try {
            const date = new Date(timestamp);
            if (isNaN(date.getTime())) {
                // 如果不是标准日期格式，直接返回原始字符串
                return timestamp;
            }
            // 返回简短格式：月/日 时:分
            return `${date.getMonth() + 1}/${date.getDate()} ${date.getHours()}:${date
                .getMinutes()
                .toString()
                .padStart(2, '0')}`;
        }
        catch (e) {
            // 如果解析失败，返回原始时间戳
            return timestamp;
        }
    }
    /**
     * 选择记忆
     */
    selectMemory(memoryId) {
        // 查找记忆
        const memory = _.find(this.memories, { id: memoryId });
        if (!memory) {
            console.error(`未找到ID为${memoryId}的记忆`);
            return;
        }
        this.selectedMemoryId = memoryId;
        // 更新记忆内容
        const $content = $('#memory-content');
        if ($content.length > 0) {
            $content.empty();
            // 如果有图片，显示图片
            if (memory.image) {
                $('<div>', {
                    class: 'memory-content-image',
                    css: { backgroundImage: `url('${memory.image}')` },
                }).appendTo($content);
            }
            // 创建记忆内容元素
            $('<div>', {
                class: 'memory-content-text',
                text: memory.content,
            }).appendTo($content);
            // 如果有时间戳，显示时间戳
            if (memory.timestamp) {
                $('<div>', {
                    class: 'memory-timestamp',
                    text: memory.timestamp,
                }).appendTo($content);
            }
        }
        // 更新记忆节点样式
        $('.memory-node-simple').removeClass('selected');
        $(`.memory-node-simple[data-id="${memoryId}"]`).addClass('selected');
        // 启用穿越按钮
        $('#travel-to-memory').prop('disabled', false);
        // 调用选择回调
        if (this.onMemorySelectedCallback) {
            this.onMemorySelectedCallback(memoryId);
        }
    }
    /**
     * 穿越到选中的记忆
     */
    travelToSelectedMemory() {
        if (this.selectedMemoryId === null) {
            console.error('没有选中的记忆点');
            return;
        }
        // 调用穿越回调
        if (this.onMemoryTravelCallback) {
            this.onMemoryTravelCallback(this.selectedMemoryId);
        }
    }
    /**
     * 添加新记忆
     */
    addMemory(content, image) {
        // 检查是否已经保存过
        if (this.hasCreatedMemory) {
            console.warn('此场景已保存过，每个场景只能保存一次');
            this.showOneTimeOnlyMessage();
            return null;
        }
        // 生成新ID（通常应使用游戏状态数据中的下一个ID）
        const memoryIds = _.map(this.memories, 'id');
        const newId = this.memories.length > 0 ? (_.max(memoryIds) || 0) + 1 : 1;
        // 创建新记忆
        const newMemory = {
            id: newId,
            content,
            timestamp: new Date().toLocaleString(),
            image,
        };
        // 添加到记忆列表
        this.memories.push(newMemory);
        // 标记为已保存并存储到会话
        this.hasCreatedMemory = true;
        sessionStorage.setItem(this.alreadySavedKey, 'true');
        // 重新渲染时间轴
        this.renderMemories();
        // 选中新记忆
        this.selectMemory(newId);
        // 调用保存回调
        if (this.onMemorySavedCallback) {
            this.onMemorySavedCallback(newMemory);
        }
        return newMemory;
    }
    /**
     * 显示只能保存一次的提示
     */
    showOneTimeOnlyMessage() {
        // 显示一个临时提示信息
        const $notification = $('<div>', {
            class: 'notification notification-warning',
            text: '此场景已保存过，每个场景只能保存一次',
        }).appendTo('#notification-container');
        // 添加显示类
        setTimeout(() => {
            $notification.addClass('notification-show');
        }, 10);
        // 一段时间后隐藏和移除
        setTimeout(() => {
            $notification.addClass('notification-hide').removeClass('notification-show');
            setTimeout(() => {
                $notification.remove();
            }, 300);
        }, 3000);
    }
    /**
     * 删除记忆
     */
    deleteMemory(memoryId) {
        // 查找记忆索引
        const index = _.findIndex(this.memories, { id: memoryId });
        if (index === -1) {
            console.error(`未找到ID为${memoryId}的记忆`);
            return;
        }
        // 删除记忆
        this.memories.splice(index, 1);
        // 重新渲染时间轴
        this.renderMemories();
        // 如果删除的是当前选中的记忆，清除选择
        if (this.selectedMemoryId === memoryId) {
            this.selectedMemoryId = null;
            this.setEmptyMemoryContent();
            // 禁用穿越按钮
            $('#travel-to-memory').prop('disabled', true);
        }
    }
    /**
     * 获取当前选中的记忆
     */
    getSelectedMemory() {
        if (this.selectedMemoryId === null)
            return null;
        return _.find(this.memories, { id: this.selectedMemoryId }) || null;
    }
    /**
     * 获取所有记忆
     */
    getAllMemories() {
        // 确保返回的数据是去重的
        const uniqueMemories = {};
        this.memories.forEach(memory => {
            uniqueMemories[memory.id] = memory;
        });
        return _.cloneDeep(Object.values(uniqueMemories));
    }
    /**
     * 设置空记忆内容
     */
    setEmptyMemoryContent(message = '选择一个记忆点或保存当前场景') {
        $('#memory-content').html(`<div class="memory-empty-message">${message}</div>`);
        // 禁用穿越按钮
        $('#travel-to-memory').prop('disabled', true);
    }
    /**
     * 设置记忆选择回调
     */
    setOnMemorySelected(callback) {
        this.onMemorySelectedCallback = callback;
    }
    /**
     * 设置记忆保存回调
     */
    setOnMemorySaved(callback) {
        this.onMemorySavedCallback = callback;
    }
    /**
     * 设置记忆穿越回调
     */
    setOnMemoryTravel(callback) {
        this.onMemoryTravelCallback = callback;
    }
    /**
     * 清空记忆列表
     */
    clearMemories() {
        this.memories = [];
        this.selectedMemoryId = null;
        // 重置保存状态
        this.hasCreatedMemory = false;
        sessionStorage.removeItem(this.alreadySavedKey);
        this.renderMemories();
        this.setEmptyMemoryContent();
    }
    /**
     * 初始化显示
     */
    initializeDisplay() {
        // 去重处理
        const uniqueMemories = {};
        this.memories.forEach(memory => {
            uniqueMemories[memory.id] = memory;
        });
        this.memories = Object.values(uniqueMemories);
        if (this.memories.length > 0) {
            this.renderMemories();
        }
        else {
            this.setEmptyMemoryContent();
        }
        // 检查是否已保存
        this.checkIfAlreadySaved();
    }
}

;// ./src/圣约与静默/游戏界面/scripts/components/memoryUIManager.ts
/**
 * 记忆UI管理器
 * 负责处理游戏中的记忆功能UI部分
 */
class MemoryUIManager {
    // 游戏数据引用
    gameData = null;
    // 依赖的其他管理器
    memoryManager;
    saveManager;
    uiManager;
    gameStateGenerationService;
    constructor(memoryManager, saveManager, uiManager, gameStateGenerationService) {
        this.memoryManager = memoryManager;
        this.saveManager = saveManager;
        this.uiManager = uiManager;
        this.gameStateGenerationService = gameStateGenerationService;
        console.log('记忆UI管理器初始化完成');
    }
    /**
     * 设置游戏数据
     * @param gameData 游戏数据
     */
    setGameData(gameData) {
        this.gameData = gameData;
    }
    /**
     * 刷新记忆时间轴
     */
    refreshMemoryTimeline() {
        if (!this.gameData)
            return;
        this.memoryManager.setMemories(this.gameData.storySummary);
        this.memoryManager.renderMemories();
    }
    /**
     * 保存记忆
     * @returns 新创建的记忆点
     */
    saveMemory() {
        if (!this.gameData)
            return null;
        const newMemory = this.memoryManager.addMemory(`${this.gameData.story.currentChapter} - 在${this.gameData.story.location}`);
        // 提示用户
        this.uiManager.showNotification('记忆点已保存', 'success');
        return newMemory;
    }
    /**
     * 穿越到记忆点
     * @param onSuccess 成功穿越后的回调函数
     */
    async travelToMemory(onSuccess) {
        const selectedMemory = this.memoryManager.getSelectedMemory();
        if (!selectedMemory) {
            this.uiManager.showNotification('请先选择一个记忆点', 'warning');
            return;
        }
        // 显示确认对话框
        this.uiManager.showConfirmDialog(`确定要穿越到"${selectedMemory.content}"吗？`, async () => {
            this.uiManager.showLoading('正在穿越时间...');
            try {
                let newState = null;
                // 先尝试从世界书中加载游戏状态
                const loadedState = await this.saveManager.loadGameStateByID(selectedMemory.id);
                if (loadedState) {
                    // 如果成功加载到，更新游戏状态
                    newState = loadedState;
                    console.log('从世界书中加载了游戏状态');
                }
                else {
                    // 如果没有找到保存的状态，使用记忆点生成服务生成
                    const generatedState = await this.gameStateGenerationService.generateMemoryState(selectedMemory);
                    if (generatedState) {
                        newState = generatedState;
                        console.log('生成了新的记忆点游戏状态');
                    }
                    else {
                        throw new Error('无法生成记忆点游戏状态');
                    }
                }
                // 设置新的游戏状态
                this.gameData = newState;
                // 调用成功回调
                onSuccess();
                this.uiManager.showNotification('时间旅行成功', 'success');
            }
            catch (error) {
                console.error('穿越时间失败:', error);
                this.uiManager.showNotification('穿越失败: ' + (error instanceof Error ? error.message : '未知错误'), 'error');
            }
            finally {
                this.uiManager.hideLoading();
            }
        });
    }
    /**
     * 获取当前游戏数据
     */
    getGameData() {
        return this.gameData;
    }
}

;// ./src/圣约与静默/游戏界面/scripts/components/saveManager.ts
class SaveManager {
    uiManager;
    worldBookName = '修女的追忆记录'; // 使用固定名称
    modalId = 'load-game-modal';
    // 对话历史记录键名
    DIALOGUE_HISTORY_KEY = 'persistent_dialogue_history';
    // 完整历史记录键名
    COMPLETE_HISTORY_KEY = 'complete_game_history';
    // 存档类型
    SAVE_TYPE = {
        AUTO: 'auto_save_',
        MANUAL: 'save_',
    };
    // 当前最大存档ID
    currentMaxSaveId = {
        auto: 0,
        manual: 0,
    };
    // 缓存完整历史记录
    cachedCompleteHistory = null;
    constructor(uiManager) {
        this.uiManager = uiManager;
        this.initializeLoadGameModal();
        this.initializeChatLorebook();
        // 确保jQuery和Bootstrap正确加载
        this.ensureBootstrapLoaded();
        // 初始化时加载历史记录
        this.loadCompleteHistory();
    }
    /**
     * 确保Bootstrap正确加载
     */
    ensureBootstrapLoaded() {
        // 检查jQuery是否已加载
        if (typeof $ === 'undefined') {
            console.error('jQuery未加载，这可能导致modal功能失效');
            return;
        }
        // 检查Bootstrap的modal功能是否可用
        if (typeof $.fn.modal !== 'function') {
            console.warn('Bootstrap modal未检测到，尝试加载');
            // 尝试动态添加Bootstrap的CSS和JS
            if (!document.getElementById('bootstrap-css')) {
                const bootstrapCss = document.createElement('link');
                bootstrapCss.id = 'bootstrap-css';
                bootstrapCss.rel = 'stylesheet';
                bootstrapCss.href = 'https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css';
                document.head.appendChild(bootstrapCss);
            }
            if (!document.getElementById('bootstrap-js')) {
                const bootstrapJs = document.createElement('script');
                bootstrapJs.id = 'bootstrap-js';
                bootstrapJs.src = 'https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.bundle.min.js';
                bootstrapJs.onload = () => {
                    console.log('Bootstrap已成功加载');
                    // 重新初始化modal
                    this.initializeLoadGameModal();
                };
                document.body.appendChild(bootstrapJs);
            }
        }
    }
    /**
     * 初始化聊天世界书
     */
    async initializeChatLorebook() {
        try {
            console.log(`正在初始化固定世界书: ${this.worldBookName}`);
            // 检查API可用性
            if (typeof window.getLorebooks !== 'function' || typeof window.createLorebook !== 'function') {
                console.error('世界书API不可用，无法初始化聊天世界书');
                return;
            }
            // 获取所有世界书
            const lorebooks = await window.getLorebooks();
            // 检查我们的固定世界书是否存在
            const worldBookExists = lorebooks.includes(this.worldBookName);
            if (!worldBookExists) {
                // 创建新的世界书
                console.log(`创建新的固定世界书: ${this.worldBookName}`);
                await window.createLorebook(this.worldBookName);
                // 设置为当前聊天的世界书
                if (typeof window.setChatLorebook === 'function') {
                    await window.setChatLorebook(this.worldBookName);
                }
            }
            else {
                console.log(`找到现有的固定世界书: ${this.worldBookName}`);
                // 确保设置为当前聊天的世界书
                if (typeof window.setChatLorebook === 'function') {
                    await window.setChatLorebook(this.worldBookName);
                }
            }
            // 初始化当前最大存档ID
            await this.initializeMaxSaveIds();
        }
        catch (error) {
            console.error('初始化聊天世界书失败:', error);
        }
    }
    /**
     * 初始化最大存档ID
     */
    async initializeMaxSaveIds() {
        try {
            // 获取所有世界书条目
            const allEntries = await this.getAllWorldBookEntries();
            if (!allEntries || !allEntries.length)
                return;
            // 找出自动存档最大ID
            const autoSaves = allEntries.filter(entry => this.checkEntryKeyStartsWith(entry, this.SAVE_TYPE.AUTO));
            if (autoSaves.length > 0) {
                this.currentMaxSaveId.auto = Math.max(...autoSaves.map(entry => {
                    const idMatch = this.getEntryKey(entry).match(/(\d+)$/);
                    return idMatch ? parseInt(idMatch[1], 10) : 0;
                }));
            }
            // 找出手动存档最大ID
            const manualSaves = allEntries.filter(entry => this.checkEntryKeyStartsWith(entry, this.SAVE_TYPE.MANUAL));
            if (manualSaves.length > 0) {
                this.currentMaxSaveId.manual = Math.max(...manualSaves.map(entry => {
                    const idMatch = this.getEntryKey(entry).match(/(\d+)$/);
                    return idMatch ? parseInt(idMatch[1], 10) : 0;
                }));
            }
            console.log(`初始化存档ID: 自动存档=${this.currentMaxSaveId.auto}, 手动存档=${this.currentMaxSaveId.manual}`);
        }
        catch (error) {
            console.error('初始化最大存档ID失败:', error);
        }
    }
    /**
     * 辅助函数：获取实际使用的键值
     */
    getEntryKey(entry) {
        if (Array.isArray(entry.key) && entry.key.length > 0) {
            return entry.key[0];
        }
        else if (typeof entry.key === 'string') {
            return entry.key;
        }
        return '';
    }
    /**
     * 获取所有世界书条目
     */
    async getAllWorldBookEntries() {
        try {
            if (!this.worldBookName) {
                console.warn('无法获取世界书条目：世界书名为空');
                // 尝试重新初始化世界书
                await this.initializeChatLorebook();
                if (!this.worldBookName) {
                    return [];
                }
            }
            // 检查API可用性
            if (typeof window.getLorebookEntries !== 'function') {
                console.error('世界书API不可用：getLorebookEntries函数未定义');
                return [];
            }
            console.log(`正在获取世界书 ${this.worldBookName} 的所有条目...`);
            // 尝试获取世界书条目
            let entries;
            try {
                entries = await window.getLorebookEntries(this.worldBookName);
            }
            catch (apiError) {
                console.error(`调用getLorebookEntries API出错:`, apiError);
                // 如果失败，尝试使用triggerSlash作为后备方案
                if (typeof window.triggerSlash === 'function') {
                    try {
                        console.log('尝试使用triggerSlash作为后备方案获取条目');
                        const entriesJson = await window.triggerSlash(`/getlbentries ${this.worldBookName}`);
                        if (entriesJson) {
                            try {
                                entries = JSON.parse(entriesJson);
                            }
                            catch (parseError) {
                                console.error('解析triggerSlash返回结果失败:', parseError);
                            }
                        }
                    }
                    catch (slashError) {
                        console.error('使用triggerSlash获取条目失败:', slashError);
                    }
                }
            }
            // 检查获取到的条目
            if (!entries) {
                console.log(`没有从世界书 ${this.worldBookName} 获取到条目`);
                return [];
            }
            if (!Array.isArray(entries)) {
                console.error('获取的条目不是数组类型:', entries);
                return [];
            }
            console.log(`成功获取世界书条目，共 ${entries.length} 个`);
            // 检查每个条目是否有效
            if (entries.length > 0) {
                const invalidEntries = entries.filter(entry => !entry || !entry.uid || typeof entry.uid !== 'number');
                if (invalidEntries.length > 0) {
                    console.warn(`发现 ${invalidEntries.length} 个无效条目（缺少UID或UID类型错误）`);
                }
            }
            else {
                console.log('世界书条目为空，可能是新创建的世界书');
            }
            return entries;
        }
        catch (error) {
            console.error('获取世界书条目失败:', error);
            return [];
        }
    }
    /**
     * 检查条目键是否以指定前缀开头
     */
    checkEntryKeyStartsWith(entry, prefix) {
        if (!entry || !entry.key)
            return false;
        if (Array.isArray(entry.key)) {
            // 对于数组类型的key，检查是否有任意元素以prefix开头
            return entry.key.some((k) => k && typeof k === 'string' && k.startsWith(prefix));
        }
        else if (typeof entry.key === 'string') {
            // 对于字符串类型的key，直接检查
            return entry.key.startsWith(prefix);
        }
        return false;
    }
    /**
     * 根据键名查找条目
     */
    findEntryByKey(entries, exactKey) {
        if (!entries || !Array.isArray(entries)) {
            console.warn('查找条目时传入的条目列表无效');
            return null;
        }
        if (!exactKey) {
            console.warn('查找条目时传入的键名为空');
            return null;
        }
        const foundEntry = entries.find(entry => {
            if (!entry)
                return false;
            if (Array.isArray(entry.key)) {
                return entry.key.includes(exactKey);
            }
            return entry.key === exactKey;
        });
        if (foundEntry) {
            if (!foundEntry.uid || typeof foundEntry.uid !== 'number' || isNaN(foundEntry.uid)) {
                console.warn(`找到键名为 ${exactKey} 的条目，但其UID无效: ${foundEntry.uid}`);
            }
            else {
                console.log(`找到键名为 ${exactKey} 的条目，UID: ${foundEntry.uid}`);
            }
        }
        else {
            console.log(`未找到键名为 ${exactKey} 的条目`);
        }
        return foundEntry;
    }
    /**
     * 初始化加载游戏弹窗
     */
    initializeLoadGameModal() {
        // 检查是否已存在弹窗
        if ($(`#${this.modalId}`).length === 0) {
            // 创建弹窗
            const modalHtml = `
      <div id="${this.modalId}" class="modal fade" tabindex="-1" role="dialog" aria-labelledby="loadGameModalTitle" aria-hidden="true">
        <div class="modal-dialog modal-lg" role="document">
          <div class="modal-content">
            <div class="modal-header">
              <h5 class="modal-title" id="loadGameModalTitle"><i class="fas fa-book-open"></i> 修道院典籍记录</h5>
              <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                <span aria-hidden="true">&times;</span>
              </button>
            </div>
            <div class="modal-body">
              <div class="save-tabs">
                <button class="save-tab-btn active" data-tab="auto"><i class="fas fa-clock"></i> 时间记忆</button>
                <button class="save-tab-btn" data-tab="manual"><i class="fas fa-bookmark"></i> 永久典籍</button>
              </div>
              <div class="save-tab-content">
                <div id="auto-saves-container" class="save-tab-pane active">
                  <ul id="auto-save-list" class="save-list">
                    <li class="save-item empty">暂无自动记录点</li>
                  </ul>
                </div>
                <div id="manual-saves-container" class="save-tab-pane">
                  <ul id="manual-save-list" class="save-list">
                    <li class="save-item empty">暂无手动保存的典籍</li>
                  </ul>
                </div>
              </div>
            </div>
            <div class="modal-footer">
              <button type="button" class="btn btn-primary" id="btn-create-manual-save">
                <i class="fas fa-feather-alt"></i> 记录当前典籍
              </button>
              <button type="button" class="btn btn-secondary" data-dismiss="modal">关闭</button>
            </div>
          </div>
        </div>
      </div>`;
            // 添加到页面
            $('body').append(modalHtml);
            // 确保模态框样式正确
            const modalStyles = `
        <style>
          #${this.modalId} {
            background-color: rgba(0, 0, 0, 0.5);
          }
          #${this.modalId}.show {
            display: block !important;
          }
          .save-tabs {
            display: flex;
            border-bottom: 1px solid #dee2e6;
            margin-bottom: 15px;
          }
          .save-tab-btn {
            background: none;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            outline: none;
          }
          .save-tab-btn.active {
            border-bottom: 2px solid #5d6e41;
          }
          .save-tab-pane {
            display: none;
          }
          .save-tab-pane.active {
            display: block;
          }
          .save-list {
            list-style: none;
            padding: 0;
          }
          .save-item {
            margin-bottom: 10px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            cursor: pointer;
            transition: box-shadow 0.3s;
          }
          .save-item:hover {
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
          }
          .save-item.empty {
            color: #6c757d;
            cursor: default;
            text-align: center;
          }
          .save-item-thumbnail {
            height: 120px;
            background-size: cover;
            background-position: center;
            border-radius: 4px;
          }
          .save-item-header {
            display: flex;
            justify-content: space-between;
            margin: 10px 0 5px;
          }
          .save-item-title {
            font-weight: bold;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
          }
          .save-item-date {
            font-size: 0.8em;
            color: #6c757d;
          }
          .save-item-content {
            font-size: 0.9em;
            color: #333;
            margin-bottom: 10px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
          }
          .save-item-actions {
            display: flex;
            justify-content: space-between;
          }
          .btn-load, .btn-delete {
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
          }
          .btn-load {
            background-color: #5d6e41;
            color: white;
          }
          .btn-delete {
            background-color: #dc3545;
            color: white;
          }
        </style>
      `;
            $('head').append(modalStyles);
            // 移除原有事件绑定，防止重复绑定
            $(document).off('click', `#${this.modalId} .save-tab-btn`);
            $(document).off('click', '#btn-create-manual-save');
            // 重新绑定标签切换事件
            $(document).on('click', `#${this.modalId} .save-tab-btn`, e => {
                const tabId = $(e.currentTarget).data('tab');
                $(`#${this.modalId} .save-tab-btn`).removeClass('active');
                $(`#${this.modalId} .save-tab-pane`).removeClass('active');
                $(e.currentTarget).addClass('active');
                if (tabId === 'auto') {
                    $(`#auto-saves-container`).addClass('active');
                }
                else {
                    $(`#manual-saves-container`).addClass('active');
                }
            });
            // 绑定创建手动存档按钮事件
            $(document).on('click', '#btn-create-manual-save', () => {
                console.log('创建手动存档按钮被点击');
                this.createManualSave();
            });
            // 绑定关闭按钮事件
            $(document).on('click', `#${this.modalId} .close, #${this.modalId} .btn-secondary`, () => {
                this.closeLoadGameModal();
            });
            // 如果点击模态框外部，关闭模态框
            $(document).on('click', `#${this.modalId}`, e => {
                if ($(e.target).attr('id') === this.modalId) {
                    this.closeLoadGameModal();
                }
            });
            console.log(`加载游戏弹窗已初始化，ID: ${this.modalId}`);
        }
    }
    /**
     * 关闭加载游戏弹窗
     */
    closeLoadGameModal() {
        if (typeof $.fn.modal === 'function') {
            $(`#${this.modalId}`).modal('hide');
        }
        else {
            $(`#${this.modalId}`).css('display', 'none').removeClass('show');
        }
    }
    /**
     * 创建手动存档
     */
    async createManualSave() {
        try {
            console.log('开始创建手动存档流程');
            // 显示确认对话框，让用户填写存档名称
            this.uiManager.showInputDialog('请输入典籍标题', '手动存档', async (saveName) => {
                console.log('用户输入的存档名称:', saveName);
                if (!saveName) {
                    saveName = '手动存档';
                    console.log('使用默认存档名称:', saveName);
                }
                this.uiManager.showLoading('正在记录典籍...');
                try {
                    // 获取当前游戏状态
                    console.log('获取当前游戏状态');
                    const gameData = await this.getCurrentGameData();
                    if (!gameData) {
                        console.error('无法获取当前游戏状态');
                        this.uiManager.showNotification('无法获取当前游戏状态', 'error');
                        return;
                    }
                    console.log('成功获取当前游戏状态，准备保存');
                    // 保存游戏状态
                    const saveResult = await this.saveGameState(gameData, true, saveName);
                    if (saveResult) {
                        console.log('手动存档成功保存');
                        this.uiManager.showNotification(`典籍"${saveName}"已成功记录`, 'success');
                        // 重新加载存档列表
                        console.log('刷新存档列表');
                        this.refreshSaveList();
                    }
                    else {
                        console.error('保存游戏状态失败');
                        this.uiManager.showNotification('记录典籍失败', 'error');
                    }
                }
                catch (error) {
                    console.error('创建手动存档失败:', error);
                    this.uiManager.showNotification('记录典籍失败', 'error');
                }
                finally {
                    this.uiManager.hideLoading();
                }
            });
        }
        catch (error) {
            console.error('创建手动存档流程出错:', error);
            this.uiManager.showNotification('记录典籍失败', 'error');
        }
    }
    /**
     * 获取当前游戏数据
     */
    async getCurrentGameData() {
        // 这里需要从游戏控制器中获取当前游戏数据
        // 为简化实现，暂时通过自定义事件获取
        return new Promise(resolve => {
            // 创建自定义事件，请求当前游戏数据
            const requestEvent = new CustomEvent('request_game_data', {
                detail: { callback: (gameData) => resolve(gameData) },
            });
            window.dispatchEvent(requestEvent);
            // 如果5秒内没有响应，返回null
            setTimeout(() => resolve(null), 5000);
        });
    }
    /**
     * 显示加载游戏弹窗
     */
    async showLoadGameModal() {
        try {
            this.uiManager.showLoading('正在获取存档列表...');
            // 先刷新存档列表
            await this.refreshSaveList();
            // 确保jQuery和Bootstrap正确加载
            this.ensureBootstrapLoaded();
            // 检查modal方法是否可用
            if (typeof $.fn.modal !== 'function') {
                console.log('Bootstrap modal方法不可用，使用替代方法显示弹窗');
                // 替代方法：直接显示元素
                const modalElement = $(`#${this.modalId}`);
                modalElement
                    .css({
                    display: 'block',
                    'padding-right': '17px',
                })
                    .addClass('show');
                // 添加overflow样式到body
                $('body').addClass('modal-open').css('overflow', 'hidden');
            }
            else {
                console.log('使用Bootstrap modal方法显示弹窗');
                // 使用Bootstrap的modal方法
                try {
                    $(`#${this.modalId}`).modal('show');
                }
                catch (modalError) {
                    console.error('显示modal出错:', modalError);
                    // 后备方案：直接显示元素
                    $(`#${this.modalId}`)
                        .css({
                        display: 'block',
                        'padding-right': '17px',
                    })
                        .addClass('show');
                    // 添加overflow样式到body
                    $('body').addClass('modal-open').css('overflow', 'hidden');
                }
            }
            this.uiManager.hideLoading();
        }
        catch (error) {
            console.error('显示加载游戏弹窗失败:', error);
            this.uiManager.showNotification('获取存档列表失败', 'error');
            this.uiManager.hideLoading();
        }
    }
    /**
     * 刷新存档列表
     */
    async refreshSaveList() {
        try {
            // 获取所有存档
            const { autoSaves, manualSaves } = await this.getAllSaves();
            // 更新自动存档列表
            const $autoSaveList = $('#auto-save-list');
            $autoSaveList.empty();
            if (autoSaves.length === 0) {
                $autoSaveList.append('<li class="save-item empty">暂无自动存档</li>');
            }
            else {
                // 按ID倒序排列，最新的存档在最前面
                const sortedAutoSaves = autoSaves.sort((a, b) => b.saveId - a.saveId);
                for (const save of sortedAutoSaves) {
                    this.appendSaveItem($autoSaveList, save);
                }
            }
            // 更新手动存档列表
            const $manualSaveList = $('#manual-save-list');
            $manualSaveList.empty();
            if (manualSaves.length === 0) {
                $manualSaveList.append('<li class="save-item empty">暂无手动存档</li>');
            }
            else {
                // 按ID倒序排列，最新的存档在最前面
                const sortedManualSaves = manualSaves.sort((a, b) => b.saveId - a.saveId);
                for (const save of sortedManualSaves) {
                    this.appendSaveItem($manualSaveList, save);
                }
            }
        }
        catch (error) {
            console.error('刷新存档列表失败:', error);
            throw error;
        }
    }
    /**
     * 添加存档项到列表
     */
    appendSaveItem($list, save) {
        // 生成缩略图URL
        let thumbnailUrl = '';
        if (save.thumbnail) {
            thumbnailUrl = save.thumbnail;
        }
        else {
            // 使用默认图片，根据存档类型选择不同的默认图片
            thumbnailUrl = save.isAuto
                ? 'https://gitgud.io/lolodesu/lolobabytutorial/-/raw/master/lologame/%E8%83%8C%E6%99%AF/%E4%B9%A6%E5%BA%97%E5%86%85/%E4%B9%A6%E5%BA%97.jpg?ref_type=heads'
                : 'https://gitgud.io/lolodesu/lolobabytutorial/-/raw/master/lologame/%E8%83%8C%E6%99%AF/%E5%85%AC%E5%9B%AD/%E7%99%BD%E5%A4%A9.jpg?ref_type=heads';
        }
        const $saveItem = $('<li>', {
            class: 'save-item',
            'data-key': save.key,
        });
        // 添加缩略图
        $('<div>', {
            class: 'save-item-thumbnail',
            style: `background-image: url(${thumbnailUrl})`,
        }).appendTo($saveItem);
        // 添加标题和日期
        const $header = $('<div>', { class: 'save-item-header' });
        $('<div>', {
            class: 'save-item-title',
            text: save.title,
        }).appendTo($header);
        $('<div>', {
            class: 'save-item-date',
            text: save.date,
        }).appendTo($header);
        $header.appendTo($saveItem);
        // 添加内容摘要
        $('<div>', {
            class: 'save-item-content',
            text: save.content || '无可用内容',
        }).appendTo($saveItem);
        // 添加操作按钮
        const $actions = $('<div>', { class: 'save-item-actions' });
        // 创建加载按钮
        const $loadBtn = $('<button>', {
            class: 'btn-load',
            html: '<i class="fas fa-book-reader"></i> 阅读',
            'data-key': save.key,
        });
        // 创建删除按钮
        const $deleteBtn = $('<button>', {
            class: 'btn-delete',
            html: '<i class="fas fa-trash-alt"></i> 销毁',
            'data-key': save.key,
            'data-title': save.title,
        });
        // 将按钮添加到操作区域
        $actions.append($loadBtn).append($deleteBtn);
        $actions.appendTo($saveItem);
        // 将整个存档项添加到列表
        $list.append($saveItem);
        // 使用直接事件绑定，避免使用on代理导致的问题
        $loadBtn.on('click', e => {
            e.preventDefault();
            e.stopPropagation();
            console.log('点击加载按钮，key:', save.key);
            this.loadGameFromKey(save.key);
            return false;
        });
        $deleteBtn.on('click', e => {
            e.preventDefault();
            e.stopPropagation();
            console.log('点击删除按钮，key:', save.key, 'title:', save.title);
            this.deleteSave(save.key, save.title);
            return false;
        });
        // 为整个存档项添加点击事件
        $saveItem.on('click', e => {
            // 如果点击的是操作按钮，不进行处理
            if ($(e.target).closest('.save-item-actions').length > 0) {
                return;
            }
            // 否则触发加载存档
            console.log('点击存档项，key:', save.key);
            this.loadGameFromKey(save.key);
        });
    }
    /**
     * 删除存档
     */
    async deleteSave(saveKey, saveTitle) {
        try {
            console.log('准备删除存档，key:', saveKey, 'title:', saveTitle);
            // 确认删除
            this.uiManager.showConfirmDialog(`确定要销毁典籍"${saveTitle}"吗？此操作不可逆。`, async () => {
                console.log('用户确认删除存档，开始删除过程');
                this.uiManager.showLoading('正在销毁典籍...');
                try {
                    const allEntries = await window.getLorebookEntries(this.worldBookName);
                    const saveEntry = this.findEntryByKey(allEntries, saveKey);
                    if (saveEntry && saveEntry.uid) {
                        console.log(`找到存档条目，准备删除 UID=${saveEntry.uid}`);
                        await window.deleteLorebookEntry(this.worldBookName, saveEntry.uid);
                        // 刷新存档列表
                        await this.refreshSaveList();
                        this.uiManager.showNotification(`典籍"${saveTitle}"已成功销毁`, 'success');
                    }
                    else {
                        console.error('找不到要删除的存档条目');
                        this.uiManager.showNotification('找不到指定的典籍记录', 'error');
                    }
                }
                catch (error) {
                    console.error('删除存档过程中出错:', error);
                    this.uiManager.showNotification('销毁典籍失败: ' + (error instanceof Error ? error.message : '未知错误'), 'error');
                }
                finally {
                    this.uiManager.hideLoading();
                }
            });
        }
        catch (error) {
            console.error('删除存档过程出错:', error);
            this.uiManager.showNotification('销毁典籍失败', 'error');
        }
    }
    /**
     * 获取所有游戏存档
     */
    async getAllSaves() {
        try {
            // 确保聊天世界书已初始化
            if (!this.worldBookName) {
                await this.initializeChatLorebook();
            }
            // 检查API是否可用
            if (!this.worldBookName || typeof window.getLorebookEntries !== 'function') {
                console.warn('世界书API不可用，无法获取存档');
                return { autoSaves: [], manualSaves: [] };
            }
            // 获取所有世界书条目
            const allEntries = await this.getAllWorldBookEntries();
            if (!allEntries || !Array.isArray(allEntries) || allEntries.length === 0) {
                return { autoSaves: [], manualSaves: [] };
            }
            // 筛选出自动存档条目
            const autoSaveEntries = allEntries.filter(entry => this.checkEntryKeyStartsWith(entry, this.SAVE_TYPE.AUTO));
            // 筛选出手动存档条目
            const manualSaveEntries = allEntries.filter(entry => this.checkEntryKeyStartsWith(entry, this.SAVE_TYPE.MANUAL));
            console.log(`找到 ${autoSaveEntries.length} 个自动存档和 ${manualSaveEntries.length} 个手动存档`);
            // 处理自动存档数据
            const autoSaves = await Promise.all(autoSaveEntries.map(entry => this.processSaveEntry(entry, true)));
            // 处理手动存档数据
            const manualSaves = await Promise.all(manualSaveEntries.map(entry => this.processSaveEntry(entry, false)));
            // 过滤掉处理失败的存档并按ID排序
            return {
                autoSaves: autoSaves.filter(save => save !== null).sort((a, b) => b.saveId - a.saveId),
                manualSaves: manualSaves.filter(save => save !== null).sort((a, b) => b.saveId - a.saveId),
            };
        }
        catch (error) {
            console.error('获取存档列表失败:', error);
            return { autoSaves: [], manualSaves: [] };
        }
    }
    /**
     * 处理存档条目
     */
    async processSaveEntry(entry, isAuto) {
        try {
            if (!entry || !entry.key) {
                console.warn('无效的存档条目:', entry);
                return null;
            }
            // 获取键值（可能是字符串或数组）
            let entryKey = '';
            if (Array.isArray(entry.key) && entry.key.length > 0) {
                // 查找符合条件的键
                const prefix = isAuto ? this.SAVE_TYPE.AUTO : this.SAVE_TYPE.MANUAL;
                const matchingKey = entry.key.find((k) => k && typeof k === 'string' && k.startsWith(prefix));
                if (matchingKey) {
                    entryKey = matchingKey;
                }
                else {
                    entryKey = entry.key[0]; // 默认使用第一个键
                }
            }
            else if (typeof entry.key === 'string') {
                entryKey = entry.key;
            }
            else {
                console.warn('无效的键值类型:', entry.key);
                return null;
            }
            // 从键中提取存档ID
            const idMatch = entryKey.match(/(\d+)$/);
            const saveId = idMatch ? parseInt(idMatch[1], 10) : 0;
            // 获取简要内容用于显示
            const savePreview = {
                key: entryKey,
                uid: entry.uid, // 保存UID用于后续操作
                title: entry.comment || (isAuto ? `自动记录点 #${saveId}` : `永久典籍 #${saveId}`),
                saveId: saveId,
                date: new Date(entry.created_at || Date.now()).toLocaleString(),
                content: '',
                thumbnail: '',
                isAuto: isAuto,
            };
            // 尝试获取存档内容的摘要和缩略图
            try {
                // 优先使用条目的直接内容
                let content = '';
                if (entry.content) {
                    content = entry.content;
                }
                else if (typeof window.triggerSlash === 'function') {
                    content = await window.triggerSlash(`/getentryfield file=${this.worldBookName} field=content ${entryKey}`);
                }
                if (content) {
                    try {
                        const gameData = JSON.parse(content);
                        if (gameData.storySummary && gameData.storySummary.length > 0) {
                            const latestSummary = gameData.storySummary[gameData.storySummary.length - 1];
                            savePreview.content = latestSummary.content;
                            // 如果有图片，则使用该图片作为缩略图
                            if (latestSummary.image) {
                                savePreview.thumbnail = latestSummary.image;
                            }
                        }
                    }
                    catch (jsonError) {
                        console.warn('解析存档内容失败:', jsonError);
                    }
                }
            }
            catch (error) {
                console.warn('无法获取存档内容摘要:', error);
            }
            return savePreview;
        }
        catch (error) {
            console.error('处理存档数据出错:', error);
            return null;
        }
    }
    /**
     * 从存档键加载游戏
     */
    async loadGameFromKey(saveKey) {
        try {
            console.log('准备加载存档，key:', saveKey);
            // 确认加载
            this.uiManager.showConfirmDialog('确定要加载此存档吗？当前游戏进度将丢失。', async () => {
                console.log('用户确认加载存档，开始加载过程');
                this.uiManager.showLoading('正在加载存档...');
                try {
                    // 加载游戏状态
                    const gameData = await this.loadGameState(saveKey);
                    if (gameData) {
                        console.log('存档加载成功，准备关闭弹窗并更新游戏状态');
                        // 关闭弹窗
                        this.closeLoadGameModal();
                        // 触发加载完成事件，传递游戏数据给游戏控制器
                        console.log('触发gameloaded事件');
                        const loadEvent = new CustomEvent('gameloaded', {
                            detail: { gameData },
                        });
                        window.dispatchEvent(loadEvent);
                        this.uiManager.showNotification('加载存档成功', 'success');
                    }
                    else {
                        console.error('加载游戏状态失败，gameData为null');
                        this.uiManager.showNotification('加载存档失败', 'error');
                    }
                }
                catch (error) {
                    console.error('加载存档处理过程中出错:', error);
                    this.uiManager.showNotification('加载存档失败: ' + (error instanceof Error ? error.message : '未知错误'), 'error');
                }
                finally {
                    this.uiManager.hideLoading();
                }
            });
        }
        catch (error) {
            console.error('加载存档过程出错:', error);
            this.uiManager.showNotification('加载存档失败', 'error');
        }
    }
    /**
     * 将当前游戏状态保存到世界书
     * @param gameData 游戏数据
     * @param isManual 是否为手动存档
     * @param customName 自定义存档名称（仅用于手动存档）
     */
    async saveGameState(gameData, isManual = false, customName) {
        if (!gameData || !gameData.storySummary || gameData.storySummary.length === 0) {
            console.warn('没有可保存的游戏状态');
            return false;
        }
        try {
            // 确保聊天世界书已初始化
            if (!this.worldBookName) {
                console.log('世界书名称为空，重新初始化');
                await this.initializeChatLorebook();
                if (!this.worldBookName) {
                    console.error('初始化世界书失败，无法保存游戏状态');
                    this.uiManager.showNotification('无法初始化世界书，保存失败', 'error');
                    return false;
                }
            }
            // 检查世界书API是否可用
            if (typeof window.getLorebookEntries !== 'function') {
                console.error('世界书API不可用');
                this.uiManager.showNotification('世界书API不可用，无法保存游戏状态', 'error');
                return false;
            }
            // 根据保存类型确定存档ID和键名前缀
            const saveType = isManual ? this.SAVE_TYPE.MANUAL : this.SAVE_TYPE.AUTO;
            const nextId = isManual ? ++this.currentMaxSaveId.manual : ++this.currentMaxSaveId.auto;
            const saveKey = `${saveType}${nextId}`;
            // 创建存档名称
            let saveName = '';
            let dialogueCount = gameData.story.dialogue.length;
            let memoriesCount = gameData.storySummary.length;
            if (isManual && customName) {
                saveName = `${customName} #${nextId} [对话:${dialogueCount}条|记忆:${memoriesCount}条]`;
            }
            else if (isManual) {
                saveName = `手动存档 #${nextId} [对话:${dialogueCount}条|记忆:${memoriesCount}条]`;
            }
            else {
                // 自动存档名称，格式为"自动存档#ID-记忆描述"
                const latestSummary = gameData.storySummary[gameData.storySummary.length - 1];
                const shortDescription = latestSummary.content.substring(0, 30) + (latestSummary.content.length > 30 ? '...' : '');
                saveName = `自动存档 #${nextId}-${shortDescription} [对话:${dialogueCount}条|记忆:${memoriesCount}条]`;
            }
            // 先保存完整历史记录，确保对话历史和游戏状态同步
            await this.saveDialogueHistory(gameData);
            // 准备保存数据
            const saveData = JSON.stringify(gameData);
            // 记录开始保存时间，用于超时判断
            const startTime = Date.now();
            const MAX_RETRY = 3;
            const TIMEOUT_MS = 10000; // 10秒超时
            for (let retry = 0; retry < MAX_RETRY; retry++) {
                try {
                    // 获取所有条目，检查是否已存在相同key的条目
                    console.log(`获取世界书条目，尝试 ${retry + 1}/${MAX_RETRY}`);
                    const allEntries = await window.getLorebookEntries(this.worldBookName);
                    const saveEntry = this.findEntryByKey(allEntries, saveKey);
                    // 设定一个Promise，当超时时拒绝
                    const saveWithTimeout = async (promise) => {
                        const timeout = new Promise((_, reject) => {
                            setTimeout(() => reject(new Error('操作超时')), TIMEOUT_MS);
                        });
                        return Promise.race([promise, timeout]);
                    };
                    // 如果存在相同key的条目，更新而不是创建新条目
                    if (saveEntry) {
                        console.log(`存档 ${saveKey} 已存在，将更新条目 uid=${saveEntry.uid}`);
                        if (typeof saveEntry.uid !== 'number' || isNaN(saveEntry.uid)) {
                            throw new Error(`无效的UID: ${saveEntry.uid}`);
                        }
                        // 创建需要更新的条目对象
                        const updateEntry = {
                            uid: saveEntry.uid,
                            comment: saveName,
                            content: saveData,
                        };
                        try {
                            if (typeof window.setLorebookEntries === 'function') {
                                await saveWithTimeout(window.setLorebookEntries(this.worldBookName, [updateEntry]));
                                console.log(`成功更新条目 UID=${saveEntry.uid}`);
                                // 更新成功，跳出重试循环
                                break;
                            }
                            else if (typeof window.editLorebookEntry === 'function') {
                                await saveWithTimeout(window.editLorebookEntry(this.worldBookName, saveEntry.uid, {
                                    comment: saveName,
                                    content: saveData,
                                }));
                                console.log(`成功更新条目 UID=${saveEntry.uid} (使用editLorebookEntry)`);
                                break;
                            }
                            else {
                                // 如果没有更新API，则删除后重建
                                await saveWithTimeout(window.deleteLorebookEntry(this.worldBookName, saveEntry.uid));
                                const newUid = await saveWithTimeout(window.createLorebookEntry(this.worldBookName, {
                                    key: [saveKey],
                                    comment: saveName,
                                    content: saveData,
                                }));
                                if (newUid > 0) {
                                    console.log(`成功删除旧条目并创建新条目 UID=${newUid}`);
                                    break;
                                }
                                else {
                                    throw new Error(`创建新条目失败，返回的UID无效: ${newUid}`);
                                }
                            }
                        }
                        catch (updateError) {
                            console.error(`更新条目尝试 ${retry + 1} 失败:`, updateError);
                            // 如果不是最后一次尝试，等待后重试
                            if (retry < MAX_RETRY - 1) {
                                console.log(`等待500ms后重试...`);
                                await new Promise(resolve => setTimeout(resolve, 500));
                            }
                            else {
                                throw updateError; // 最后一次尝试失败，向上抛出错误
                            }
                        }
                    }
                    else {
                        // 创建新条目
                        console.log(`存档 ${saveKey} 不存在，将创建新条目`);
                        // 准备创建的条目对象
                        const newEntry = {
                            key: [saveKey],
                            comment: saveName,
                            content: saveData,
                        };
                        try {
                            let success = false;
                            // 尝试使用新API创建条目
                            if (typeof window.createLorebookEntries === 'function') {
                                const result = await saveWithTimeout(window.createLorebookEntries(this.worldBookName, [newEntry]));
                                if (result && result.new_uids && result.new_uids.length > 0) {
                                    console.log(`成功创建新条目，UID=${result.new_uids[0]}`);
                                    success = true;
                                }
                                else {
                                    console.warn('createLorebookEntries返回结果无效，将尝试旧API');
                                }
                            }
                            // 如果新API失败或不可用，尝试旧API
                            if (!success && typeof window.createLorebookEntry === 'function') {
                                const uid = await saveWithTimeout(window.createLorebookEntry(this.worldBookName, newEntry));
                                if (uid > 0) {
                                    console.log(`成功创建新条目，UID=${uid}`);
                                    success = true;
                                }
                                else {
                                    throw new Error(`创建条目失败，返回的UID无效: ${uid}`);
                                }
                            }
                            if (success) {
                                break; // 创建成功，跳出重试循环
                            }
                            else {
                                throw new Error('没有可用的API创建条目');
                            }
                        }
                        catch (createError) {
                            console.error(`创建条目尝试 ${retry + 1} 失败:`, createError);
                            // 如果不是最后一次尝试，等待后重试
                            if (retry < MAX_RETRY - 1) {
                                console.log(`等待500ms后重试...`);
                                await new Promise(resolve => setTimeout(resolve, 500));
                            }
                            else {
                                throw createError; // 最后一次尝试失败，向上抛出错误
                            }
                        }
                    }
                }
                catch (error) {
                    // 处理最后一次失败的情况
                    if (retry === MAX_RETRY - 1) {
                        throw error;
                    }
                }
            }
            // 保存成功，记录当前ID
            if (isManual) {
                this.currentMaxSaveId.manual = nextId;
            }
            else {
                this.currentMaxSaveId.auto = nextId;
            }
            console.log(`已成功保存游戏状态到世界书，包含 ${dialogueCount} 条对话和 ${memoriesCount} 条记忆`);
            return true;
        }
        catch (error) {
            console.error('保存游戏状态到世界书失败:', error);
            this.uiManager.showNotification('保存游戏状态失败: ' + (error instanceof Error ? error.message : '未知错误'), 'error');
            return false;
        }
    }
    /**
     * 加载完整历史记录
     */
    async loadCompleteHistory() {
        try {
            // 如果已有缓存记录，直接返回
            if (this.cachedCompleteHistory) {
                return this.cachedCompleteHistory;
            }
            // 确保聊天世界书已初始化
            if (!this.worldBookName) {
                await this.initializeChatLorebook();
            }
            // 检查API是否可用
            if (typeof window.getLorebookEntries !== 'function') {
                console.warn('世界书API不可用，无法加载完整历史记录');
                return null;
            }
            // 获取所有世界书条目
            const allEntries = await window.getLorebookEntries(this.worldBookName);
            if (!allEntries || !Array.isArray(allEntries)) {
                console.warn('未找到世界书条目');
                return null;
            }
            // 查找完整历史记录条目
            const historyEntry = this.findEntryByKey(allEntries, this.COMPLETE_HISTORY_KEY);
            if (!historyEntry) {
                console.log('未找到完整历史记录条目，将创建新记录');
                // 创建新的完整历史记录
                const newHistory = {
                    id: `history_${Date.now()}`,
                    dialogues: [],
                    memories: [],
                };
                this.cachedCompleteHistory = newHistory;
                return newHistory;
            }
            // 获取条目内容
            let historyContent = '';
            // 尝试获取条目内容
            if (historyEntry.content) {
                historyContent = historyEntry.content;
            }
            else if (typeof window.triggerSlash === 'function') {
                // 使用triggerSlash获取
                historyContent = await window.triggerSlash(`/getentryfield file=${this.worldBookName} field=content ${this.COMPLETE_HISTORY_KEY}`);
            }
            if (!historyContent) {
                console.log('完整历史记录内容为空，将创建新记录');
                // 创建新的完整历史记录
                const newHistory = {
                    id: `history_${Date.now()}`,
                    dialogues: [],
                    memories: [],
                };
                this.cachedCompleteHistory = newHistory;
                return newHistory;
            }
            try {
                // 解析JSON内容
                const history = JSON.parse(historyContent);
                if (!history.id || !Array.isArray(history.dialogues) || !Array.isArray(history.memories)) {
                    throw new Error('历史记录格式不正确');
                }
                console.log(`成功加载完整历史记录，包含 ${history.dialogues.length} 条对话和 ${history.memories.length} 条记忆`);
                this.cachedCompleteHistory = history;
                return history;
            }
            catch (parseError) {
                console.error('解析完整历史记录失败:', parseError);
                // 创建新的完整历史记录
                const newHistory = {
                    id: `history_${Date.now()}`,
                    dialogues: [],
                    memories: [],
                };
                this.cachedCompleteHistory = newHistory;
                return newHistory;
            }
        }
        catch (error) {
            console.error('加载完整历史记录失败:', error);
            return null;
        }
    }
    /**
     * 保存完整历史记录
     */
    async saveCompleteHistory(history) {
        try {
            // 确保聊天世界书已初始化
            if (!this.worldBookName) {
                await this.initializeChatLorebook();
            }
            // 检查API是否可用
            if (!this.worldBookName || typeof window.getLorebookEntries !== 'function') {
                console.warn('世界书API不可用，无法保存完整历史记录');
                return false;
            }
            // 获取所有世界书条目
            const allEntries = await window.getLorebookEntries(this.worldBookName);
            // 查找完整历史记录条目
            const historyEntry = this.findEntryByKey(allEntries, this.COMPLETE_HISTORY_KEY);
            // 历史记录标题
            const historyTitle = `完整游戏历史记录 - 最后更新: ${new Date().toLocaleString()}`;
            // 转换为JSON字符串
            const historyContent = JSON.stringify(history);
            if (historyEntry) {
                // 更新现有条目
                if (typeof window.editLorebookEntry === 'function') {
                    await window.editLorebookEntry(this.worldBookName, historyEntry.uid, {
                        comment: historyTitle,
                        content: historyContent,
                    });
                }
                else {
                    // 回退到旧API：删除并重建
                    await window.deleteLorebookEntry(this.worldBookName, historyEntry.uid);
                    await window.createLorebookEntry(this.worldBookName, {
                        keys: [this.COMPLETE_HISTORY_KEY],
                        comment: historyTitle,
                        content: historyContent,
                    });
                }
                console.log('更新了完整历史记录');
            }
            else {
                // 创建新条目
                await window.createLorebookEntry(this.worldBookName, {
                    keys: [this.COMPLETE_HISTORY_KEY],
                    comment: historyTitle,
                    content: historyContent,
                });
                console.log('创建了新的完整历史记录条目');
            }
            // 更新缓存
            this.cachedCompleteHistory = history;
            return true;
        }
        catch (error) {
            console.error('保存完整历史记录失败:', error);
            return false;
        }
    }
    /**
     * 保存对话历史到世界书
     * 使用完整历史记录存储所有对话和记忆
     */
    async saveDialogueHistory(gameData) {
        if (!gameData.story || !gameData.story.dialogue) {
            console.warn('没有可保存的对话历史');
            return false;
        }
        try {
            // 加载当前的完整历史记录
            let completeHistory = await this.loadCompleteHistory();
            if (!completeHistory) {
                // 创建新的完整历史记录
                completeHistory = {
                    id: `history_${Date.now()}`,
                    dialogues: [],
                    memories: [],
                };
            }
            // 添加所有对话到历史记录（避免重复）
            const existingDialogueCount = completeHistory.dialogues.length;
            // 转换所有对话为简化格式
            const allDialogues = gameData.story.dialogue.map(dialogue => ({
                speaker: dialogue.speaker,
                content: dialogue.content,
                style: dialogue.style,
            }));
            // 避免重复添加对话，只添加新的对话
            if (existingDialogueCount < allDialogues.length) {
                completeHistory.dialogues = allDialogues;
                console.log(`更新对话历史：从 ${existingDialogueCount} 条增加到 ${allDialogues.length} 条`);
            }
            // 添加所有记忆点到历史记录（避免重复）
            if (gameData.storySummary && gameData.storySummary.length > 0) {
                // 映射现有记忆点的ID
                const existingMemoryIds = new Set(completeHistory.memories.map(m => m.id));
                // 添加不存在的新记忆点
                for (const memory of gameData.storySummary) {
                    if (!existingMemoryIds.has(memory.id)) {
                        completeHistory.memories.push({
                            id: memory.id,
                            content: memory.content,
                        });
                        existingMemoryIds.add(memory.id);
                    }
                }
                console.log(`更新记忆历史：当前共有 ${completeHistory.memories.length} 条记忆`);
            }
            // 保存完整历史记录
            const saveResult = await this.saveCompleteHistory(completeHistory);
            // 同时更新旧版对话历史记录格式（向后兼容）
            await this.saveLegacyDialogueHistory(gameData, completeHistory);
            return saveResult;
        }
        catch (error) {
            console.error('保存对话历史到世界书失败:', error);
            return false;
        }
    }
    /**
     * 保存旧版格式的对话历史（向后兼容）
     */
    async saveLegacyDialogueHistory(gameData, completeHistory) {
        try {
            // 确保聊天世界书已初始化
            if (!this.worldBookName) {
                await this.initializeChatLorebook();
            }
            // 检查API是否可用
            if (!this.worldBookName || typeof window.getLorebookEntries !== 'function') {
                console.warn('世界书API不可用，无法保存旧版对话历史');
                return false;
            }
            // 获取所有世界书条目
            const allEntries = await window.getLorebookEntries(this.worldBookName);
            // 查找对话历史条目
            const dialogueHistoryEntry = this.findEntryByKey(allEntries, this.DIALOGUE_HISTORY_KEY);
            // 构建旧版日志格式
            let logContent = '';
            for (const dialogue of completeHistory.dialogues) {
                if (dialogue.speaker === '玩家') {
                    logContent += `选择:${dialogue.content};`;
                }
                else {
                    logContent += `${dialogue.speaker}:${dialogue.content};`;
                }
            }
            // 添加记忆穿越点
            for (const memory of completeHistory.memories) {
                if (memory.content.includes('穿越') || memory.content.includes('回到')) {
                    logContent += `回到过去:${memory.content};`;
                }
            }
            // 对话历史标题
            const dialogueTitle = `对话历史记录 - ${new Date().toLocaleString()}`;
            // 包装为旧版格式
            const updatedContent = `<log>${logContent}</log>`;
            // 更新或创建条目
            try {
                if (dialogueHistoryEntry) {
                    // 更新现有条目
                    if (typeof window.editLorebookEntry === 'function') {
                        await window.editLorebookEntry(this.worldBookName, dialogueHistoryEntry.uid, {
                            comment: dialogueTitle,
                            content: updatedContent,
                        });
                    }
                    else {
                        // 回退到旧API：删除并重建
                        await window.deleteLorebookEntry(this.worldBookName, dialogueHistoryEntry.uid);
                        await window.createLorebookEntry(this.worldBookName, {
                            keys: [this.DIALOGUE_HISTORY_KEY],
                            comment: dialogueTitle,
                            content: updatedContent,
                        });
                    }
                    console.log('更新了旧版对话历史记录');
                }
                else {
                    // 创建新条目
                    await window.createLorebookEntry(this.worldBookName, {
                        keys: [this.DIALOGUE_HISTORY_KEY],
                        comment: dialogueTitle,
                        content: updatedContent,
                    });
                    console.log('创建了新的旧版对话历史记录条目');
                }
                return true;
            }
            catch (error) {
                console.error('保存旧版对话历史失败:', error);
                return false;
            }
        }
        catch (error) {
            console.error('保存旧版对话历史到世界书失败:', error);
            return false;
        }
    }
    /**
     * 从世界书获取对话历史
     * 优先使用新的完整历史记录格式
     */
    async getDialogueHistory() {
        try {
            // 先尝试获取完整历史记录
            const completeHistory = await this.loadCompleteHistory();
            if (completeHistory && completeHistory.dialogues && completeHistory.dialogues.length > 0) {
                console.log(`从完整历史记录中获取 ${completeHistory.dialogues.length} 条对话历史`);
                // 转换为DialogueHistoryItem格式
                const dialogueHistoryItems = completeHistory.dialogues.map(d => ({
                    speaker: d.speaker,
                    content: d.content,
                    style: d.style || 'normal',
                }));
                return dialogueHistoryItems;
            }
            // 如果没有完整历史记录，回退到旧版记录格式
            console.log('未找到完整历史记录，尝试旧版格式');
            // 确保聊天世界书已初始化
            if (!this.worldBookName) {
                await this.initializeChatLorebook();
            }
            // 检查API是否可用
            if (typeof window.getLorebookEntries !== 'function') {
                console.warn('世界书API不可用，无法获取对话历史');
                return null;
            }
            // 获取所有世界书条目
            const allEntries = await window.getLorebookEntries(this.worldBookName);
            if (!allEntries || !Array.isArray(allEntries) || allEntries.length === 0) {
                console.warn('没有找到世界书条目');
                return null;
            }
            // 查找持久化对话历史条目
            const dialogueEntry = this.findEntryByKey(allEntries, this.DIALOGUE_HISTORY_KEY);
            if (!dialogueEntry) {
                console.warn('没有找到对话历史条目');
                return null;
            }
            // 获取条目内容
            let dialogueContent = '';
            // 尝试直接从条目获取内容
            if (dialogueEntry.content) {
                dialogueContent = dialogueEntry.content;
            }
            // 如果没有直接内容，使用triggerSlash获取
            else if (typeof window.triggerSlash === 'function') {
                // 获取实际键值（可能是数组中的第一个元素）
                let actualKey = this.DIALOGUE_HISTORY_KEY;
                if (Array.isArray(dialogueEntry.key) && dialogueEntry.key.length > 0) {
                    actualKey = dialogueEntry.key[0];
                }
                else if (typeof dialogueEntry.key === 'string') {
                    actualKey = dialogueEntry.key;
                }
                dialogueContent = await window.triggerSlash(`/getentryfield file=${this.worldBookName} field=content ${actualKey}`);
            }
            if (!dialogueContent) {
                console.warn('对话历史内容为空');
                return null;
            }
            try {
                // 尝试解析对话历史内容
                // 首先检查是否有<log>标签
                if (dialogueContent.includes('<log>') && dialogueContent.includes('</log>')) {
                    const logMatch = dialogueContent.match(/<log>([\s\S]*?)<\/log>/);
                    if (logMatch && logMatch[1]) {
                        // 解析日志内容
                        const logContent = logMatch[1];
                        // 分割成独立的对话条目
                        const dialogueEntries = logContent.split(';').filter(entry => entry.trim().length > 0);
                        // 转换为DialogueHistoryItem格式
                        const dialogueHistoryItems = [];
                        for (const entry of dialogueEntries) {
                            if (entry.includes(':')) {
                                const [type, content] = entry.split(':', 2);
                                if (type === '选择') {
                                    dialogueHistoryItems.push({
                                        speaker: '玩家',
                                        content: content,
                                        style: 'normal',
                                    });
                                }
                                else if (type === '回到过去') {
                                    dialogueHistoryItems.push({
                                        speaker: '旁白',
                                        content: `【时间穿越：${content}】`,
                                        style: 'special',
                                    });
                                }
                                else {
                                    // 普通对话
                                    dialogueHistoryItems.push({
                                        speaker: type,
                                        content: content,
                                        style: 'normal',
                                    });
                                }
                            }
                        }
                        console.log(`从旧版格式读取了 ${dialogueHistoryItems.length} 条对话历史`);
                        return dialogueHistoryItems;
                    }
                }
                else {
                    // 尝试作为JSON解析
                    try {
                        const dialogues = JSON.parse(dialogueContent);
                        if (Array.isArray(dialogues)) {
                            console.log(`从JSON格式读取了 ${dialogues.length} 条对话历史`);
                            return dialogues;
                        }
                    }
                    catch (jsonError) {
                        console.warn('无法解析对话历史为JSON格式:', jsonError);
                    }
                }
            }
            catch (parseError) {
                console.error('解析对话历史内容失败:', parseError);
            }
            return null;
        }
        catch (error) {
            console.error('获取对话历史失败:', error);
            return null;
        }
    }
    /**
     * 从键名加载游戏状态
     */
    async loadGameState(saveKey) {
        const MAX_RETRY = 3;
        for (let retry = 0; retry < MAX_RETRY; retry++) {
            try {
                // 确保聊天世界书已初始化
                if (!this.worldBookName) {
                    console.log('世界书名称为空，重新初始化');
                    await this.initializeChatLorebook();
                    if (!this.worldBookName) {
                        console.error('初始化世界书失败，无法加载游戏状态');
                        this.uiManager.showNotification('无法初始化世界书，加载失败', 'error');
                        return null;
                    }
                }
                // 检查API函数是否可用
                if (typeof window.getLorebookEntries !== 'function') {
                    console.error('世界书读取API不可用');
                    this.uiManager.showNotification('世界书API不可用，无法加载存档', 'error');
                    return null;
                }
                // 获取所有世界书条目
                console.log(`获取世界书条目，尝试 ${retry + 1}/${MAX_RETRY}`);
                const allEntries = await window.getLorebookEntries(this.worldBookName);
                // 尝试查找对应的存档条目
                const saveEntry = this.findEntryByKey(allEntries, saveKey);
                if (!saveEntry) {
                    console.warn(`找不到存档键 ${saveKey}`);
                    // 如果不是最后一次尝试，等待后重试
                    if (retry < MAX_RETRY - 1) {
                        console.log(`等待500ms后重试...`);
                        await new Promise(resolve => setTimeout(resolve, 500));
                        continue; // 继续下一次重试
                    }
                    else {
                        this.uiManager.showNotification(`找不到指定存档`, 'warning');
                        return null;
                    }
                }
                // 获取条目内容
                let entryContent = '';
                try {
                    // 尝试直接从条目获取内容
                    if (saveEntry.content) {
                        entryContent = saveEntry.content;
                        console.log('直接从条目获取到内容');
                    }
                    // 如果没有直接内容，使用triggerSlash获取
                    else if (typeof window.triggerSlash === 'function') {
                        // 获取实际键值（可能是数组中的第一个元素）
                        let actualKey = saveKey;
                        if (Array.isArray(saveEntry.key) && saveEntry.key.length > 0) {
                            actualKey = saveEntry.key[0];
                        }
                        else if (typeof saveEntry.key === 'string') {
                            actualKey = saveEntry.key;
                        }
                        console.log(`通过triggerSlash获取条目内容，key=${actualKey}`);
                        entryContent = await window.triggerSlash(`/getentryfield file=${this.worldBookName} field=content ${actualKey}`);
                        if (entryContent) {
                            console.log('通过triggerSlash成功获取内容');
                        }
                    }
                    if (!entryContent) {
                        console.warn(`存档键 ${saveKey} 对应的内容为空`);
                        // 如果不是最后一次尝试，等待后重试
                        if (retry < MAX_RETRY - 1) {
                            console.log(`等待500ms后重试...`);
                            await new Promise(resolve => setTimeout(resolve, 500));
                            continue; // 继续下一次重试
                        }
                        else {
                            this.uiManager.showNotification(`存档内容为空`, 'warning');
                            return null;
                        }
                    }
                    // 解析保存的状态
                    try {
                        console.log('解析存档内容...');
                        const savedState = JSON.parse(entryContent);
                        // 确保对话索引设置为0
                        if (savedState && savedState.story) {
                            savedState.story.currentDialogueIndex = 0;
                            console.log('成功解析存档内容，重置对话索引');
                            return savedState;
                        }
                        else {
                            console.warn('解析的存档缺少必要数据');
                            // 如果不是最后一次尝试并且是格式问题，可能是加载不完整，重试
                            if (retry < MAX_RETRY - 1) {
                                console.log(`等待500ms后重试...`);
                                await new Promise(resolve => setTimeout(resolve, 500));
                                continue; // 继续下一次重试
                            }
                            else {
                                this.uiManager.showNotification('存档数据不完整或格式错误', 'error');
                                return null;
                            }
                        }
                    }
                    catch (parseError) {
                        console.error('解析存档内容失败:', parseError);
                        // 如果不是最后一次尝试，等待后重试
                        if (retry < MAX_RETRY - 1) {
                            console.log(`等待500ms后重试...`);
                            await new Promise(resolve => setTimeout(resolve, 500));
                            continue; // 继续下一次重试
                        }
                        else {
                            this.uiManager.showNotification('存档内容格式错误', 'error');
                            return null;
                        }
                    }
                }
                catch (contentError) {
                    console.error(`获取存档 ${saveKey} 内容失败:`, contentError);
                    // 如果不是最后一次尝试，等待后重试
                    if (retry < MAX_RETRY - 1) {
                        console.log(`等待500ms后重试...`);
                        await new Promise(resolve => setTimeout(resolve, 500));
                        continue; // 继续下一次重试
                    }
                    else {
                        this.uiManager.showNotification('获取存档内容失败', 'error');
                        return null;
                    }
                }
            }
            catch (retryError) {
                console.error(`加载游戏存档尝试 ${retry + 1} 失败:`, retryError);
                // 如果不是最后一次尝试，等待后重试
                if (retry < MAX_RETRY - 1) {
                    console.log(`等待500ms后重试...`);
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                else {
                    this.uiManager.showNotification('加载存档失败: ' + (retryError instanceof Error ? retryError.message : '未知错误'), 'error');
                    return null;
                }
            }
        }
        return null; // 如果所有重试都失败，返回null
    }
    /**
     * 根据ID加载游戏状态
     */
    async loadGameStateByID(summaryId, isManual = false) {
        const saveKey = isManual ? `${this.SAVE_TYPE.MANUAL}${summaryId}` : `${this.SAVE_TYPE.AUTO}${summaryId}`;
        return this.loadGameState(saveKey);
    }
    /**
     * 获取完整历史记录
     * 包含所有对话和记忆点
     */
    async getCompleteHistory() {
        return this.loadCompleteHistory();
    }
    /**
     * 加载游戏
     */
    loadGame() {
        // 显示加载游戏弹窗
        this.showLoadGameModal();
    }
}

;// external "_"
const external_namespaceObject = _;
;// ./src/圣约与静默/游戏界面/scripts/components/settingsManager.ts
/**
 * 设置管理器组件
 * 负责管理游戏的设置，如字体大小和界面类型
 */

class SettingsManager {
    // 默认设置
    defaultSettings = {
        fontSize: 'medium',
        uiMode: 'adaptive',
        gameHeight: 'auto', // 默认为自动高度
    };
    // 当前设置
    currentSettings;
    // 设置变更回调
    onSettingsChangedCallback = null;
    // 本地存储键
    SETTINGS_STORAGE_KEY = 'monastery_game_settings';
    constructor() {
        // 从本地存储加载设置或使用默认设置
        this.currentSettings = this.loadSettings();
        // 初始应用设置
        this.applySettings();
        console.log('设置管理器初始化完成');
    }
    /**
     * 从本地存储加载设置
     */
    loadSettings() {
        try {
            const savedSettings = localStorage.getItem(this.SETTINGS_STORAGE_KEY);
            if (savedSettings) {
                const parsedSettings = JSON.parse(savedSettings);
                // 处理从旧版本升级的情况
                if (parsedSettings.hasOwnProperty('useMobileUI')) {
                    // 从旧版本迁移
                    parsedSettings.uiMode = parsedSettings.useMobileUI ? 'mobile' : 'desktop';
                    delete parsedSettings.useMobileUI;
                }
                return {
                    ...this.defaultSettings,
                    ...parsedSettings,
                };
            }
        }
        catch (error) {
            console.error('加载设置失败:', error);
        }
        return { ...this.defaultSettings };
    }
    /**
     * 保存设置到本地存储
     */
    saveSettings() {
        try {
            localStorage.setItem(this.SETTINGS_STORAGE_KEY, JSON.stringify(this.currentSettings));
        }
        catch (error) {
            console.error('保存设置失败:', error);
        }
    }
    /**
     * 应用当前设置到UI
     */
    applySettings() {
        // 应用字体大小
        document.documentElement.classList.remove('font-small', 'font-medium', 'font-large');
        document.documentElement.classList.add(`font-${this.currentSettings.fontSize}`);
        // 应用界面类型
        document.documentElement.classList.remove('mobile-ui', 'desktop-ui');
        // 根据 UI 模式应用相应的类
        switch (this.currentSettings.uiMode) {
            case 'mobile':
                document.documentElement.classList.add('mobile-ui');
                break;
            case 'desktop':
                document.documentElement.classList.add('desktop-ui');
                break;
            case 'adaptive':
            default:
                // 自适应模式不添加特殊类，依赖于CSS媒体查询
                break;
        }
        // 应用游戏高度
        const gameContainer = document.querySelector('.game-container');
        if (gameContainer) {
            if (this.currentSettings.gameHeight === 'auto') {
                // 自动高度模式，移除设置的高度
                gameContainer.style.height = '';
            }
            else {
                // 固定高度模式
                gameContainer.style.height = `${this.currentSettings.gameHeight}px`;
            }
        }
        console.log('已应用设置:', this.currentSettings);
    }
    /**
     * 更新设置
     */
    updateSettings(settings) {
        // 更新当前设置
        this.currentSettings = {
            ...this.currentSettings,
            ...settings,
        };
        // 保存设置
        this.saveSettings();
        // 应用设置
        this.applySettings();
        // 调用变更回调
        if (this.onSettingsChangedCallback) {
            this.onSettingsChangedCallback(this.currentSettings);
        }
    }
    /**
     * 设置字体大小
     */
    setFontSize(fontSize) {
        this.updateSettings({ fontSize });
    }
    /**
     * 设置界面模式
     */
    setUIMode(uiMode) {
        this.updateSettings({ uiMode });
    }
    /**
     * 设置游戏高度
     */
    setGameHeight(gameHeight) {
        this.updateSettings({ gameHeight });
    }
    /**
     * 获取当前设置
     */
    getSettings() {
        return { ...this.currentSettings };
    }
    /**
     * 重置为默认设置
     */
    resetSettings() {
        this.currentSettings = { ...this.defaultSettings };
        this.saveSettings();
        this.applySettings();
        // 调用变更回调
        if (this.onSettingsChangedCallback) {
            this.onSettingsChangedCallback(this.currentSettings);
        }
    }
    /**
     * 设置设置变更回调
     */
    setOnSettingsChanged(callback) {
        this.onSettingsChangedCallback = callback;
    }
    /**
     * 显示设置对话框
     */
    showSettingsDialog() {
        // 创建设置对话框HTML
        const dialogHtml = `
      <div id="settings-dialog" class="modal fade">
        <div class="modal-dialog modal-dialog-centered monastery-dialog">
          <div class="modal-content">
            <div class="modal-header">
              <h5 class="modal-title"><i class="fas fa-cog"></i> 游戏设置</h5>
              <button type="button" class="close" data-dismiss="modal">&times;</button>
            </div>
            <div class="modal-body">
              <div class="form-group monastery-form-group">
                <label for="font-size-select" class="monastery-label">
                  <i class="fas fa-font"></i> 字体大小
                </label>
                <select id="font-size-select" class="form-control monastery-select">
                  <option value="small" ${this.currentSettings.fontSize === 'small' ? 'selected' : ''}>小</option>
                  <option value="medium" ${this.currentSettings.fontSize === 'medium' ? 'selected' : ''}>中</option>
                  <option value="large" ${this.currentSettings.fontSize === 'large' ? 'selected' : ''}>大</option>
                </select>
              </div>
              <div class="form-group monastery-form-group">
                <label for="ui-mode-select" class="monastery-label">
                  <i class="fas fa-mobile-alt"></i> 界面模式
                </label>
                <select id="ui-mode-select" class="form-control monastery-select">
                  <option value="adaptive" ${this.currentSettings.uiMode === 'adaptive' ? 'selected' : ''}>自适应</option>
                  <option value="mobile" ${this.currentSettings.uiMode === 'mobile' ? 'selected' : ''}>手机</option>
                  <option value="desktop" ${this.currentSettings.uiMode === 'desktop' ? 'selected' : ''}>电脑</option>
                </select>
                <small class="form-text text-muted monastery-help-text">自适应: 根据屏幕大小自动调整; 手机/电脑: 强制使用对应界面</small>
              </div>
              <div class="form-group monastery-form-group">
                <label for="game-height-mode" class="monastery-label">
                  <i class="fas fa-arrows-alt-v"></i> 游戏界面高度
                </label>
                <div class="custom-control custom-switch mb-2">
                  <input type="checkbox" class="custom-control-input" id="height-custom-switch" ${this.currentSettings.gameHeight !== 'auto' ? 'checked' : ''}>
                  <label class="custom-control-label" for="height-custom-switch">自定义高度</label>
                </div>
                <div id="custom-height-container" class="mt-2 ${this.currentSettings.gameHeight === 'auto' ? 'd-none' : ''}">
                  <div class="input-group">
                    <input 
                      type="number" 
                      id="game-height-input" 
                      class="form-control monastery-input" 
                      value="${this.currentSettings.gameHeight === 'auto' ? 1000 : this.currentSettings.gameHeight}" 
                      min="500" 
                      max="2000" 
                      step="50" 
                    />
                    <div class="input-group-append">
                      <span class="input-group-text">px</span>
                    </div>
                  </div>
                  <small class="form-text text-muted monastery-help-text">推荐值: 1000px（可根据屏幕大小调整）</small>
                </div>
              </div>
            </div>
            <div class="modal-footer">
              <button type="button" class="btn btn-secondary monastery-btn monastery-btn-secondary" id="reset-settings-btn">
                <i class="fas fa-undo"></i> 恢复默认
              </button>
              <button type="button" class="btn btn-primary monastery-btn monastery-btn-primary" id="save-settings-btn">
                <i class="fas fa-check"></i> 保存设置
              </button>
              <button type="button" class="btn btn-secondary monastery-btn monastery-btn-cancel" data-dismiss="modal">
                <i class="fas fa-times"></i> 取消
              </button>
            </div>
          </div>
        </div>
      </div>
    `;
        // 添加到页面
        $('body').append(dialogHtml);
        // 绑定高度设置开关事件
        $('#height-custom-switch').on('change', function () {
            if ($(this).is(':checked')) {
                $('#custom-height-container').removeClass('d-none');
            }
            else {
                $('#custom-height-container').addClass('d-none');
            }
        });
        // 绑定保存按钮事件
        $('#save-settings-btn').on('click', () => {
            const fontSize = $('#font-size-select').val();
            const uiMode = $('#ui-mode-select').val();
            const useCustomHeight = $('#height-custom-switch').is(':checked');
            // 根据是否启用自定义高度决定使用auto还是自定义值
            let gameHeight = 'auto';
            if (useCustomHeight) {
                const gameHeightInput = $('#game-height-input').val();
                // 使用lodash验证并转换高度值，确保在有效范围内
                gameHeight = external_namespaceObject.clamp(external_namespaceObject.parseInt(gameHeightInput) || 1000, 500, // 最小值
                2000);
            }
            this.updateSettings({
                fontSize,
                uiMode,
                gameHeight,
            });
            $('#settings-dialog').modal('hide');
        });
        $('#reset-settings-btn').on('click', () => {
            if (confirm('确定要恢复默认设置吗？')) {
                this.resetSettings();
                // 更新对话框中的选项
                $('#font-size-select').val(this.defaultSettings.fontSize);
                $('#ui-mode-select').val(this.defaultSettings.uiMode);
                // 更新自定义高度开关
                $('#height-custom-switch').prop('checked', this.defaultSettings.gameHeight !== 'auto');
                if (this.defaultSettings.gameHeight === 'auto') {
                    $('#custom-height-container').addClass('d-none');
                }
                else {
                    $('#custom-height-container').removeClass('d-none');
                    $('#game-height-input').val(this.defaultSettings.gameHeight);
                }
            }
        });
        // 显示对话框
        $('#settings-dialog').modal('show').data('backdrop', 'static').data('keyboard', false);
        // 当对话框关闭时移除
        $('#settings-dialog').on('hidden.bs.modal', function () {
            $(this).remove();
        });
    }
}

;// ./src/圣约与静默/游戏界面/scripts/components/uiManager.ts
/**
 * UI管理器组件
 * 负责管理游戏中的通用UI显示和交互
 */
class UIManager {
    // 当前确认回调
    currentConfirmCallback = null;
    constructor() {
        // 初始化Toastr配置
        toastr.options = {
            closeButton: true,
            progressBar: true,
            positionClass: 'toast-top-right',
            preventDuplicates: false,
            timeOut: 3000,
        };
        // 绑定确认对话框按钮事件 - 这里不需要预绑定，我们会在显示时动态绑定
        console.log('UI管理器初始化完成');
    }
    /**
     * 显示加载提示
     */
    showLoading(message = '加载中...') {
        $('.loading-text').text(message);
        $('.loading-indicator').removeClass('hidden');
    }
    /**
     * 隐藏加载提示
     */
    hideLoading() {
        $('.loading-indicator').addClass('hidden');
    }
    /**
     * 显示确认对话框
     */
    showConfirmDialog(message, onConfirm) {
        // 保存确认回调
        this.currentConfirmCallback = onConfirm;
        console.log('显示确认对话框:', message);
        // 设置确认消息
        $('#confirm-message').text(message);
        // 显示对话框容器
        $('#confirm-container').removeClass('hidden');
        // 绑定按钮事件
        $('#confirm-yes')
            .off('click')
            .on('click', () => this.handleConfirmYes());
        $('#confirm-no')
            .off('click')
            .on('click', () => this.hideConfirmDialog());
        // 点击对话框外部关闭
        $(document).on('click.confirm-outside', e => {
            if ($(e.target).closest('.confirm-dialog').length === 0 && !$('#confirm-container').hasClass('hidden')) {
                this.hideConfirmDialog();
            }
        });
    }
    /**
     * 隐藏确认对话框
     */
    hideConfirmDialog() {
        // 隐藏对话框
        $('#confirm-container').addClass('hidden');
        // 移除外部点击事件处理器
        $(document).off('click.confirm-outside');
        // 重置回调
        this.currentConfirmCallback = null;
    }
    /**
     * 处理确认按钮点击
     */
    handleConfirmYes() {
        // 调用确认回调
        if (this.currentConfirmCallback) {
            this.currentConfirmCallback();
        }
        // 隐藏对话框
        this.hideConfirmDialog();
    }
    /**
     * 显示通知
     */
    showNotification(message, type = 'info', duration = 3000) {
        // 使用toastr库显示通知
        toastr.options.timeOut = duration;
        switch (type) {
            case 'success':
                toastr.success(message);
                break;
            case 'warning':
                toastr.warning(message);
                break;
            case 'error':
                toastr.error(message);
                break;
            default:
                toastr.info(message);
        }
    }
    /**
     * 切换全屏显示
     */
    toggleFullscreen() {
        if (!document.fullscreenElement) {
            // 进入全屏
            if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen();
            }
        }
        else {
            // 退出全屏
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
        }
    }
    /**
     * 显示文本提示
     */
    showTooltip(element, message) {
        // 使用jQuery UI的tooltip
        $(element)
            .attr('title', message)
            .tooltip({
            content: message,
            position: { my: 'center bottom', at: 'center top-5' },
            show: { effect: 'fadeIn', duration: 200 },
            hide: { effect: 'fadeOut', duration: 200 },
        })
            .tooltip('open');
        // 自动关闭
        setTimeout(() => {
            $(element).tooltip('close');
        }, 2000);
    }
    /**
     * 显示输入对话框
     * @param title 对话框标题
     * @param defaultValue 默认值
     * @param callback 输入完成回调函数
     */
    showInputDialog(title, defaultValue, callback) {
        // 检查是否已存在对话框
        if ($('#input-dialog').length > 0) {
            $('#input-dialog').remove();
        }
        // 创建对话框
        const dialogHtml = `
      <div id="input-dialog" class="modal fade">
        <div class="modal-dialog modal-dialog-centered monastery-dialog">
          <div class="modal-content">
            <div class="modal-header">
              <h5 class="modal-title"><i class="fas fa-feather-alt"></i> ${title}</h5>
              <button type="button" class="close" data-dismiss="modal">&times;</button>
            </div>
            <div class="modal-body">
              <div class="input-dialog-container">
                <label for="input-dialog-value" class="monastery-label">为您的记录命名：</label>
                <input type="text" id="input-dialog-value" class="form-control monastery-input" value="${defaultValue}">
              </div>
            </div>
            <div class="modal-footer">
              <button type="button" class="btn btn-primary monastery-btn monastery-btn-primary" id="input-dialog-confirm">
                <i class="fas fa-save"></i> 确定
              </button>
              <button type="button" class="btn btn-secondary monastery-btn monastery-btn-secondary" data-dismiss="modal">
                <i class="fas fa-times"></i> 取消
              </button>
            </div>
          </div>
        </div>
      </div>
    `;
        // 添加到页面
        $('body').append(dialogHtml);
        // 绑定确认按钮事件
        $('#input-dialog-confirm').on('click', () => {
            const value = $('#input-dialog-value').val();
            $('#input-dialog').modal('hide');
            callback(value);
        });
        // 绑定回车键事件
        $('#input-dialog-value').on('keypress', e => {
            if (e.which === 13) {
                // Enter键
                $('#input-dialog-confirm').click();
            }
        });
        // 显示对话框
        $('#input-dialog').modal('show');
        // 自动聚焦输入框
        $('#input-dialog-value').focus();
    }
}

;// ./src/圣约与静默/游戏界面/services/character-resource.service.ts
/**
 * 角色资源服务
 * 负责管理角色数据和立绘资源
 */
class CharacterResourceService {
    // 角色资源映射表
    characters = new Map();
    constructor() {
        console.log('角色资源服务已初始化');
        // 初始化角色数据
        this.initializeCharacters();
    }
    /**
     * 初始化角色数据
     */
    initializeCharacters() {
        // 修女Cecilia
        this.characters.set('cecilia', {
            id: 'cecilia',
            name: 'Cecilia修女',
            fullName: 'Sister Cecilia',
            position: 'right',
            emotions: {
                default: 'https://gitgud.io/lolodesu/lolobabytutorial/-/raw/master/lologame/%E8%A7%92%E8%89%B2/%E6%B0%B4%E6%89%8B%E6%9C%8D/%E5%BE%AE%E7%AC%91.png?ref_type=heads',
                smile: 'https://gitgud.io/lolodesu/lolobabytutorial/-/raw/master/lologame/%E8%A7%92%E8%89%B2/%E6%B0%B4%E6%89%8B%E6%9C%8D/%E5%BE%AE%E7%AC%91.png?ref_type=heads',
                sad: 'https://gitgud.io/lolodesu/lolobabytutorial/-/raw/master/lologame/%E8%A7%92%E8%89%B2/%E6%B0%B4%E6%89%8B%E6%9C%8D/%E5%93%AD%E6%B3%A3.png?ref_type=heads',
                shocked: 'https://gitgud.io/lolodesu/lolobabytutorial/-/raw/master/lologame/%E8%A7%92%E8%89%B2/%E6%B0%B4%E6%89%8B%E6%9C%8D/%E6%83%8A%E8%AE%B6.png?ref_type=heads',
                blush: 'https://gitgud.io/lolodesu/lolobabytutorial/-/raw/master/lologame/%E8%A7%92%E8%89%B2/%E6%B0%B4%E6%89%8B%E6%9C%8D/%E5%AE%B3%E7%BE%9E.png?ref_type=heads',
            },
            bio: '一位年轻的见习修女，专注于抄写工作，对草药学有浓厚兴趣。',
        });
        // 玩家角色
        this.characters.set('player', {
            id: 'player',
            name: '{{user}}',
            fullName: 'The Visitor',
            position: 'left',
            emotions: {
                default: 'https://gitgud.io/lolodesu/lolobabytutorial/-/raw/master/lologame/%E8%A7%92%E8%89%B2/%E6%B0%B4%E6%89%8B%E6%9C%8D/%E9%BB%98%E8%AE%A4.png?ref_type=heads',
                smile: 'https://gitgud.io/lolodesu/lolobabytutorial/-/raw/master/lologame/%E8%A7%92%E8%89%B2/%E6%B0%B4%E6%89%8B%E6%9C%8D/%E5%BE%AE%E7%AC%91.png?ref_type=heads',
                sad: 'https://gitgud.io/lolodesu/lolobabytutorial/-/raw/master/lologame/%E8%A7%92%E8%89%B2/%E6%B0%B4%E6%89%8B%E6%9C%8D/%E5%93%AD%E6%B3%A3.png?ref_type=heads',
            },
            bio: '一位到访修道院的神秘人物，对修道院的历史和草药学表示了浓厚兴趣。',
        });
        // 可以根据需要添加更多角色...
    }
    /**
     * 获取角色资源
     * @param characterId 角色ID
     * @returns 角色资源对象，不存在时返回undefined
     */
    getCharacter(characterId) {
        return this.characters.get(characterId);
    }
    /**
     * 获取所有角色ID列表
     * @returns 角色ID数组
     */
    getAllCharacterIds() {
        return Array.from(this.characters.keys());
    }
    /**
     * 获取角色表情图片URL
     * @param characterId 角色ID
     * @param emotion 表情类型，默认为'default'
     * @returns 表情图片URL，角色或表情不存在时返回undefined
     */
    getCharacterEmotionUrl(characterId, emotion = 'default') {
        const character = this.characters.get(characterId);
        if (!character)
            return undefined;
        // 如果请求的表情不存在，返回默认表情
        return character.emotions[emotion] || character.emotions.default;
    }
    /**
     * 获取角色名称
     * @param characterId 角色ID
     * @returns 角色名称，不存在时返回"未知角色"
     */
    getCharacterName(characterId) {
        const character = this.characters.get(characterId);
        return character ? character.name : '未知角色';
    }
    /**
     * 添加一个新角色
     * @param character 角色资源对象
     * @returns 是否添加成功
     */
    addCharacter(character) {
        if (this.characters.has(character.id)) {
            console.warn(`角色ID: ${character.id} 已存在，无法添加`);
            return false;
        }
        this.characters.set(character.id, character);
        return true;
    }
    /**
     * 更新角色信息
     * @param characterId 角色ID
     * @param updates 更新的字段
     * @returns 是否更新成功
     */
    updateCharacter(characterId, updates) {
        const character = this.characters.get(characterId);
        if (!character) {
            console.warn(`角色ID: ${characterId} 不存在，无法更新`);
            return false;
        }
        // 使用lodash合并对象
        const updatedCharacter = _.merge({}, character, updates);
        this.characters.set(characterId, updatedCharacter);
        return true;
    }
}

;// ./src/圣约与静默/游戏界面/services/game-data.service.ts
class GameDataService {
    // 游戏默认数据
    defaultGameData = {
        story: {
            date: '1243年 夏',
            location: '修道院',
            scene: '图书室',
            dialogue: [
                {
                    speaker: 'Cecilia修女',
                    content: '欢迎来到修道院，这里是我们的图书室。',
                    style: 'normal',
                    portrait: {
                        character: 'cecilia',
                        emotion: 'smile',
                    },
                    background: {
                        location: '修道院',
                        scene: '图书室',
                    },
                },
                {
                    speaker: '玩家',
                    content: '谢谢你的接待，这里的藏书真是令人惊叹。',
                    style: 'normal',
                    portrait: {
                        character: 'player',
                        emotion: 'default',
                    },
                },
                {
                    speaker: '旁白',
                    content: 'Cecilia修女微笑着拿起一本古老的书籍。',
                    style: 'special',
                },
                {
                    speaker: 'Cecilia修女',
                    content: '这本是我们修道院最珍贵的草药学手稿，记载了很多珍贵的药方。',
                    style: 'normal',
                    portrait: {
                        character: 'cecilia',
                        emotion: 'thoughtful',
                    },
                },
                {
                    speaker: '图书管理员',
                    content: '午餐时间到了，请各位移步餐厅。',
                    style: 'normal',
                    // 这是一个未预定义的角色，只显示名字，不显示立绘
                },
                {
                    speaker: 'Cecilia修女',
                    content: '不如我们去花园里继续聊吧？',
                    style: 'normal',
                    portrait: {
                        character: 'cecilia',
                        emotion: 'smile',
                    },
                    background: {
                        location: '修道院',
                        scene: '花园',
                    },
                },
            ],
            options: ['好的，我很乐意。', '我想先了解更多关于那本草药手稿的内容。', '我需要先休息一下，稍后再聊。'],
            currentDialogueIndex: 0,
            currentChapter: '第一章：修道院的秘密',
            currentFunds: 50,
        },
        storySummary: [
            {
                id: 1,
                content: '玩家来到修道院，与Cecilia修女在图书室相遇，得知了一本珍贵的草药学手稿。',
                timestamp: new Date().toISOString(),
            },
        ],
    };
    constructor() {
        console.log('游戏数据服务已初始化');
    }
    /**
     * 加载游戏数据
     * @returns 游戏数据
     */
    async loadGameData() {
        // 在实际应用中，这里可能会从文件或API加载数据
        // 现在我们使用默认数据
        return this.defaultGameData;
    }
    /**
     * 保存游戏数据
     * @param gameData 游戏数据
     */
    async saveGameData(gameData) {
        // 在实际应用中，这里可能会保存数据到文件或API
        console.log('游戏数据已保存');
    }
}

;// ./src/圣约与静默/游戏界面/services/game-state-generation.service.ts
class GameStateGenerationService {
    // 添加属性保存原始响应
    lastRawResponse = '';
    constructor() {
        console.log('游戏状态生成服务已初始化');
    }
    /**
     * 获取最后一次LLM生成的原始响应
     * @returns 最后一次LLM的原始响应
     */
    getLastRawResponse() {
        return this.lastRawResponse;
    }
    /**
     * 生成下一个游戏状态
     * @param choice 玩家选择
     */
    async generateNextGameState(choice) {
        // 检查API是否可用
        if (typeof window.generate !== 'function') {
            console.warn('generate API不可用');
            return null;
        }
        try {
            // 使用简单标签替代复杂提示词
            const systemPrompt = `<选择>${choice}</选择>`;
            // 使用简单的inject参数指示AI返回游戏状态JSON
            const generateConfig = {
                user_input: choice,
                should_stream: false,
                injects: [
                    {
                        role: 'system',
                        content: systemPrompt,
                        position: 'before_prompt',
                        depth: 0,
                        should_scan: false,
                    },
                ],
            };
            // 调用生成API
            const result = await window.generate(generateConfig);
            // 保存并打印完整的原始响应
            this.lastRawResponse = result;
            console.log('%c[LLM完整响应]', 'color: #ff5722; font-weight: bold;');
            console.log(result);
            // 解析结果
            const regex = /<gametext>([\s\S]*?)<\/gametext>/;
            const match = result.match(regex);
            if (match && match[1]) {
                try {
                    const jsonData = match[1].trim();
                    console.log('%c[找到游戏状态JSON]', 'color: #4caf50; font-weight: bold;');
                    console.log(jsonData);
                    const gameData = JSON.parse(jsonData);
                    return gameData;
                }
                catch (parseError) {
                    console.error('解析游戏数据JSON失败:', parseError);
                    const jsonData = match[1].trim();
                    console.log('%c[解析JSON失败]', 'color: #f44336; font-weight: bold;', jsonData);
                    return null;
                }
            }
            else {
                console.error('未找到<gametext>标签或内容为空');
                return null;
            }
        }
        catch (error) {
            console.error('生成游戏状态失败:', error);
            return null;
        }
    }
    /**
     * 生成记忆点游戏状态
     * @param memory 记忆点对象
     */
    async generateMemoryState(memory) {
        // 检查API是否可用
        if (typeof window.generate !== 'function') {
            console.warn('generate API不可用');
            return null;
        }
        try {
            // 使用简单标签替代复杂提示词
            const systemPrompt = `<时间跳跃>${memory.content}</时间跳跃>`;
            // 使用简单的inject参数指示AI根据记忆点生成游戏状态
            const result = await window.generate({
                user_input: `穿越到记忆点"${memory.content}"`,
                should_stream: false,
                injects: [
                    {
                        role: 'system',
                        content: systemPrompt,
                        position: 'before_prompt',
                        depth: 0,
                        should_scan: false,
                    },
                ],
            });
            // 保存并打印完整的原始响应
            this.lastRawResponse = result;
            console.log('%c[LLM记忆点响应]', 'color: #ff9800; font-weight: bold;');
            console.log(result);
            // 解析结果
            const regex = /<gametext>([\s\S]*?)<\/gametext>/;
            const match = result.match(regex);
            if (match && match[1]) {
                try {
                    const jsonData = match[1].trim();
                    console.log('%c[找到记忆点游戏状态JSON]', 'color: #4caf50; font-weight: bold;');
                    console.log(jsonData);
                    const gameData = JSON.parse(jsonData);
                    return gameData;
                }
                catch (parseError) {
                    console.error('解析记忆点游戏数据JSON失败:', parseError);
                    const jsonData = match[1].trim();
                    console.log('%c[解析记忆点JSON失败]', 'color: #f44336; font-weight: bold;', jsonData);
                    return null;
                }
            }
        }
        catch (error) {
            console.error('生成记忆点游戏状态失败:', error);
        }
        return null;
    }
    /**
     * 处理自定义行动
     * @param action 玩家输入的自定义行动
     */
    async handleCustomAction(action) {
        // 检查API是否可用
        if (typeof window.generate !== 'function') {
            console.warn('generate API不可用');
            return null;
        }
        try {
            // 使用简单标签替代复杂提示词
            const systemPrompt = `<自定义行动>${action}</自定义行动>`;
            // 使用inject参数指示AI处理自定义行动
            const result = await window.generate({
                user_input: action,
                should_stream: false,
                injects: [
                    {
                        role: 'system',
                        content: systemPrompt,
                        position: 'before_prompt',
                        depth: 0,
                        should_scan: false,
                    },
                ],
            });
            // 保存并打印完整的原始响应
            this.lastRawResponse = result;
            console.log('%c[LLM自定义行动响应]', 'color: #2196f3; font-weight: bold;');
            console.log(result);
            // 解析结果
            const regex = /<gametext>([\s\S]*?)<\/gametext>/;
            const match = result.match(regex);
            if (match && match[1]) {
                try {
                    const jsonData = match[1].trim();
                    console.log('%c[找到自定义行动游戏状态JSON]', 'color: #4caf50; font-weight: bold;');
                    console.log(jsonData);
                    const gameData = JSON.parse(jsonData);
                    return gameData;
                }
                catch (parseError) {
                    console.error('解析自定义行动游戏数据JSON失败:', parseError);
                    const jsonData = match[1].trim();
                    console.log('%c[解析自定义行动JSON失败]', 'color: #f44336; font-weight: bold;', jsonData);
                    return null;
                }
            }
        }
        catch (error) {
            console.error('处理自定义行动失败:', error);
        }
        return null;
    }
    /**
     * 添加一个辅助方法，可以通过控制台调用查看最后一次响应
     * 用法: window.debugLLMResponse()
     */
    initDebugHelpers() {
        window.debugLLMResponse = () => {
            console.log('%c[Debug] 最后一次LLM响应', 'background: #222; color: #bada55');
            console.log(this.lastRawResponse);
            // 尝试提取gametext部分
            const regex = /<gametext>([\s\S]*?)<\/gametext>/;
            const match = this.lastRawResponse.match(regex);
            if (match && match[1]) {
                console.log('%c[Debug] 提取的gametext内容', 'background: #222; color: #ffa500');
                console.log(match[1]);
                try {
                    const parsed = JSON.parse(match[1]);
                    console.log('%c[Debug] 解析后的JSON对象', 'background: #222; color: #4caf50');
                    console.log(parsed);
                }
                catch (e) {
                    console.log('%c[Debug] JSON解析失败', 'background: #222; color: #f44336');
                    console.log(e);
                }
            }
            else {
                console.log('%c[Debug] 未找到gametext标签', 'background: #222; color: #f44336');
            }
            return '调试信息已输出到控制台';
        };
    }
}

;// ./src/圣约与静默/游戏界面/game.controller.ts
/**
 * 游戏控制器
 * 负责协调各个服务和组件，管理游戏的整体流程
 */













class GameController {
    // 游戏状态数据
    gameData = null;
    // 服务
    gameDataService;
    gameStateGenerationService;
    characterResourceService;
    // 组件管理器
    dialogueManager;
    characterManager;
    backgroundManager;
    choiceManager;
    memoryManager;
    memoryUIManager;
    uiManager;
    saveManager;
    journalManager;
    settingsManager;
    constructor() {
        // 初始化服务
        this.gameDataService = new GameDataService();
        this.gameStateGenerationService = new GameStateGenerationService();
        this.characterResourceService = new CharacterResourceService();
        // 初始化各个管理器
        this.uiManager = new UIManager();
        this.saveManager = new SaveManager(this.uiManager);
        this.backgroundManager = new BackgroundManager();
        this.characterManager = new CharacterManager(this.characterResourceService);
        this.dialogueManager = new DialogueManager(this.characterResourceService, this.characterManager, this.backgroundManager);
        this.choiceManager = new ChoiceManager();
        this.memoryManager = new MemoryManager();
        // 初始化新分离的管理器
        this.journalManager = new JournalManager();
        this.memoryUIManager = new MemoryUIManager(this.memoryManager, this.saveManager, this.uiManager, this.gameStateGenerationService);
        // 初始化设置管理器
        this.settingsManager = new SettingsManager();
        // 初始化调试辅助功能
        this.gameStateGenerationService.initDebugHelpers();
        console.log('调试辅助功能已初始化，请在控制台使用 window.debugLLMResponse() 查看最近一次LLM响应');
        // 初始化游戏
        this.init();
    }
    /**
     * 初始化游戏
     */
    async init() {
        console.log('初始化游戏界面...');
        // 注册事件监听器
        this.registerEventListeners();
        // 尝试获取游戏数据
        await this.loadGameData();
        // 更新UI
        this.updateUI();
        // 添加调试功能
        this.initDebugFunctions();
        console.log('游戏界面初始化完成!');
    }
    /**
     * 初始化调试功能
     */
    initDebugFunctions() {
        // 添加调试确认对话框的全局函数
        window.testConfirmDialog = () => {
            console.log('测试确认对话框');
            // 创建一个计数变量
            if (!window.confirmTestCount) {
                window.confirmTestCount = 0;
            }
            // 增加计数
            window.confirmTestCount++;
            // 显示带计数的确认对话框
            this.uiManager.showConfirmDialog(`这是一个测试确认对话框 #${window.confirmTestCount}，用于检查位置和点击功能。请点击"确认"按钮测试是否可点击。`, () => {
                console.log('确认对话框被确认');
                this.uiManager.showNotification(`确认对话框 #${window.confirmTestCount} 测试成功!`, 'success');
            });
        };
        console.log('调试功能已初始化，可在控制台使用 window.testConfirmDialog() 测试确认对话框');
    }
    /**
     * 注册事件监听器
     */
    registerEventListeners() {
        // 标签切换按钮
        $('.tab-button').on('click', e => {
            const tabId = $(e.currentTarget).data('tab');
            if (tabId) {
                this.switchTab(tabId);
            }
        });
        // 日记标签内的导航按钮
        $('.journal-nav-item').on('click', e => {
            const sectionId = $(e.currentTarget).data('section');
            if (sectionId) {
                this.journalManager.switchJournalSection(sectionId);
            }
        });
        // 保存游戏按钮 - 使用右上角的按钮
        $('#save-game').on('click', () => {
            this.saveGame();
        });
        // 加载游戏按钮 - 使用右上角的按钮
        $('#load-game').on('click', () => {
            this.loadGame();
        });
        // 设置按钮
        $('#settings-button').on('click', () => {
            this.showSettings();
        });
        // 保存记忆按钮
        $('#save-memory').on('click', () => {
            const newMemory = this.memoryUIManager.saveMemory();
            if (newMemory && this.gameData) {
                // 更新游戏数据
                this.gameData.storySummary.push(newMemory);
            }
        });
        // 穿越记忆按钮
        $('#travel-memory').on('click', () => {
            this.memoryUIManager.travelToMemory(() => {
                // 成功穿越后的回调
                this.gameData = this.memoryUIManager.getGameData();
                this.updateUI();
                this.switchTab('story-tab');
            });
        });
        // 历史记录按钮
        $('#dialogue-history').on('click', () => {
            this.showDialogueHistory();
        });
        // 选择按钮
        $(document).on('click', '.choice-button', e => {
            const choice = $(e.currentTarget).data('choice');
            this.makeChoice(choice);
        });
        // 获取游戏数据事件
        window.addEventListener('request_game_data', event => {
            if (event.detail && typeof event.detail.callback === 'function') {
                // 确保返回的游戏数据包含所有必要属性
                const currentGameData = {
                    story: this.gameData?.story || {
                        date: '未知日期',
                        location: '未知位置',
                        scene: '未知场景',
                        dialogue: [],
                        options: [],
                        currentDialogueIndex: 0,
                        currentChapter: '第1章',
                        currentFunds: 0,
                    },
                    storySummary: this.gameData?.storySummary || [],
                };
                // 返回当前游戏数据的副本
                event.detail.callback(currentGameData);
            }
        });
        // 游戏加载完成事件
        window.addEventListener('gameloaded', event => {
            if (event.detail && event.detail.gameData) {
                // 更新游戏数据
                this.gameData = event.detail.gameData;
                // 重新渲染游戏状态
                this.updateUI();
                this.switchTab('story-tab');
                // 显示成功加载的通知
                this.uiManager.showNotification('游戏已加载', 'success');
            }
        });
        // 对话框点击事件 - 点击对话框进入下一步或重新显示选项
        $('#dialogue-container').on('click', e => {
            // 防止点击对话控制按钮时触发下一步
            if (!$(e.target).closest('.dialogue-controls').length) {
                // 检查是否可以重新显示选项
                if (this.choiceManager.canReshowChoices()) {
                    this.choiceManager.reshowChoices();
                }
                else {
                    this.nextDialogue();
                }
            }
        });
        // 选项选择回调
        this.choiceManager.setOnChoiceSelected(choice => {
            this.makeChoice(choice);
        });
    }
    /**
     * 加载游戏数据
     */
    async loadGameData() {
        try {
            this.gameData = await this.gameDataService.loadGameData();
            // 更新各管理器的游戏数据
            this.journalManager.setGameData(this.gameData);
            this.memoryUIManager.setGameData(this.gameData);
        }
        catch (error) {
            console.error('加载游戏数据失败:', error);
        }
    }
    /**
     * 切换标签页
     */
    switchTab(tabId) {
        // 移除所有标签按钮的激活状态
        $('.tab-button').removeClass('active');
        // 移除所有标签内容的激活状态
        $('.tab-pane').removeClass('active');
        // 激活选中的标签按钮和内容
        $(`[data-tab="${tabId}"]`).addClass('active');
        $(`#${tabId}`).addClass('active');
        // 如果是记忆标签，刷新记忆时间轴
        if (tabId === 'memory-tab') {
            this.memoryUIManager.refreshMemoryTimeline();
        }
        // 如果是日记标签，刷新角色信息
        if (tabId === 'journal-tab') {
            this.journalManager.refreshJournalContent();
        }
    }
    /**
     * 显示对话历史记录
     */
    async showDialogueHistory() {
        // 尝试从世界书获取对话历史
        const dialogueHistory = await this.saveManager.getDialogueHistory();
        if (dialogueHistory) {
            this.dialogueManager.showDialogueHistory(dialogueHistory);
        }
    }
    /**
     * 显示设置
     */
    showSettings() {
        console.log('显示设置');
        this.settingsManager.showSettingsDialog();
    }
    /**
     * 保存游戏
     */
    saveGame() {
        console.log('保存游戏...');
        // 显示确认对话框
        this.uiManager.showInputDialog('请输入典籍标题', '当前进度记录', async (saveName) => {
            try {
                this.uiManager.showLoading('正在记录典籍...');
                // 调用存档管理器保存游戏
                const success = await this.saveManager.saveGameState(this.gameData, true, saveName);
                if (success) {
                    this.uiManager.showNotification('典籍记录成功', 'success');
                }
            }
            catch (error) {
                console.error('保存游戏失败:', error);
                this.uiManager.showNotification('典籍记录失败', 'error');
            }
            finally {
                this.uiManager.hideLoading();
            }
        });
    }
    /**
     * 加载游戏
     */
    loadGame() {
        console.log('加载游戏...');
        // 显示存档列表
        this.saveManager.loadGame();
    }
    /**
     * 更新UI
     */
    updateUI() {
        if (!this.gameData) {
            console.error('无法更新UI：游戏数据不存在');
            return;
        }
        try {
            // 更新顶部日期
            $('#game-date').text(this.gameData.story.date);
            // 设置对话
            this.dialogueManager.setDialogues(this.gameData.story.dialogue);
            this.dialogueManager.renderDialogue(this.gameData.story.currentDialogueIndex);
            // 设置背景
            this.backgroundManager.setBackground(this.gameData.story.location, this.gameData.story.scene);
            // 设置选项
            this.choiceManager.setChoices(this.gameData.story.options);
            // 更新内存UI（如果记忆标签是活跃的）
            if ($('#memory-tab').hasClass('active')) {
                this.memoryUIManager.refreshMemoryTimeline();
            }
            // 更新日记（如果日记标签是活跃的）
            if ($('#journal-tab').hasClass('active')) {
                this.journalManager.refreshJournalContent();
            }
            console.log('UI已更新');
        }
        catch (error) {
            console.error('更新UI时发生错误:', error);
        }
    }
    /**
     * 显示下一条对话
     */
    nextDialogue() {
        if (!this.gameData)
            return;
        // 尝试显示下一条对话
        const hasMoreDialogue = this.dialogueManager.showNextDialogue();
        if (hasMoreDialogue) {
            // 更新游戏数据中的当前对话索引
            this.gameData.story.currentDialogueIndex = this.dialogueManager.getCurrentDialogueIndex();
        }
        else if (this.gameData.story.options.length > 0) {
            // 新增：检查是否是最后一条对话，且已经显示了选项
            const isDialogueFinished = this.dialogueManager.isDialogueFinished();
            const isChoicesAlreadyShown = this.choiceManager.areChoicesVisible();
            // 只有在对话已结束且选项还没显示的情况下才显示选项
            if (isDialogueFinished && !isChoicesAlreadyShown) {
                console.log('对话已结束，显示选项');
                this.choiceManager.showChoices();
            }
            else if (isChoicesAlreadyShown) {
                console.log('选项已显示，不再重复显示');
            }
        }
        else {
            // 没有更多对话也没有选项，可以添加额外逻辑
            console.log('对话结束，且没有可用选项');
        }
    }
    /**
     * 选择选项
     */
    async makeChoice(choice) {
        if (!this.gameData)
            return;
        console.log(`玩家选择了: ${choice}`);
        // 判断是否为自定义行动（不在预定义选项列表中）
        const isCustomAction = !this.gameData.story.options.includes(choice);
        // 隐藏选项
        this.choiceManager.hideChoices();
        // 显示加载提示
        this.uiManager.showLoading('正在生成回应...');
        // 保存玩家选择前的状态，以便出错时恢复
        const previousDialogueLength = this.gameData.story.dialogue.length;
        const previousDialogueIndex = this.gameData.story.currentDialogueIndex;
        // 添加玩家选择到对话
        const playerChoice = {
            speaker: '玩家',
            content: choice,
            style: 'normal',
            // 不设置portrait，使用默认规则
        };
        this.gameData.story.dialogue.push(playerChoice);
        this.dialogueManager.setDialogues(this.gameData.story.dialogue);
        this.gameData.story.currentDialogueIndex = this.gameData.story.dialogue.length - 1;
        this.dialogueManager.showDialogue(this.gameData.story.currentDialogueIndex);
        try {
            // 根据是否是自定义行动调用不同的处理方法
            const newGameState = isCustomAction
                ? await this.gameStateGenerationService.handleCustomAction(choice)
                : await this.gameStateGenerationService.generateNextGameState(choice);
            if (newGameState) {
                // 更新游戏状态
                this.gameData = newGameState;
                // 更新UI
                this.updateUI();
                // 保存到世界书
                await this.saveManager.saveGameState(this.gameData);
            }
            else {
                // 生成失败，恢复到玩家选择前的状态
                if (this.gameData) {
                    // 移除玩家选择
                    this.gameData.story.dialogue = this.gameData.story.dialogue.slice(0, previousDialogueLength);
                    this.gameData.story.currentDialogueIndex = previousDialogueIndex;
                    // 更新对话显示
                    this.dialogueManager.setDialogues(this.gameData.story.dialogue);
                    this.dialogueManager.showDialogue(this.gameData.story.currentDialogueIndex);
                    // 重新显示选项
                    this.choiceManager.showChoices();
                    this.uiManager.showNotification('生成游戏状态失败，请重新选择', 'warning');
                }
            }
        }
        catch (error) {
            console.error('处理玩家选择时出错:', error);
            // 出错时恢复到玩家选择前的状态
            if (this.gameData) {
                // 移除玩家选择
                this.gameData.story.dialogue = this.gameData.story.dialogue.slice(0, previousDialogueLength);
                this.gameData.story.currentDialogueIndex = previousDialogueIndex;
                // 更新对话显示
                this.dialogueManager.setDialogues(this.gameData.story.dialogue);
                this.dialogueManager.showDialogue(this.gameData.story.currentDialogueIndex);
                // 重新显示选项
                this.choiceManager.showChoices();
                this.uiManager.showNotification('生成响应时出错，请重新选择', 'error');
            }
        }
        finally {
            // 隐藏加载提示
            this.uiManager.hideLoading();
        }
    }
}

;// ./src/圣约与静默/游戏界面/index.ts
/**
 * 修道院箱庭游戏界面 - 主脚本
 */


// 等待DOM加载完成后初始化游戏
$(document).ready(() => {
    new GameController();
});</script><style>:root{--color-primary:#8a6d3b;--color-secondary:#a85832;--color-tertiary:#5d6e41;--color-bg-dark:#2a2a2a;--color-bg-light:#333333;--color-bg-lighter:#3c3c3c;--color-text-primary:#d1d1d1;--color-text-secondary:#888888;--color-text-whisper:#a8c5e9;--color-text-shocked:#e9a8a8;--color-text-special:#d6c8a4;--color-memory-primary:#c99e51;--color-memory-secondary:#9c7f46;--color-memory-highlight:#e4c987;--color-memory-bg:#2e2a25;--color-save-primary:#9e8148;--color-save-secondary:#b29656;--color-save-highlight:#d5b978;--color-save-bg:#2d2a24;--color-save-delete:#a85832;--font-heading:"Cinzel",serif;--font-body:"Lato",sans-serif;--header-height:60px;--tab-height:40px;--dialogue-height:200px;--border-radius:6px;--spacing-xs:4px;--spacing-sm:8px;--spacing-md:16px;--spacing-lg:24px;--spacing-xl:32px;--transition-fast:0.2s;--transition-normal:0.3s;--transition-slow:0.5s;--z-background:1;--z-characters:2;--z-dialogue:3;--z-choices:4;--z-header:5;--z-sidebar:10;--z-modal:20;--font-size-base:1rem;--font-size-small:0.9rem;--font-size-large:1.1rem}*{margin:0;padding:0;box-sizing:border-box}html{height:100%}button{cursor:pointer;font-family:inherit;background:none;border:none;color:inherit}button:focus{outline:none}ul{list-style:none}.hidden{display:none !important}.game-container{position:relative;width:100%;display:flex;flex-direction:column;overflow:hidden;background-color:var(--color-bg-dark);z-index:1}.game-header{height:var(--header-height);min-height:var(--header-height);background-color:rgba(20,20,20,.9);border-bottom:1px solid var(--color-primary);display:flex;justify-content:space-between;align-items:center;padding:0 var(--spacing-md);z-index:var(--z-header)}.header-left,.header-right{display:flex;align-items:center;gap:var(--spacing-md)}.game-title{font-family:var(--font-heading);font-size:1.5rem;color:var(--color-primary);margin-left:var(--spacing-md)}.game-date{font-family:var(--font-heading);font-size:.9rem;color:var(--color-text-secondary)}.game-controls{display:flex;align-items:center;gap:var(--spacing-sm)}.icon-button{background:none;border:none;font-size:1.5rem;color:var(--color-text-primary);cursor:pointer;display:flex;align-items:center;justify-content:center;width:36px;height:36px;border-radius:50%;transition:background-color var(--transition-fast),color var(--transition-fast)}.icon-button:hover{background-color:hsla(0,0%,100%,.1)}.icon-button.small{font-size:1rem;width:28px;height:28px}.icon-button.gold{color:var(--color-primary)}.icon-button.gold:hover{background-color:rgba(138,109,59,.2)}.content-wrapper{display:flex;flex-direction:column;position:relative;flex:1;overflow:hidden}.tab-navigation{display:flex;height:var(--tab-height);min-height:var(--tab-height);background-color:rgba(20,20,20,.9);border-bottom:1px solid var(--color-primary)}.tab-button{padding:0 var(--spacing-lg);height:100%;display:flex;align-items:center;gap:var(--spacing-sm);color:var(--color-text-secondary);font-family:var(--font-heading);border-bottom:3px solid rgba(0,0,0,0);transition:all var(--transition-fast)}.tab-button i{font-size:1rem}.tab-button:hover{color:var(--color-text-primary);background-color:hsla(0,0%,100%,.05)}.tab-button.active{color:var(--color-primary);border-bottom-color:var(--color-primary)}.tab-content{position:relative;aspect-ratio:16/9;overflow:hidden}.tab-pane{position:absolute;top:0;left:0;width:100%;height:100%;display:none;overflow:hidden;z-index:1}.tab-pane.active{display:flex;flex-direction:column;z-index:2}#story-tab{position:relative;overflow:hidden;display:flex;flex-direction:column}.background-container{position:absolute;top:0;left:0;width:100%;height:100%;background-size:cover;background-position:center;z-index:var(--z-background);transition:opacity var(--transition-slow)}.characters-container{position:absolute;bottom:0;left:0;width:100%;height:100%;z-index:var(--z-characters);display:flex;justify-content:space-between}.character-left,.character-right{height:100%;width:40%;background-size:contain;background-position:bottom;background-repeat:no-repeat;transition:transform var(--transition-normal),opacity var(--transition-normal)}.character-left{transform-origin:bottom left}.character-right{transform-origin:bottom right}.dialogue-container{position:absolute;bottom:30px;left:50%;transform:translateX(-50%);width:90%;max-width:900px;height:var(--dialogue-height);background-color:rgba(20,20,20,.85);backdrop-filter:blur(5px);-webkit-backdrop-filter:blur(5px);border:1px solid var(--color-primary);border-radius:var(--border-radius);z-index:var(--z-dialogue);display:flex;flex-direction:column;box-shadow:0 5px 15px rgba(0,0,0,.3);cursor:pointer}.dialogue-header{display:flex;justify-content:space-between;align-items:center;padding:var(--spacing-sm) var(--spacing-md);border-bottom:1px solid rgba(138,109,59,.3);background-color:rgba(0,0,0,.2)}.speaker-name{font-family:var(--font-heading);font-size:1.125rem;color:var(--color-primary);text-shadow:0 1px 2px rgba(0,0,0,.5)}.dialogue-controls{display:flex;gap:var(--spacing-sm)}.dialogue-content{flex:1;padding:var(--spacing-md);overflow-y:auto;font-size:1rem;line-height:1.6}.dialogue-text{margin-bottom:var(--spacing-md)}.dialogue-text.style-normal{color:var(--color-text-primary)}.dialogue-text.style-whisper{color:var(--color-text-whisper);font-style:italic}.dialogue-text.style-shocked{color:var(--color-text-shocked)}.dialogue-text.style-special{color:var(--color-text-special);font-weight:500}.choices-container{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:70%;max-width:650px;background-color:rgba(20,20,20,.85);backdrop-filter:blur(5px);-webkit-backdrop-filter:blur(5px);border:1px solid var(--color-primary);border-radius:var(--border-radius);z-index:var(--z-choices);padding:var(--spacing-sm);display:flex;flex-direction:column;gap:var(--spacing-sm);box-shadow:0 5px 15px rgba(0,0,0,.5)}.choices-container.compact-choices{width:60%;max-width:500px;padding:var(--spacing-xs)}.choices-header{padding-bottom:var(--spacing-xs);margin-bottom:var(--spacing-xs);border-bottom:1px solid rgba(138,109,59,.3);display:flex;justify-content:space-between;align-items:center}.choices-header h3{font-family:var(--font-heading);font-size:1rem;color:var(--color-primary);margin:0;text-align:left}.compact-choices .choices-header{margin-bottom:0;padding-bottom:var(--spacing-xs)}.compact-choices .choices-header h3{font-size:.9rem}.preset-choices{display:flex;flex-direction:column;gap:0}.choice-button{background-color:rgba(0,0,0,0);border:none;border-radius:0;padding:var(--spacing-sm) var(--spacing-md);text-align:left;color:var(--color-text-primary);font-size:.95rem;transition:background-color var(--transition-fast),color var(--transition-fast);position:relative;overflow:hidden}.choice-button::before{content:"";position:absolute;left:0;top:50%;transform:translateY(-50%);height:0;width:3px;background-color:var(--color-primary);transition:height var(--transition-fast)}.choice-button:hover{background-color:hsla(0,0%,100%,.05);color:var(--color-primary)}.choice-button:hover::before{height:70%}.compact-choices .choice-button{padding:var(--spacing-xs) var(--spacing-md)}.custom-choice{display:flex;gap:var(--spacing-xs);margin-top:var(--spacing-xs);align-items:center;height:32px;border-top:1px solid rgba(138,109,59,.2);padding-top:var(--spacing-xs)}.custom-choice input{flex:1;background-color:hsla(0,0%,100%,.03);border:none;border-bottom:1px solid rgba(138,109,59,.3);border-radius:0;padding:4px var(--spacing-sm);color:var(--color-text-primary);font-size:.95rem;height:100%;box-sizing:border-box;transition:all var(--transition-fast);position:relative}.custom-choice input:focus{outline:none;border-bottom-color:var(--color-primary);background-color:hsla(0,0%,100%,.05);color:var(--color-primary)}.custom-choice input::placeholder{color:var(--color-text-secondary);opacity:.7}.compact-choices .custom-choice input{padding:2px var(--spacing-sm)}.custom-choice button{background-color:rgba(0,0,0,0);color:var(--color-text-secondary);padding:0 var(--spacing-md);border:none;border-radius:0;border-bottom:1px solid rgba(138,109,59,.3);transition:all var(--transition-fast);font-size:.95rem;height:100%;white-space:nowrap;position:relative}.custom-choice button::before{content:"";position:absolute;left:0;top:50%;transform:translateY(-50%);height:0;width:2px;background-color:var(--color-primary);transition:height var(--transition-fast)}.custom-choice button:hover{background-color:hsla(0,0%,100%,.05);color:var(--color-primary);border-bottom-color:var(--color-primary)}.custom-choice button:hover::before{height:70%}.compact-choices .custom-choice button{padding:0 var(--spacing-sm)}.choices-header .icon-button.small{width:24px;height:24px;border-radius:50%;display:flex;justify-content:center;align-items:center;color:var(--color-text-secondary);transition:background-color var(--transition-fast),color var(--transition-fast)}.choices-header .icon-button.small:hover{background-color:hsla(0,0%,100%,.1);color:var(--color-text-primary)}.journal-container{display:flex;flex-direction:column;height:100%;width:100%;background-color:var(--color-bg-light)}.journal-nav{display:flex;gap:var(--spacing-md);padding:var(--spacing-md);background-color:rgba(20,20,20,.8);border-bottom:1px solid var(--color-tertiary)}.journal-nav-item{padding:var(--spacing-sm) var(--spacing-md);border-radius:var(--border-radius);color:var(--color-text-secondary);transition:all var(--transition-fast);display:flex;align-items:center;gap:var(--spacing-sm)}.journal-nav-item i{font-size:1rem}.journal-nav-item:hover{color:var(--color-text-primary);background-color:hsla(0,0%,100%,.05)}.journal-nav-item.active{color:var(--color-tertiary);background-color:rgba(93,110,65,.2)}.journal-content{flex:1;padding:var(--spacing-md);overflow-y:auto}.journal-section{display:none;height:100%}.journal-section.active{display:flex}#characters-section{display:flex;gap:var(--spacing-lg)}.character-cards{width:30%;display:flex;flex-direction:column;gap:var(--spacing-md);overflow-y:auto}.character-card{display:flex;align-items:center;gap:var(--spacing-md);padding:var(--spacing-md);background-color:var(--color-bg-lighter);border-radius:var(--border-radius);cursor:pointer;transition:all var(--transition-fast)}.character-card:hover{transform:translateY(-2px);box-shadow:0 4px 8px rgba(0,0,0,.2)}.character-card.active{border-left:3px solid var(--color-tertiary)}.character-avatar{width:60px;height:60px;border-radius:50%;object-fit:cover;border:2px solid var(--color-tertiary)}.character-info{flex:1}.character-name{font-size:1.1rem;font-weight:bold;margin-bottom:var(--spacing-xs)}.character-role{font-size:.9rem;color:var(--color-text-secondary)}.character-details{flex:1;padding:var(--spacing-lg);background-color:var(--color-bg-lighter);border-radius:var(--border-radius);display:flex;flex-direction:column;gap:var(--spacing-lg)}.monastery-info{padding:var(--spacing-lg);background-color:var(--color-bg-lighter);border-radius:var(--border-radius)}#knowledge-section{display:flex;gap:var(--spacing-lg)}.knowledge-categories{width:30%;display:flex;flex-direction:column;gap:var(--spacing-sm);overflow-y:auto}.knowledge-category{padding:var(--spacing-md);background-color:var(--color-bg-lighter);border-radius:var(--border-radius);cursor:pointer;transition:all var(--transition-fast)}.knowledge-category:hover{background-color:rgba(93,110,65,.2)}.knowledge-category.active{background-color:rgba(93,110,65,.3);border-left:3px solid var(--color-tertiary)}.knowledge-entries{flex:1;display:flex;flex-direction:column;gap:var(--spacing-md);overflow-y:auto}.knowledge-entry{padding:var(--spacing-lg);background-color:var(--color-bg-lighter);border-radius:var(--border-radius)}.knowledge-title{font-size:1.2rem;font-family:var(--font-heading);color:var(--color-tertiary);margin-bottom:var(--spacing-md);border-bottom:1px solid rgba(93,110,65,.3);padding-bottom:var(--spacing-sm)}.knowledge-content{line-height:1.6}.memory-container{display:flex;flex-direction:column;height:100%;width:100%;background-color:var(--color-memory-bg)}.memory-header{display:flex;justify-content:space-between;align-items:center;padding:var(--spacing-md);border-bottom:1px solid var(--color-memory-secondary);background-color:rgba(0,0,0,.2)}.memory-header h2{color:var(--color-memory-primary);font-family:var(--font-heading);display:flex;align-items:center;gap:var(--spacing-sm)}.memory-button{background-color:var(--color-memory-secondary);color:#fff;padding:var(--spacing-sm) var(--spacing-md);border-radius:var(--border-radius);display:flex;align-items:center;gap:var(--spacing-sm);transition:background-color var(--transition-fast)}.memory-button:hover{background-color:var(--color-memory-primary)}.memory-button:disabled{cursor:not-allowed}.memory-timeline-container{padding:var(--spacing-md);background-color:rgba(0,0,0,.15);border-bottom:1px solid rgba(158,129,72,.3)}.memory-timeline{position:relative;display:flex;align-items:center;justify-content:center;padding:var(--spacing-sm) 0;overflow-x:auto;scrollbar-width:thin;scrollbar-color:var(--color-memory-secondary) rgba(0,0,0,.2);gap:var(--spacing-md);height:60px}.memory-timeline::-webkit-scrollbar{height:4px}.memory-timeline::-webkit-scrollbar-track{background:rgba(0,0,0,.2)}.memory-timeline::-webkit-scrollbar-thumb{background-color:var(--color-memory-secondary);border-radius:2px}.memory-timeline::before{content:"";position:absolute;top:50%;left:0;right:0;height:2px;background-color:var(--color-memory-secondary);z-index:1}.memory-node-simple{position:relative;width:24px;height:24px;border-radius:50%;background-color:var(--color-memory-secondary);z-index:2;cursor:pointer;box-shadow:0 0 0 0 rgba(201,158,81,0);transition:all .3s ease-in-out}.memory-node-simple::before{content:"";position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:2px;height:16px;background-color:var(--color-memory-secondary);z-index:1}.memory-node-simple:hover{background-color:var(--color-memory-primary);transform:scale(1.2);box-shadow:0 0 10px 2px rgba(201,158,81,.3)}.memory-node-simple.selected{background-color:var(--color-memory-highlight);transform:scale(1.3);box-shadow:0 0 15px 5px rgba(201,158,81,.5);animation:memory-pulse 2s infinite}@keyframes memory-pulse{0%{box-shadow:0 0 0 0 rgba(201,158,81,.7)}70%{box-shadow:0 0 0 10px rgba(201,158,81,0)}100%{box-shadow:0 0 0 0 rgba(201,158,81,0)}}.memory-node{display:none}.memory-detail-container{flex:1;display:flex;flex-direction:column;padding:var(--spacing-md);gap:var(--spacing-md);overflow-y:auto}.memory-content{flex:1;padding:var(--spacing-lg);background-color:rgba(0,0,0,.2);border:1px solid var(--color-memory-secondary);border-radius:var(--border-radius);line-height:1.6;overflow-y:auto}.memory-content-image{width:100%;height:200px;background-size:cover;background-position:center;border-radius:var(--border-radius);margin-bottom:var(--spacing-md)}.memory-content-text{color:var(--color-text-primary)}.memory-actions{display:flex;justify-content:center;gap:var(--spacing-md)}.memory-travel-button{background-color:var(--color-memory-primary);color:#000;padding:var(--spacing-md) var(--spacing-xl);border-radius:var(--border-radius);font-family:var(--font-heading);font-weight:bold;display:flex;align-items:center;gap:var(--spacing-md);transition:all var(--transition-fast)}.memory-travel-button i{font-size:1.25rem}.memory-travel-button:hover{background-color:var(--color-memory-highlight);transform:translateY(-2px);box-shadow:0 4px 12px rgba(201,158,81,.3)}.memory-travel-button:disabled{opacity:.5;background-color:var(--color-memory-secondary);transform:none;box-shadow:none;cursor:not-allowed}.memory-empty-message{text-align:center;color:var(--color-text-secondary);font-style:italic;margin-top:var(--spacing-xl)}.memory-empty-timeline{padding:var(--spacing-md);text-align:center;color:var(--color-text-secondary);font-style:italic;width:100%}.loading-indicator{position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,.7);z-index:var(--z-modal);display:flex;flex-direction:column;justify-content:center;align-items:center;gap:var(--spacing-lg)}.loading-spinner{width:50px;height:50px;border:4px solid rgba(138,109,59,.3);border-radius:50%;border-top-color:var(--color-primary);animation:spin 1s linear infinite}@keyframes spin{to{transform:rotate(360deg)}}.loading-text{color:var(--color-text-primary);font-size:1.125rem}.confirm-container{position:fixed;top:0;left:0;width:100%;height:100%;z-index:10000;display:flex;justify-content:center;align-items:center;pointer-events:none}.modal-backdrop{display:none}.confirm-dialog{position:relative;background-color:var(--color-bg-light);border:1px solid var(--color-primary);border-radius:var(--border-radius);padding:var(--spacing-lg);width:400px;max-width:90%;z-index:2;box-shadow:0 8px 24px rgba(0,0,0,.7);pointer-events:auto;animation:dialogPop .2s ease-out forwards}@keyframes dialogPop{0%{opacity:0;transform:scale(0.9)}100%{opacity:1;transform:scale(1)}}.confirm-message{margin-bottom:var(--spacing-lg);text-align:center;font-size:1.1rem;line-height:1.5;color:#fff}.confirm-buttons{display:flex;justify-content:center;gap:var(--spacing-md);margin-top:var(--spacing-lg)}.confirm-button{padding:10px 20px;border-radius:var(--border-radius);min-width:100px;font-weight:bold;font-size:1rem;transition:all var(--transition-fast);border:1px solid rgba(0,0,0,0);cursor:pointer;margin:0 10px;pointer-events:auto !important}.confirm-button:active{transform:scale(0.95)}.confirm-yes{background-color:var(--color-primary);color:#fff;border:1px solid var(--color-memory-highlight)}.confirm-yes:hover{background-color:var(--color-memory-highlight);transform:translateY(-2px);box-shadow:0 2px 5px rgba(0,0,0,.3)}.confirm-no{background-color:rgba(80,80,80,.5);color:var(--color-text-primary);border:1px solid hsla(0,0%,100%,.1)}.confirm-no:hover{background-color:rgba(100,100,100,.7);transform:translateY(-2px);box-shadow:0 2px 5px rgba(0,0,0,.3)}#notification-container{position:fixed;top:var(--spacing-md);right:var(--spacing-md);z-index:var(--z-modal);display:flex;flex-direction:column;gap:var(--spacing-sm);max-width:300px}.notification{padding:var(--spacing-md);border-radius:var(--border-radius);background-color:var(--color-bg-light);box-shadow:0 4px 8px rgba(0,0,0,.3);opacity:0;transform:translateX(20px);transition:all var(--transition-normal)}.notification-show{opacity:1;transform:translateX(0)}.notification-hide{opacity:0;transform:translateX(20px)}.notification-info{border-left:4px solid #3498db}.notification-success{border-left:4px solid #2ecc71}.notification-warning{border-left:4px solid #f39c12}.notification-error{border-left:4px solid #e74c3c}@media (max-width:768px){html:not(.mobile-ui):not(.desktop-ui) :root{--header-height:50px}html:not(.mobile-ui):not(.desktop-ui) .game-container{display:flex;flex-direction:column;height:auto;overflow-y:hidden}html:not(.mobile-ui):not(.desktop-ui) .game-header{height:auto;min-height:auto;padding:var(--spacing-sm);flex-shrink:0;z-index:10}html:not(.mobile-ui):not(.desktop-ui) .header-left,html:not(.mobile-ui):not(.desktop-ui) .header-right{gap:var(--spacing-sm)}html:not(.mobile-ui):not(.desktop-ui) .game-title{font-size:1.2rem;margin-left:0}html:not(.mobile-ui):not(.desktop-ui) .game-date{font-size:.8rem}html:not(.mobile-ui):not(.desktop-ui) .icon-button{width:32px;height:32px;font-size:1.2rem}html:not(.mobile-ui):not(.desktop-ui) .content-wrapper{flex:1;position:relative;overflow:hidden;display:flex;flex-direction:column}html:not(.mobile-ui):not(.desktop-ui) .tab-navigation{height:36px;min-height:36px;flex-shrink:0;z-index:9}html:not(.mobile-ui):not(.desktop-ui) .tab-button{padding:0 var(--spacing-sm);font-size:.9rem}html:not(.mobile-ui):not(.desktop-ui) .tab-button i{font-size:.9rem}html:not(.mobile-ui):not(.desktop-ui) .tab-content{flex:1;position:relative;display:flex;flex-direction:column;overflow:hidden}html:not(.mobile-ui):not(.desktop-ui) .tab-pane.active{position:relative;height:100%;display:flex;flex-direction:column}html:not(.mobile-ui):not(.desktop-ui) #story-tab{display:flex;flex-direction:column;position:relative;height:100%}html:not(.mobile-ui):not(.desktop-ui) .background-container{position:fixed;top:calc(var(--header-height) + 36px);left:0;width:100%;height:56.25vw;z-index:1}html:not(.mobile-ui):not(.desktop-ui) .characters-container{position:fixed;top:calc(var(--header-height) + 36px);left:0;width:100%;height:56.25vw;z-index:2}html:not(.mobile-ui):not(.desktop-ui) .dialogue-container{position:fixed;top:calc(var(--header-height) + 36px + 56.25vw);left:0;right:0;width:100%;height:calc(100vh - (var(--header-height) + 36px + 56.25vw));bottom:0;max-width:none;max-height:none;transform:none;border-radius:0;border-left:none;border-right:none;border-bottom:none;border-top:1px solid var(--color-primary);z-index:3;background-color:rgba(20,20,20,.95);box-shadow:none;cursor:default}html:not(.mobile-ui):not(.desktop-ui) .dialogue-header{padding:var(--spacing-xs) var(--spacing-sm)}html:not(.mobile-ui):not(.desktop-ui) .dialogue-content{padding:var(--spacing-sm);height:calc(100% - 35px);overflow-y:auto;scrollbar-width:thin;scrollbar-color:var(--color-primary) rgba(20,20,20,.3)}html:not(.mobile-ui):not(.desktop-ui) .dialogue-content::-webkit-scrollbar{width:4px}html:not(.mobile-ui):not(.desktop-ui) .dialogue-content::-webkit-scrollbar-track{background:rgba(20,20,20,.3)}html:not(.mobile-ui):not(.desktop-ui) .dialogue-content::-webkit-scrollbar-thumb{background-color:var(--color-primary);border-radius:2px}html:not(.mobile-ui):not(.desktop-ui) .speaker-name{font-size:1rem}html:not(.mobile-ui):not(.desktop-ui) .choices-container{width:90%;max-width:90%;padding:var(--spacing-xs);z-index:4}html:not(.mobile-ui):not(.desktop-ui) .character-left,html:not(.mobile-ui):not(.desktop-ui) .character-right{height:100%;transform-origin:center bottom}html:not(.mobile-ui):not(.desktop-ui) #journal-tab,html:not(.mobile-ui):not(.desktop-ui) #memory-tab{position:fixed;top:calc(var(--header-height) + 36px);left:0;width:100%;height:calc(100vh - (var(--header-height) + 36px));bottom:0;z-index:3}html:not(.mobile-ui):not(.desktop-ui) .journal-container,html:not(.mobile-ui):not(.desktop-ui) .memory-container{padding:0;height:100%;width:100%;overflow-y:auto;display:flex;flex-direction:column}html:not(.mobile-ui):not(.desktop-ui) .memory-container{background-color:var(--color-memory-bg)}html:not(.mobile-ui):not(.desktop-ui) .memory-header{padding:var(--spacing-sm);border-bottom:1px solid var(--color-memory-secondary);background-color:rgba(0,0,0,.2);position:sticky;top:0;z-index:1}html:not(.mobile-ui):not(.desktop-ui) .memory-header h2{font-size:1.2rem;margin-bottom:var(--spacing-sm)}html:not(.mobile-ui):not(.desktop-ui) .memory-button{background-color:var(--color-memory-primary);padding:var(--spacing-xs) var(--spacing-sm);border-radius:var(--border-radius);font-size:.9rem;display:flex;align-items:center;justify-content:center;width:100%}html:not(.mobile-ui):not(.desktop-ui) .memory-timeline-container{padding:var(--spacing-sm);border-bottom:1px solid rgba(158,129,72,.3);background-color:rgba(0,0,0,.15)}html:not(.mobile-ui):not(.desktop-ui) .memory-timeline{padding:var(--spacing-sm) 0;height:50px;gap:var(--spacing-sm)}html:not(.mobile-ui):not(.desktop-ui) .memory-node-simple{width:20px;height:20px}html:not(.mobile-ui):not(.desktop-ui) .memory-node-simple::before{height:12px}html:not(.mobile-ui):not(.desktop-ui) .memory-node-simple.selected{transform:scale(1.25);box-shadow:0 0 10px 3px rgba(201,158,81,.5)}html:not(.mobile-ui):not(.desktop-ui) .memory-node{display:none}html:not(.mobile-ui):not(.desktop-ui) .memory-node-content,html:not(.mobile-ui):not(.desktop-ui) .memory-timestamp{display:none}html:not(.mobile-ui):not(.desktop-ui) .memory-detail-container{flex:1;padding:var(--spacing-sm);display:flex;flex-direction:column}html:not(.mobile-ui):not(.desktop-ui) .memory-content{flex:1;padding:var(--spacing-md);background-color:rgba(0,0,0,.2);border:1px solid var(--color-memory-secondary);overflow-y:auto;font-size:.95rem;line-height:1.5}html:not(.mobile-ui):not(.desktop-ui) .memory-actions{padding:var(--spacing-sm) 0}html:not(.mobile-ui):not(.desktop-ui) .memory-travel-button{width:100%;justify-content:center;padding:var(--spacing-sm);background-color:var(--color-memory-primary);font-size:1rem}html:not(.mobile-ui):not(.desktop-ui) .memory-empty-timeline{padding:var(--spacing-md);font-size:.9rem}html:not(.mobile-ui):not(.desktop-ui) .journal-container{background-color:var(--color-bg-light)}html:not(.mobile-ui):not(.desktop-ui) .journal-nav{flex-wrap:wrap;padding:var(--spacing-sm);border-bottom:1px solid var(--color-tertiary);background-color:rgba(0,0,0,.2);position:sticky;top:0;z-index:1}html:not(.mobile-ui):not(.desktop-ui) .journal-nav-item{font-size:.9rem;padding:var(--spacing-xs) var(--spacing-sm);margin-right:var(--spacing-xs);margin-bottom:var(--spacing-xs);border-radius:var(--border-radius)}html:not(.mobile-ui):not(.desktop-ui) .journal-content{flex:1;padding:var(--spacing-sm);overflow-y:auto}html:not(.mobile-ui):not(.desktop-ui) .journal-section{background-color:var(--color-bg-lighter);border-radius:var(--border-radius);padding:var(--spacing-sm);margin-bottom:var(--spacing-sm)}}@media (max-width:768px)and (orientation:portrait){html:not(.mobile-ui):not(.desktop-ui) .game-header{--header-height:50px}html:not(.mobile-ui):not(.desktop-ui) .character-left,html:not(.mobile-ui):not(.desktop-ui) .character-right{transform:scale(0.9)}html:not(.mobile-ui):not(.desktop-ui) .dialogue-container{backdrop-filter:blur(8px)}}@media (max-width:768px)and (orientation:landscape){html:not(.mobile-ui):not(.desktop-ui) .game-header{--header-height:40px}html:not(.mobile-ui):not(.desktop-ui) .background-container,html:not(.mobile-ui):not(.desktop-ui) .characters-container{height:40vh;top:calc(var(--header-height) + 36px)}html:not(.mobile-ui):not(.desktop-ui) .dialogue-container{top:calc(var(--header-height) + 36px + 40vh);height:calc(100vh - (var(--header-height) + 36px + 40vh));min-height:0}html:not(.mobile-ui):not(.desktop-ui) #journal-tab,html:not(.mobile-ui):not(.desktop-ui) #memory-tab{top:calc(var(--header-height) + 36px);height:calc(100vh - (var(--header-height) + 36px))}html:not(.mobile-ui):not(.desktop-ui) .memory-detail-container,html:not(.mobile-ui):not(.desktop-ui) .journal-content{padding:var(--spacing-xs)}html:not(.mobile-ui):not(.desktop-ui) .memory-content,html:not(.mobile-ui):not(.desktop-ui) .journal-section{padding:var(--spacing-sm)}html:not(.mobile-ui):not(.desktop-ui) .memory-header h2,html:not(.mobile-ui):not(.desktop-ui) .journal-nav-item{font-size:.85rem}}.modal{z-index:9999}.modal-dialog:not(.monastery-dialog){max-width:90%;width:800px}.modal-content:not(.monastery-dialog .modal-content){background-color:var(--color-bg-light);color:var(--color-text-primary);border:1px solid var(--color-primary);border-radius:var(--border-radius);box-shadow:0 5px 15px rgba(0,0,0,.5)}.modal-header:not(.monastery-dialog .modal-header),.modal-footer:not(.monastery-dialog .modal-footer){border-color:rgba(138,109,59,.3);padding:var(--spacing-sm) var(--spacing-md)}.modal-header .close{color:var(--color-text-primary);opacity:.7;transition:opacity var(--transition-fast)}.modal-header .close:hover{opacity:1}.btn-secondary:not(.monastery-btn){background-color:var(--color-bg-lighter);border-color:var(--color-bg-lighter);color:var(--color-text-primary);transition:all var(--transition-fast)}.btn-secondary:not(.monastery-btn):hover{background-color:var(--color-bg-light);border-color:var(--color-primary)}.modal-backdrop{z-index:9998}.modal-open{overflow:hidden;padding-right:0 !important}.modal.fade .modal-dialog{transform:translate(0,-50px);transition:transform var(--transition-normal) ease}.modal.show .modal-dialog{transform:none}#load-game-modal .modal-dialog{max-width:700px}#load-game-modal .modal-content{background-color:var(--color-save-bg);border:1px solid var(--color-save-primary);backdrop-filter:blur(5px);-webkit-backdrop-filter:blur(5px)}#load-game-modal .modal-header{background-color:rgba(0,0,0,.2);border-bottom:1px solid var(--color-save-primary)}#load-game-modal .modal-header .modal-title{color:var(--color-save-highlight);font-family:var(--font-heading);font-size:1.3rem}#load-game-modal .modal-header .close{color:var(--color-save-highlight);text-shadow:none;opacity:.7}#load-game-modal .modal-header .close:hover{opacity:1}#load-game-modal .modal-body{padding:var(--spacing-md);max-height:70vh;overflow-y:auto;scrollbar-width:thin;scrollbar-color:var(--color-save-primary) rgba(0,0,0,.2)}#load-game-modal .modal-body::-webkit-scrollbar{width:8px}#load-game-modal .modal-body::-webkit-scrollbar-track{background:rgba(0,0,0,.2);border-radius:var(--border-radius)}#load-game-modal .modal-body::-webkit-scrollbar-thumb{background:var(--color-save-primary);border-radius:var(--border-radius)}#load-game-modal .modal-body::-webkit-scrollbar-thumb:hover{background:var(--color-save-highlight)}#load-game-modal .modal-footer{background-color:rgba(0,0,0,.2);border-top:1px solid var(--color-save-primary)}.save-tabs{display:flex;margin-bottom:var(--spacing-md);background-color:rgba(0,0,0,.15);border-radius:var(--border-radius);padding:0;overflow:hidden}.save-tab-btn{flex:1;padding:var(--spacing-sm) 0;background:none;border:none;color:var(--color-text-secondary);cursor:pointer;font-family:var(--font-heading);font-size:1rem;transition:all var(--transition-fast);position:relative}.save-tab-btn::after{content:"";position:absolute;bottom:0;left:0;width:100%;height:3px;background-color:rgba(0,0,0,0);transition:background-color var(--transition-fast)}.save-tab-btn:hover{color:var(--color-text-primary)}.save-tab-btn.active{color:var(--color-save-highlight);background-color:rgba(158,129,72,.1)}.save-tab-btn.active::after{background-color:var(--color-save-primary)}.save-tab-content{position:relative}.save-tab-pane{display:none;animation:fadeIn .3s ease}.save-tab-pane.active{display:block}@keyframes fadeIn{from{opacity:0}to{opacity:1}}.save-list{list-style:none;padding:0;margin:0;display:grid;grid-template-columns:repeat(auto-fill,minmax(300px,1fr));gap:var(--spacing-md)}.save-item{background-color:hsla(0,0%,100%,.05);border:1px solid rgba(158,129,72,.3);border-radius:var(--border-radius);overflow:hidden;transition:border-color var(--transition-fast),box-shadow var(--transition-fast);position:relative;cursor:pointer}.save-item:hover{border-color:var(--color-save-highlight);box-shadow:0 3px 10px rgba(0,0,0,.2)}.save-item.empty{grid-column:1/-1;padding:var(--spacing-lg);text-align:center;color:var(--color-text-secondary);cursor:default}.save-item.empty:hover{box-shadow:none;border-color:rgba(158,129,72,.3)}.save-item-thumbnail{height:120px;background-size:cover;background-position:center;border-bottom:1px solid rgba(158,129,72,.2);position:relative;transition:filter var(--transition-fast)}.save-item-thumbnail::after{content:"";position:absolute;bottom:0;left:0;right:0;height:40px;background:linear-gradient(to top,rgba(0,0,0,0.7),transparent)}.save-item:hover .save-item-thumbnail{filter:brightness(1.1)}.save-item-header{padding:var(--spacing-sm) var(--spacing-md);display:flex;justify-content:space-between;align-items:center;background-color:rgba(0,0,0,.2);border-bottom:1px solid rgba(158,129,72,.2);backdrop-filter:blur(2px);-webkit-backdrop-filter:blur(2px)}.save-item-title{font-weight:bold;font-family:var(--font-heading);font-size:1rem;color:var(--color-save-highlight);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:60%;transition:color var(--transition-fast)}.save-item:hover .save-item-title{color:var(--color-save-highlight)}.save-item-date{font-size:.8rem;color:var(--color-text-secondary)}.save-item-content{padding:var(--spacing-sm) var(--spacing-md);font-size:.9rem;color:var(--color-text-primary);max-height:60px;overflow:hidden;text-overflow:ellipsis;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical}.save-item-actions{padding:var(--spacing-xs) var(--spacing-md);display:flex;justify-content:flex-end;background-color:rgba(0,0,0,.2);border-top:1px solid rgba(158,129,72,.2);opacity:0;transition:opacity var(--transition-fast)}.save-item-actions button{background-color:rgba(0,0,0,0);color:var(--color-text-secondary);border:1px solid rgba(158,129,72,.3);border-radius:4px;padding:var(--spacing-xs) var(--spacing-sm);font-size:.8rem;transition:all var(--transition-fast)}.save-item-actions button:hover{background-color:var(--color-save-delete);color:#fff;border-color:var(--color-save-delete)}.save-item:hover .save-item-actions{opacity:1}#btn-create-manual-save{background-color:var(--color-save-primary);color:#fff;border:none;font-family:var(--font-heading);padding:var(--spacing-sm) var(--spacing-lg);border-radius:var(--border-radius);transition:background-color var(--transition-fast),box-shadow var(--transition-fast);display:flex;align-items:center}#btn-create-manual-save i{margin-right:var(--spacing-sm)}#btn-create-manual-save:hover{background-color:var(--color-save-highlight);color:#000;box-shadow:0 2px 5px rgba(0,0,0,.2)}#load-game-modal .btn-secondary{background-color:hsla(0,0%,100%,.1);border:1px solid rgba(158,129,72,.3);color:var(--color-text-primary)}#load-game-modal .btn-secondary:hover{background-color:hsla(0,0%,100%,.15);border-color:var(--color-save-secondary)}.input-dialog-container input{background-color:hsla(0,0%,100%,.1);border:1px solid var(--color-save-secondary);color:var(--color-text-primary);border-radius:var(--border-radius);padding:var(--spacing-sm);width:100%;margin-bottom:var(--spacing-md)}.input-dialog-container input:focus{outline:none;border-color:var(--color-save-highlight);box-shadow:0 0 0 2px rgba(213,185,120,.25)}html.font-small .dialogue-content,html.font-small .choice-button,html.font-small .custom-choice input,html.font-small .memory-content-text,html.font-small .journal-content,html.font-small .knowledge-content{font-size:var(--font-size-small)}html.font-small .speaker-name,html.font-small .memory-header h2,html.font-small .journal-nav-item,html.font-small .tab-button{font-size:.95rem}html.font-small .dialogue-container{--dialogue-height:180px}html.font-large .dialogue-content,html.font-large .choice-button,html.font-large .custom-choice input,html.font-large .memory-content-text,html.font-large .journal-content,html.font-large .knowledge-content{font-size:var(--font-size-large);line-height:1.7}html.font-large .speaker-name,html.font-large .memory-header h2,html.font-large .journal-nav-item,html.font-large .tab-button{font-size:1.15rem}html.font-large .dialogue-container{--dialogue-height:230px}html.mobile-ui :root{--header-height:50px}html.mobile-ui .game-container{display:flex;flex-direction:column;height:100vh;overflow-y:hidden}html.mobile-ui .game-header{height:auto;min-height:auto;padding:var(--spacing-sm);flex-shrink:0;z-index:10}html.mobile-ui .header-left,html.mobile-ui .header-right{gap:var(--spacing-sm)}html.mobile-ui .game-title{font-size:1.2rem;margin-left:0}html.mobile-ui .game-date{font-size:.8rem}html.mobile-ui .icon-button{width:32px;height:32px;font-size:1.2rem}html.mobile-ui .content-wrapper{flex:1;position:relative;overflow:hidden;display:flex;flex-direction:column}html.mobile-ui .tab-navigation{height:36px;min-height:36px;flex-shrink:0;z-index:9}html.mobile-ui .tab-button{padding:0 var(--spacing-sm);font-size:.9rem}html.mobile-ui .tab-button i{font-size:.9rem}html.mobile-ui .tab-content{flex:1;position:relative;display:flex;flex-direction:column;overflow:hidden}html.mobile-ui .tab-pane.active{position:relative;height:100%;display:flex;flex-direction:column}html.mobile-ui #story-tab{display:flex;flex-direction:column;position:relative;height:100%}html.mobile-ui .background-container{position:fixed;top:calc(var(--header-height) + 36px);left:0;width:100%;height:56.25vw;z-index:1}html.mobile-ui .characters-container{position:fixed;top:calc(var(--header-height) + 36px);left:0;width:100%;height:56.25vw;z-index:2}html.mobile-ui .dialogue-container{position:fixed;top:calc(var(--header-height) + 36px + 56.25vw);left:0;right:0;width:100%;height:calc(100vh - (var(--header-height) + 36px + 56.25vw));bottom:0;max-width:none;max-height:none;transform:none;border-radius:0;border-left:none;border-right:none;border-bottom:none;border-top:1px solid var(--color-primary);z-index:3;background-color:rgba(20,20,20,.95);box-shadow:none;cursor:default}html.mobile-ui .dialogue-header{padding:var(--spacing-xs) var(--spacing-sm)}html.mobile-ui .dialogue-content{padding:var(--spacing-sm);height:calc(100% - 35px);overflow-y:auto;scrollbar-width:thin;scrollbar-color:var(--color-primary) rgba(20,20,20,.3)}html.mobile-ui .dialogue-content::-webkit-scrollbar{width:4px}html.mobile-ui .dialogue-content::-webkit-scrollbar-track{background:rgba(20,20,20,.3)}html.mobile-ui .dialogue-content::-webkit-scrollbar-thumb{background-color:var(--color-primary);border-radius:2px}html.mobile-ui .speaker-name{font-size:1rem}html.mobile-ui .choices-container{width:90%;max-width:90%;padding:var(--spacing-xs);z-index:4}html.mobile-ui .character-left,html.mobile-ui .character-right{height:100%;transform-origin:center bottom}html.mobile-ui #journal-tab,html.mobile-ui #memory-tab{position:fixed;top:calc(var(--header-height) + 36px);left:0;width:100%;height:calc(100vh - (var(--header-height) + 36px));bottom:0;z-index:3}html.mobile-ui .journal-container,html.mobile-ui .memory-container{padding:0;height:100%;width:100%;overflow-y:auto;display:flex;flex-direction:column}html.mobile-ui .memory-container{background-color:var(--color-memory-bg)}html.mobile-ui .memory-header{padding:var(--spacing-sm);border-bottom:1px solid var(--color-memory-secondary);background-color:rgba(0,0,0,.2);position:sticky;top:0;z-index:1}html.mobile-ui .memory-header h2{font-size:1.2rem;margin-bottom:var(--spacing-sm)}html.mobile-ui .memory-button{padding:var(--spacing-xs) var(--spacing-sm);border-radius:var(--border-radius);font-size:.9rem}html.mobile-ui .memory-timeline-container{padding:var(--spacing-sm);border-bottom:1px solid rgba(158,129,72,.3);background-color:rgba(0,0,0,.15)}html.mobile-ui .memory-timeline{padding:var(--spacing-sm) 0;height:50px;gap:var(--spacing-sm)}html.mobile-ui .memory-node-simple{width:20px;height:20px}html.mobile-ui .memory-node-simple::before{height:12px}html.mobile-ui .memory-node-simple.selected{transform:scale(1.25);box-shadow:0 0 10px 3px rgba(201,158,81,.5)}html.mobile-ui .memory-detail-container{flex:1;padding:var(--spacing-sm);display:flex;flex-direction:column}html.mobile-ui .memory-content{flex:1;padding:var(--spacing-md);background-color:rgba(0,0,0,.2);border:1px solid var(--color-memory-secondary);overflow-y:auto;font-size:.95rem;line-height:1.5}html.mobile-ui .memory-actions{padding:var(--spacing-sm) 0}html.mobile-ui .memory-travel-button{width:100%;justify-content:center;padding:var(--spacing-sm);background-color:var(--color-memory-primary);font-size:1rem}html.mobile-ui .journal-container{background-color:var(--color-bg-light)}html.mobile-ui .journal-nav{flex-wrap:wrap;padding:var(--spacing-sm);border-bottom:1px solid var(--color-tertiary);background-color:rgba(0,0,0,.2);position:sticky;top:0;z-index:1}html.mobile-ui .journal-nav-item{font-size:.9rem;padding:var(--spacing-xs) var(--spacing-sm);margin-right:var(--spacing-xs);margin-bottom:var(--spacing-xs);border-radius:var(--border-radius)}html.mobile-ui .journal-content{flex:1;padding:var(--spacing-sm);overflow-y:auto}html.mobile-ui .journal-section{background-color:var(--color-bg-lighter);border-radius:var(--border-radius);padding:var(--spacing-sm);margin-bottom:var(--spacing-sm)}.monastery-dialog{max-width:500px;width:90%;margin:auto}.modal-content{background-color:var(--color-bg-light);color:var(--color-text-primary);border:1px solid var(--color-primary);border-radius:var(--border-radius);box-shadow:0 5px 25px rgba(0,0,0,.7)}.modal-header{background-color:rgba(0,0,0,.2);border-bottom:1px solid var(--color-primary);padding:var(--spacing-sm) var(--spacing-md)}.modal-title{color:var(--color-primary);font-family:var(--font-heading);display:flex;align-items:center;gap:var(--spacing-sm)}.modal-title i{font-size:1.1em}.modal-body{padding:var(--spacing-md);background-color:rgba(0,0,0,.1)}.modal-footer{background-color:rgba(0,0,0,.2);border-top:1px solid var(--color-primary);padding:var(--spacing-sm) var(--spacing-md)}.monastery-btn{padding:var(--spacing-sm) var(--spacing-md);border-radius:var(--border-radius);font-family:var(--font-heading);font-size:.95rem;transition:all var(--transition-fast);display:flex;align-items:center;gap:var(--spacing-sm)}.monastery-btn i{font-size:1em}.monastery-btn-primary{background-color:var(--color-primary);border-color:var(--color-primary);color:#fff}.monastery-btn-primary:hover{background-color:rgb(102.2741116751,80.7817258883,43.7258883249);border-color:rgb(102.2741116751,80.7817258883,43.7258883249);transform:translateY(-2px);box-shadow:0 3px 8px rgba(0,0,0,.3)}.monastery-btn-secondary{background-color:var(--color-tertiary);border-color:var(--color-tertiary);color:#fff}.monastery-btn-secondary:hover{background-color:rgb(65.8971428571,77.9428571429,46.0571428571);border-color:rgb(65.8971428571,77.9428571429,46.0571428571);transform:translateY(-2px);box-shadow:0 3px 8px rgba(0,0,0,.3)}.monastery-btn-cancel{background-color:hsla(0,0%,100%,.1);border-color:hsla(0,0%,100%,.2);color:var(--color-text-primary)}.monastery-btn-cancel:hover{background-color:hsla(0,0%,100%,.15);border-color:hsla(0,0%,100%,.25)}.monastery-form-group{margin-bottom:var(--spacing-md)}.monastery-label{color:var(--color-primary);font-family:var(--font-heading);margin-bottom:var(--spacing-xs);display:flex;align-items:center;gap:var(--spacing-sm)}.monastery-label i{color:var(--color-primary);font-size:1.1em}.monastery-input,.monastery-select{background-color:hsla(0,0%,100%,.05);border:1px solid rgba(138,109,59,.4);color:var(--color-text-primary);border-radius:var(--border-radius);padding:var(--spacing-sm);transition:all var(--transition-fast)}.monastery-input:focus,.monastery-select:focus{background-color:hsla(0,0%,100%,.1);border-color:var(--color-primary);box-shadow:0 0 0 2px rgba(138,109,59,.2)}.monastery-help-text{margin-top:var(--spacing-xs);font-style:italic;opacity:.8}.monastery-switch .custom-control-input:checked~.custom-control-label::before{background-color:var(--color-primary);border-color:var(--color-primary)}.monastery-switch .custom-control-label{cursor:pointer}.monastery-switch .custom-control-label::before{background-color:hsla(0,0%,100%,.1);border-color:rgba(138,109,59,.4)}.input-dialog-container{display:flex;flex-direction:column;gap:var(--spacing-sm)}#load-game-modal .modal-dialog{max-width:700px;width:95%;margin:auto}@media (max-width:768px){#load-game-modal .save-list{grid-template-columns:1fr}#load-game-modal .save-item{margin-bottom:var(--spacing-sm)}#load-game-modal .save-item-thumbnail{height:80px}#load-game-modal .save-item-actions{opacity:1}#load-game-modal .modal-dialog{margin:.5rem auto}#load-game-modal .modal-body{padding:var(--spacing-sm);max-height:70vh}#load-game-modal .save-tabs{margin-bottom:var(--spacing-sm)}#load-game-modal .save-tab-btn{font-size:.9rem;padding:var(--spacing-xs) 0}#load-game-modal #btn-create-manual-save{width:100%;justify-content:center;margin-bottom:var(--spacing-sm)}#load-game-modal .modal-footer{padding:var(--spacing-xs) var(--spacing-sm);flex-wrap:wrap;justify-content:center}#load-game-modal .modal-footer .btn{margin:var(--spacing-xs);flex:1;min-width:80px}}html.desktop-ui .game-container{display:flex;flex-direction:column;height:100vh}html.desktop-ui .game-header{height:var(--header-height);min-height:var(--header-height);padding:0 var(--spacing-md)}html.desktop-ui .content-wrapper{flex:1;display:flex;flex-direction:column}html.desktop-ui .tab-navigation{height:var(--tab-height);min-height:var(--tab-height)}html.desktop-ui .tab-button{padding:0 var(--spacing-lg);height:100%;font-size:1rem}html.desktop-ui .tab-content{position:relative;aspect-ratio:16/9;overflow:hidden;flex:none}html.desktop-ui .tab-pane{position:absolute;top:0;left:0;width:100%;height:100%}html.desktop-ui .background-container,html.desktop-ui .characters-container{position:absolute;top:0;left:0;width:100%;height:100%}html.desktop-ui .dialogue-container{position:absolute;bottom:30px;left:50%;transform:translateX(-50%);width:90%;max-width:900px;height:var(--dialogue-height);border:1px solid var(--color-primary);border-radius:var(--border-radius);cursor:pointer}html.desktop-ui .dialogue-header{padding:var(--spacing-sm) var(--spacing-md)}html.desktop-ui .dialogue-content{padding:var(--spacing-md);overflow-y:auto;height:auto}html.desktop-ui .choices-container{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:70%;max-width:650px;padding:var(--spacing-sm)}html.desktop-ui #journal-tab,html.desktop-ui #memory-tab{position:absolute;top:0;left:0;width:100%;height:100%}html.desktop-ui .journal-container,html.desktop-ui .memory-container{display:flex;flex-direction:column;height:100%;width:100%;padding:0}html.desktop-ui .memory-header,html.desktop-ui .journal-nav{position:static;padding:var(--spacing-md)}html.desktop-ui .journal-nav{display:flex;gap:var(--spacing-md);flex-wrap:nowrap}html.desktop-ui .journal-nav-item{padding:var(--spacing-sm) var(--spacing-md);margin:0;font-size:1rem}html.desktop-ui .memory-detail-container,html.desktop-ui .journal-content{flex:1;padding:var(--spacing-md)}html.desktop-ui .character-left,html.desktop-ui .character-right{height:100%;width:40%;transform-origin:bottom center;transform:none}html.desktop-ui .character-left{transform-origin:bottom left}html.desktop-ui .character-right{transform-origin:bottom right}
</style></head><body><div class="game-container"><header class="game-header"><div class="header-left"><h1 class="game-title">Saint Aurelia</h1></div><div class="header-right"><span class="game-date" id="game-date">Anno Domini 1250, Martius XII</span><div class="game-controls"><button id="save-game" class="icon-button gold" title="记录典籍"><i class="fas fa-feather-alt"></i></button> <button id="load-game" class="icon-button gold" title="查看典籍"><i class="fas fa-book-open"></i></button> <button id="settings-button" class="icon-button" title="设置"><i class="fas fa-cog"></i></button></div></div></header><div class="content-wrapper"><div class="tab-navigation"><button id="tab-story" class="tab-button active" data-tab="story-tab"><i class="fas fa-book-open"></i> 正文</button> <button id="tab-journal" class="tab-button" data-tab="journal-tab"><i class="fas fa-journal-whills"></i> 日记</button> <button id="tab-memory" class="tab-button" data-tab="memory-tab"><i class="fas fa-clock-rotate-left"></i> 记忆</button></div><div class="tab-content"><div id="story-tab" class="tab-pane active"><div class="game-core"><div class="background-container" id="background-container"></div><div class="characters-container" id="characters-container"><div class="character-left" id="character-left"></div><div class="character-right" id="character-right"></div></div><div class="dialogue-container" id="dialogue-container"><div class="dialogue-header"><span class="speaker-name" id="speaker-name">Sister Cecilia</span><div class="dialogue-controls"><button id="auto-play" class="icon-button small" title="自动播放"><i class="fas fa-play"></i></button> <button id="dialogue-history" class="icon-button small" title="历史记录"><i class="fas fa-history"></i></button></div></div><div class="dialogue-content" id="dialogue-content"></div></div><div class="choices-container hidden" id="choices-container"><div class="choices-header"><h3>接下来的行动</h3><button id="hide-choices-btn" class="icon-button small" title="隐藏选项"><i class="fas fa-times"></i></button></div><div class="preset-choices" id="preset-choices"></div><div class="custom-choice"><input id="custom-choice-input" placeholder="自定义回应..."/> <button id="custom-choice-button" type="button">确定</button></div></div></div></div><div id="journal-tab" class="tab-pane"><div class="journal-container"><div class="journal-nav"><button class="journal-nav-item active" data-section="characters"><i class="fas fa-users"></i> 角色信息</button> <button class="journal-nav-item" data-section="monastery"><i class="fas fa-church"></i> 修道院状态</button> <button class="journal-nav-item" data-section="knowledge"><i class="fas fa-book"></i> 知识库</button></div><div class="journal-content"><div id="characters-section" class="journal-section active"><div class="character-cards" id="character-cards"></div><div class="character-details" id="character-details"></div></div><div id="monastery-section" class="journal-section"><div class="monastery-info" id="monastery-info"></div></div><div id="knowledge-section" class="journal-section"><div class="knowledge-categories" id="knowledge-categories"></div><div class="knowledge-entries" id="knowledge-entries"></div></div></div></div></div><div id="memory-tab" class="tab-pane"><div class="memory-container"><div class="memory-header"><h2><i class="fas fa-hourglass-half"></i> 穿越记忆点</h2><button id="save-memory" class="memory-button"><i class="fas fa-bookmark"></i> 保存此刻</button></div><div class="memory-timeline-container"><div class="memory-timeline" id="memory-timeline"></div></div><div class="memory-detail-container"><div class="memory-content" id="memory-content"></div><div class="memory-actions"><button id="travel-to-memory" class="memory-travel-button"><i class="fas fa-clock-rotate-left"></i> 穿越到此刻</button></div></div></div></div></div><div class="loading-indicator hidden" id="loading-indicator"><div class="loading-spinner"></div><div class="loading-text">加载中...</div></div><div id="notification-container"></div></div></div><div class="confirm-container hidden" id="confirm-container"><div class="modal-backdrop" id="modal-backdrop"></div><div class="confirm-dialog" id="confirm-dialog"><div class="confirm-message" id="confirm-message">确定要执行此操作吗？</div><div class="confirm-buttons"><button class="confirm-button confirm-yes" id="confirm-yes">确认</button> <button class="confirm-button confirm-no" id="confirm-no">取消</button></div></div></div></body></html>