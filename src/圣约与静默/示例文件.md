完整的HTML代码
```
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>星光少女 - 培养女团正式游戏</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
    /* Import Font */
@import url("https://fontsapi.zeoseven.com/382/main/result.css");

/* --- Base Variables --- */
:root {
   --primary-color: #FF69B4;
   --secondary-color: #FFB6C1;
   --accent-color: #FF1493;
   --bg-color: #FFF0F5;
   --text-color: #333;
   --primary-color-rgb: 255, 105, 180;
   --placeholder-image: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'; /* Tiny transparent pixel */
}

/* --- Base Layout & Fixed Height --- */
html, body {
   height: 900px; /* Keep fixed height */
   overflow: hidden; /* Prevent body scroll */
   margin: 0; padding: 0;
}
body {
   font-family: "MaokenAssortedSans", sans-serif;
   font-weight: normal;
   background-color: var(--bg-color);
   color: var(--text-color);
   display: flex;
   flex-direction: column;
   height: 100%; /* Fill fixed html height */
   user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none;
}
/* Allow Text Selection in Specific Elements */
input, textarea, .text-box, .message-text,
.chapter-modal-body .chapter-content p, #customOptionInput
{ user-select: auto; -webkit-user-select: auto; -moz-user-select: auto; -ms-user-select: auto; }

.container-fluid {
   padding: 0;
   flex: 1; /* Fill body */
   display: flex;
   flex-direction: column;
   height: 100%; /* Fill body's flex space */
   overflow: hidden; /* Prevent container scroll */
   min-height: 0; /* Prevent flex blowout */
}

/* --- Navigation Bar --- */
.nav-tabs {
   background-color: var(--primary-color);
   border: none;
   flex-shrink: 0; /* Prevent vertical compression */
   display: flex;
   flex-wrap: wrap; /* Allow wrapping by default on smaller screens */
   padding: 0.2rem 0.5rem;
   overflow: hidden; /* Hide potential overflow when wrapped */
   /* Horizontal scroll for larger screens will be handled by media query */
}

.nav-tabs .nav-link {
   color: white; border: none; padding: 0.7rem 1.2rem;
   transition: all 0.3s ease; white-space: nowrap;
   display: flex; align-items: center; gap: 0.5rem;
   border-radius: 5px;
   margin: 0.2rem;
}
.nav-tabs .nav-link:hover { background-color: var(--accent-color); color: white; }
.nav-tabs .nav-link.active { background-color: var(--secondary-color); color: var(--text-color); font-weight: bold; }

/* --- Content Area (Primary Scroll Container) --- */
.content-area {
   padding: 1.5rem;
   flex-grow: 1; /* Fill remaining vertical space */
   overflow-y: auto; /* 【关键】Allow content to scroll vertically */
   overflow-x: hidden; /* Prevent horizontal scroll */
   min-height: 0; /* Prevent flex blowout */
}

/* --- Page Switching --- */
.page {
    display: none;
    animation: fadeIn 0.5s ease;
    /* 【修改】移除 height: 100%，让页面高度由内容决定 */
    /* height: 100%; */
    overflow-x: hidden; /* Prevent horizontal overflow within page */
    /* 【新增】确保页面在 flex 容器中正确表现 */
    flex-shrink: 0; /* 通常不需要收缩 */
    width: 100%; /* 占据父容器宽度 */
}
.page.active { display: block; }
@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

/* --- General Buttons --- */
.btn-primary { background-color: var(--primary-color); border-color: var(--primary-color); }
.btn-primary:hover { background-color: var(--accent-color); border-color: var(--accent-color); }
.btn-outline-primary { color: var(--primary-color); border-color: var(--primary-color); }
.btn-outline-primary:hover { background-color: var(--primary-color); color: white; }
.btn-outline-light { color: #f8f9fa; border-color: #f8f9fa; }
.btn-outline-light:hover { color: #333; background-color: #f8f9fa; border-color: #f8f9fa; }

/* --- Story Page Layout --- */
.game-container {
           max-width: 1000px; /* 保持最大宽度限制 */
           width: 100%;
           margin-left: auto;
           margin-right: auto;
           background: white;
           border-radius: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.1);
           /* 【修改】让 flex 控制高度，并添加 gap */
           /* min-height: 500px; */ /* 可以移除或保留，flex 会处理高度 */
           display: flex; flex-direction: column;
           overflow: hidden;
           gap: 1rem; /* 【新增】在子元素之间添加 1rem 的间距 */
           /* 【新增】确保 flex 容器能计算高度，即使内容不足也撑开 */
           min-height: 600px; /* 或根据需要调整，保证基本布局 */
           padding-bottom: 1rem; /* 【新增】给底部也留点空间 */
           box-sizing: border-box; /* 确保 padding 不增加总高度 */
       }
.info-bar {
   display: flex; justify-content: space-between; align-items: center;
   padding: 0.8rem 1.5rem; background: var(--primary-color); color: white;
   min-height: 50px; flex-shrink: 0;
}
.info-bar .date-location { flex-grow: 1; display: flex; align-items: center; gap: 1rem; font-size: 0.9em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.info-bar .date-location span { white-space: nowrap; }
.info-bar > button { margin-left: 0.5rem; flex-shrink: 0; }

.vn-container {
           position: relative; width: 100%;
           /* 【修改】显著增加 VN 容器的高度比例 */
           height: 70%; /* 示例：增加到 70% */
           min-height: 400px; /* 【调整】可以适当增加最小高度 */
           background-color: #000; overflow: hidden; display: flex; flex-direction: column;
           flex-shrink: 0; /* 保持不压缩 */
       }
.scene-container { position: relative; width: 100%; flex-grow: 1; background-size: cover; background-position: center; background-repeat: no-repeat; }
.effect-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; }
.effect-overlay.horror { animation: horror 0.5s infinite; background: rgba(255, 0, 0, 0.1); }
.effect-overlay.insane { animation: insane 0.3s infinite; background: rgba(0, 255, 255, 0.1); }
.text-box-container {
           position: absolute; bottom: 0; left: 0; width: 100%;
           padding: 15px; z-index: 1000;
           /* 【调整】可以微调文本框区域的最大高度 */
           max-height: 40%; /* 示例：略微减少 */
           box-sizing: border-box;
       }
       .name-box {
           display: inline-block; /* 或者 block，取决于你想要的宽度 */
           background-color: rgba(0, 0, 0, 0.7);
           color: #fff; padding: 5px 15px; border-radius: 5px; margin-bottom: 5px; font-weight: bold;
           flex-shrink: 0; /* 不压缩 */
           width: fit-content; /* 让宽度适应内容 */
           max-width: 80%; /* 防止名字过长时撑满 */
       }
       .text-box {
           background-color: rgba(0, 0, 0, 0.7);
           color: #fff; padding: 10px 15px; /* 可以稍微调整 padding */
           border-radius: 5px; font-size: 1em; line-height: 1.6;
           width: 100%; box-sizing: border-box;
           max-height: 150px; /* 保持最大高度 */
           overflow-y: auto; /* 保持内部滚动 */
           margin-bottom: 8px; /* 调整与按钮的间距 */
           padding-right: 5px; /* Scrollbar padding */
           /* 新增 Flexbox 属性 */
           flex-grow: 1; /* 尝试填充空间，但受 max-height 限制 */
           min-height: 0; /* 允许在 flex 布局中收缩 */
       }
       .text-box.text-box-horror { background-color: rgba(139, 0, 0, 0.6); /* ... */ }
       .text-box.text-box-insane { background-color: rgba(0, 0, 139, 0.6); /* ... */ }
       .text-controls {
           display: flex; justify-content: flex-end; gap: 10px;
           margin-top: auto; /* 将按钮推到底部（相对于 text-box-container）*/
           padding-top: 5px; /* 增加一点顶部空间 */
           flex-shrink: 0; /* 不压缩 */
       }
.text-btn { background-color: rgba(0, 0, 0, 0.5); border: 1px solid #fff; color: #fff; padding: 5px 15px; cursor: pointer; transition: all 0.2s; }
.text-btn:hover { background-color: rgba(255, 255, 255, 0.2); }
.character-sprite {
           position: absolute;
           bottom: 0;
           height: 75%; /* 【调整】可以相对于新的 VN 高度再微调 */
           max-width: 38%; /* 【调整】可以相对于新的 VN 宽度再微调 */
           object-fit: contain;
           transition: all 0.3s ease;
           z-index: 2;
           filter: drop-shadow(2px 4px 6px rgba(0, 0, 0, 0.3));
       }
       .character-sprite.left {
           left: 5%; /* 示例：调整起始位置 */
           transform: translateX(-30px); opacity: 0; animation: slideInLeft 0.5s forwards;
       }
.character-sprite.right { right: 20px; transform: translateX(30px) scaleX(-1); opacity: 0; animation: slideInRight 0.5s forwards; }
@keyframes slideInLeft { to { transform: translateX(0); opacity: 1; } }
       .character-sprite.right {
            /* 注意：scaleX(-1) 会影响 transform-origin 和定位，可能需要调整 right 值 */
           right: 5%; /* 示例：调整起始位置 */
           transform: translateX(30px) scaleX(-1); opacity: 0; animation: slideInRight 0.5s forwards;
       }
        @keyframes slideInRight { to { transform: translateX(0) scaleX(-1); opacity: 1; } }
.text-normal { color: #fff; } .text-angry { color: #ff6b6b; } .text-insane { color: #00ffff; text-shadow: 0 0 5px #00ffff; } .text-whisper { color: #aaa; font-style: italic; } .text-horror { color: #ff0000; text-shadow: 0 0 5px #ff0000; } .text-shocked { color: #ffff00; } .text-sad { color: #87ceeb; } .text-despair { color: #800080; } .text-happy { color: #00ff00; } .text-excited { color: #ffd000; }
@keyframes horror { 0% { transform: translate(0, 0); } 25% { transform: translate(-2px, 2px); } 50% { transform: translate(2px, -2px); } 75% { transform: translate(-2px, -2px); } 100% { transform: translate(0, 0); } }
@keyframes insane { 0% { transform: scale(1) rotate(0deg); } 50% { transform: scale(1.02) rotate(1deg); } 100% { transform: scale(1) rotate(0deg); } }

.interaction-options {
           border-radius: 16px;
           box-shadow: 0 8px 20px rgba(0,0,0,0.1); background: rgba(255, 255, 255, 0.8);
           backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
           border: 1px solid rgba(255, 255, 255, 0.3); transition: box-shadow 0.3s ease;
           width: 100%; max-width: 100%; flex-shrink: 0;
           /* 【修改】减少最大高度占比 */
           max-height: 28%; /* 示例：减少到 28% */
           overflow: hidden;
           display: flex;
           flex-direction: column;
       }
.options-header {
    padding: 1rem 1.5rem; background: linear-gradient(135deg, var(--primary-color), #8e44ad); color: white; border-top-left-radius: 16px; border-top-right-radius: 16px; flex-shrink: 0;
}
.options-header h4 { margin: 0; font-size: 1.2rem; font-weight: 600; text-shadow: 0 1px 2px rgba(0,0,0,0.2); position: relative; }
.options-header h4:after { content: ''; position: absolute; bottom: -8px; left: 0; width: 40px; height: 3px; background: rgba(255, 255, 255, 0.7); border-radius: 3px; }

.options-list {
    padding: 1rem 1.5rem;
    overflow-y: auto; /* Internal scrolling */
    flex-grow: 1; /* Fill available space */
    padding-right: 5px; /* Scrollbar padding */
}
.btn-option {
    text-align: left; background: rgba(255, 255, 255, 0.7); border: 1px solid rgba(0,0,0,0.1); border-radius: 12px; padding: 0.8rem 1.2rem; margin-bottom: 0.8rem; transition: background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease; backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); box-shadow: 0 4px 10px rgba(0,0,0,0.05); width: 100%; box-sizing: border-box; color: var(--text-color); font-size: 0.95em;
}
.btn-option:hover:not(:disabled) { background: rgba(255, 255, 255, 0.9); border-color: var(--primary-color); transform: none; box-shadow: 0 8px 15px rgba(var(--primary-color-rgb), 0.1); }
.btn-option:disabled { opacity: 0.6; cursor: not-allowed; background: rgba(230, 230, 230, 0.7); border-color: rgba(0,0,0,0.05); box-shadow: 0 4px 10px rgba(0,0,0,0.05); }
.custom-option-input { margin-top: 1rem; padding: 0 1.5rem 1rem; flex-shrink: 0; }

/* --- Contact Page --- */
.contact-container {
    display: grid;
    grid-template-columns: 280px 1fr 300px;
    gap: 1rem;
    /* height: 100%; */ /* Removed */
    max-width: 1200px;
    margin: 0 auto;
    /* Let height be determined by content */
}
.contact-sidebar { background: white; border-radius: 15px; box-shadow: 0 0 15px rgba(0,0,0,0.1); display: flex; flex-direction: column; overflow: hidden; /* Keeps internal structure */ }
.contact-search { padding: 1rem; border-bottom: 1px solid #eee; flex-shrink: 0; }
.contact-list { overflow-y: auto; flex-grow: 1; padding-right: 5px; /* Scrollbar padding */ }
.contact-item { display: flex; align-items: center; padding: 1rem; cursor: pointer; border-bottom: 1px solid #f5f5f5; transition: all 0.3s ease; }
.contact-item:hover, .contact-item.active { background: var(--bg-color); }
.contact-avatar { position: relative; margin-right: 0.8rem; flex-shrink: 0; }
.contact-avatar img { width: 50px; height: 50px; border-radius: 25px; object-fit: cover; }
.status-badge { position: absolute; width: 12px; height: 12px; border-radius: 50%; right: 0; bottom: 0; border: 2px solid white; }
.status-badge.online { background-color: #00C851; } .status-badge.busy { background-color: #ff4444; } .status-badge.away { background-color: #ffbb33; } .status-badge.offline { background-color: #bbb; }
.contact-info { flex-grow: 1; overflow: hidden; }
.contact-name-time { display: flex; justify-content: space-between; margin-bottom: 0.3rem; }
.contact-name { font-weight: bold; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.contact-time { font-size: 0.8rem; color: #777; flex-shrink: 0; margin-left: 0.5rem; }
.contact-preview { display: flex; justify-content: space-between; align-items: center; }
.preview-text { color: #666; font-size: 0.85rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.unread-badge { background-color: var(--primary-color); color: white; font-size: 0.7rem; padding: 0.1rem 0.4rem; border-radius: 10px; min-width: 18px; text-align: center; flex-shrink: 0; margin-left: 0.5rem; }
.chat-area { background: white; border-radius: 15px; box-shadow: 0 0 15px rgba(0,0,0,0.1); display: flex; flex-direction: column; overflow: hidden; /* Keeps internal structure */ }
.chat-header { padding: 1rem; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; min-height: 70px; flex-shrink: 0; }
.chat-title { display: flex; align-items: center; flex-grow: 1; overflow: hidden; }
.chat-title img { width: 40px; height: 40px; border-radius: 20px; margin-right: 0.8rem; object-fit: cover; flex-shrink: 0; }
.chat-title h3 { margin: 0; font-size: 1.1rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.chat-actions { display: flex; align-items: center; gap: 0.5rem; flex-shrink: 0; }
.chat-messages { flex-grow: 1; overflow-y: auto; padding: 1rem; background-color: #f9f9f9; display: flex; flex-direction: column; padding-right: 5px; /* Scrollbar padding */ min-height: 200px; /* Ensure minimum space */ }
.empty-chat { text-align: center; padding: 3rem 1rem; color: #aaa; font-style: italic; }
.message-date { text-align: center; margin: 1rem 0; position: relative; }
.message-date span { background-color: rgba(0,0,0,0.1); color: #777; font-size: 0.8rem; padding: 0.3rem 1rem; border-radius: 15px; }
.message-system { text-align: center; margin: 0.5rem 0; }
.message-system span { background-color: rgba(0,0,0,0.05); color: #777; font-size: 0.8rem; padding: 0.3rem 1rem; border-radius: 15px; }
.chat-message { display: flex; margin-bottom: 1rem; max-width: 80%; }
.chat-message.received { align-self: flex-start; }
.chat-message.received.ai-typing .message-text { font-style: italic; color: #888; }
.chat-message.sent { align-self: flex-end; flex-direction: row-reverse; }
.message-avatar { width: 36px; height: 36px; border-radius: 18px; margin: 0 0.5rem; align-self: flex-end; object-fit: cover; flex-shrink: 0; }
.message-content { background: white; padding: 0.8rem; border-radius: 0.8rem; box-shadow: 0 1px 2px rgba(0,0,0,0.1); position: relative; }
.chat-message.received .message-content { border-bottom-left-radius: 0; }
.chat-message.sent .message-content { background-color: var(--primary-color); color: white; border-bottom-right-radius: 0; }
.message-text { word-break: break-word; }
.message-text img { max-width: 100%; border-radius: 0.5rem; margin-top: 0.5rem; cursor: pointer; }
.message-time { font-size: 0.7rem; color: #999; text-align: right; margin-top: 0.3rem; }
.chat-message.sent .message-time { color: rgba(255,255,255,0.8); }
.chat-input { padding: 1rem; border-top: 1px solid #eee; background-color: white; flex-shrink: 0; }
.chat-input .btn { min-width: 40px; }
.member-profile { background: white; border-radius: 15px; box-shadow: 0 0 15px rgba(0,0,0,0.1); padding: 1.5rem; overflow-y: auto; display: block; /* height: 100%; */ /* Removed */ padding-right: 5px; /* Scrollbar padding */ }
.profile-header { text-align: center; margin-bottom: 1.5rem; }
.profile-avatar { width: 100px; height: 100px; border-radius: 50%; margin-bottom: 1rem; object-fit: cover; }
.profile-tags { display: flex; flex-wrap: wrap; justify-content: center; gap: 0.5rem; margin-top: 0.8rem; }
.tag { background: var(--secondary-color); color: var(--text-color); padding: 0.2rem 0.6rem; border-radius: 12px; font-size: 0.8rem; }
.profile-stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); gap: 1rem; margin-bottom: 1rem; }
.stat-item { text-align: center; }
.stat-value { font-size: 1.2rem; font-weight: bold; color: var(--primary-color); }
.stat-label { font-size: 0.75rem; color: #666; }
.profile-info h4 { color: var(--accent-color); margin: 1rem 0 0.5rem; font-size: 0.9rem; border-bottom: 1px solid #eee; padding-bottom: 0.3rem; }
.profile-info p { font-size: 0.85rem; line-height: 1.6; color: #555; }
.empty-profile { /* height: 100%; */ /* Removed */ min-height: 300px; /* Ensure it takes some space */ display: flex; flex-direction: column; align-items: center; justify-content: center; color: #999; gap: 1rem; text-align: center; }


/* --- Team Page --- */
.team-container { max-width: 1200px; margin: 0 auto; padding: 1.5rem; }
.team-header { background-color: white; border-radius: 15px; padding: 1.5rem; box-shadow: 0 0 15px rgba(0,0,0,0.05); display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem; }
.team-info h2 { color: var(--accent-color); margin-bottom: 0.5rem; }
.team-stats { display: flex; gap: 1.5rem; flex-wrap: wrap; }
.stat { display: flex; align-items: center; color: #666; font-size: 0.9em; }
.stat i { color: var(--primary-color); margin-right: 0.5rem; }
.team-actions { display: flex; gap: 0.8rem; }
.section-title { padding: 0.8rem 0; margin: 1.5rem 0 1rem; font-size: 1.2rem; color: var(--accent-color); border-bottom: 1px solid #eee; padding-bottom: 0.5rem; display: flex; align-items: center; }
.section-title i { margin-right: 0.5rem; }
.members-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem; padding: 0; }
.member-card.horizontal { background: white; border-radius: 12px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08); overflow: hidden; transition: transform 0.2s ease, box-shadow 0.2s ease; cursor: pointer; border: 1px solid #eee; }
.member-card.horizontal:hover { transform: translateY(-4px); box-shadow: 0 8px 20px rgba(var(--primary-color-rgb), 0.15); border-color: var(--secondary-color); }
.member-card-content { display: flex; align-items: stretch; }
.member-avatar-container { flex-shrink: 0; width: 120px; position: relative; background-color: var(--bg-color); display: flex; align-items: center; justify-content: center; padding: 15px; }
.member-avatar-large { width: 90px; height: 90px; border-radius: 50%; object-fit: cover; border: 3px solid white; box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15); }
.member-role-badge {
    position: absolute;
    bottom: 10px;
    left: 5%; /* 让它从左边开始，而不是居中 */
    transform: none; /* 移除 transform */
    /* 或者，如果你仍想居中但限制宽度： */
    /* left: 50%; */
    /* transform: translateX(-50%); */
    width: 90%; /* 限制宽度为父容器的90% */
    max-width: calc(100% - 20px); /* 更精确地限制最大宽度，留出边距 */
    box-sizing: border-box; /* 确保 padding 不会增加总宽度 */

    background-color: var(--primary-color);
    color: white;
    padding: 3px 10px;
    border-radius: 12px;
    font-size: 0.75em;
    font-weight: 600;

    /* 添加文本溢出处理 */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    text-align: center; /* 文本居中显示 */
}
.member-details-container { flex-grow: 1; padding: 15px 20px; display: flex; flex-direction: column; justify-content: space-between; }
.member-header { margin-bottom: 12px; }
.member-name { font-size: 1.2em; font-weight: 700; color: var(--text-color); margin: 0 0 4px; }
.member-position { font-size: 0.85em; color: #777; margin: 0; }
.member-stats-horizontal { display: grid; gap: 8px; }
.stat-item-horizontal { display: flex; align-items: center; font-size: 0.85em; }
.stat-item-horizontal .label { flex-basis: 60px; flex-shrink: 0; color: #555; margin-right: 8px; text-align: right; white-space: nowrap; }
.stat-item-horizontal .label i { margin-right: 4px; color: var(--primary-color); width: 1em; text-align: center; }
.stat-item-horizontal .progress { flex-grow: 1; height: 8px; background-color: #eee; border-radius: 4px; overflow: hidden; margin: 0 8px; }
.stat-item-horizontal .progress-bar { background: linear-gradient(to right, var(--secondary-color), var(--primary-color)); height: 100%; border-radius: 4px; transition: width 0.4s ease; }
.stat-item-horizontal .value { flex-basis: 30px; flex-shrink: 0; font-weight: 600; color: var(--primary-color); text-align: right; }
.member-action { display: none; }
.member-card.horizontal:active { transform: scale(0.98); box-shadow: 0 2px 8px rgba(var(--primary-color-rgb), 0.2); }
.team-achievements { background-color: white; border-radius: 15px; padding: 1.5rem; margin-bottom: 2rem; box-shadow: 0 0 15px rgba(0,0,0,0.05); }
.achievements-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1.2rem; margin-top: 1.5rem; }
.achievement-card { background: linear-gradient(135deg, #fff6f9 0%, #fff 100%); border: 1px solid rgba(255, 105, 180, 0.1); box-shadow: 0 4px 15px rgba(255, 105, 180, 0.05); border-radius: 12px; padding: 1.5rem; text-align: center; transition: transform 0.3s ease, box-shadow 0.3s ease; }
.achievement-card:hover { transform: translateY(-5px); box-shadow: 0 8px 25px rgba(255, 105, 180, 0.1); }
.achievement-card.locked { opacity: 0.7; background-color: #f5f5f5; cursor: not-allowed; transform: none; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05); }
.achievement-icon { font-size: 2.5rem; margin-bottom: 0.8rem; }
.achievement-icon i { background: linear-gradient(45deg, var(--primary-color), var(--secondary-color)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-shadow: 2px 2px 4px rgba(0,0,0,0.1); }
.achievement-card h4 { margin: 0 0 0.5rem; color: var(--accent-color); font-size: 1rem; }
.achievement-card p { color: #666; margin: 0; font-size: 0.85rem; }
.achievement-card p.description { margin-top: 0.5rem; font-size: 0.9rem; color: #555; }
.team-schedule { background-color: white; border-radius: 15px; padding: 2rem 1.5rem; margin-bottom: 2rem; box-shadow: 0 6px 20px rgba(0, 0, 0, 0.06); }
.schedule-timeline { margin-top: 1.5rem; position: relative; padding-left: 85px; }
.schedule-timeline::before { content: ''; position: absolute; left: 45px; top: 10px; bottom: 30px; width: 3px; background: linear-gradient(to bottom, var(--secondary-color), var(--primary-color)); border-radius: 3px; z-index: 1; }
.timeline-item { position: relative; margin-bottom: 2.5rem; padding-left: 40px; display: flex; align-items: flex-start; }
.timeline-item:last-child { margin-bottom: 0; }
.timeline-item:last-child::after { content: ''; position: absolute; left: calc(45px - (3px / 2)); bottom: -2.5rem; width: 3px; height: 2.5rem; background: white; z-index: 1; }
.timeline-item::before { content: ''; position: absolute; left: calc(45px - 8px); top: 8px; width: 16px; height: 16px; background-color: var(--primary-color); border-radius: 50%; border: 3px solid white; box-shadow: 0 0 8px rgba(var(--primary-color-rgb), 0.4); z-index: 2; }
.timeline-item.past-event::before { background-color: #ccc; border-color: #f0f0f0; box-shadow: none; }
.timeline-date { position: absolute; left: 0; top: 5px; width: 70px; text-align: center; flex-shrink: 0; color: var(--primary-color); }
.timeline-month { display: block; font-size: 0.8em; font-weight: 500; color: var(--accent-color); margin-bottom: 3px; text-transform: uppercase; position: relative; padding-right: 8px; }
.timeline-month::after { content: '●'; position: absolute; right: 0; top: 50%; transform: translateY(-50%); font-size: 0.5em; color: var(--secondary-color); line-height: 1; }
.timeline-day { display: block; font-size: 1.8em; font-weight: 700; line-height: 1.1; letter-spacing: -1px; }
.timeline-item.past-event .timeline-date { color: #aaa; } .timeline-item.past-event .timeline-month { color: #bbb; } .timeline-item.past-event .timeline-month::after { color: #ddd; }
.timeline-content { background-color: #fff; border-radius: 10px; padding: 18px 20px; flex-grow: 1; box-shadow: 0 3px 10px rgba(0, 0, 0, 0.07); transition: transform 0.2s ease, box-shadow 0.2s ease; margin-left: 15px; border: 1px solid #eee; }
.timeline-content:hover { transform: translateY(-3px); box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1); }
.timeline-title { margin: 0 0 10px; font-size: 1.1em; color: var(--text-color); font-weight: 600; }
.timeline-location { font-size: 0.9em; color: #555; margin-bottom: 10px; display: flex; align-items: center; }
.timeline-location i { color: var(--accent-color); margin-right: 8px; font-size: 1.05em; }
.timeline-description { font-size: 0.9em; color: #666; margin: 0; line-height: 1.65; }
.timeline-item.past-event .timeline-content { background-color: #f9f9f9; box-shadow: 0 1px 5px rgba(0,0,0,0.04); border-color: #f0f0f0; opacity: 0.85; }
.timeline-item.past-event .timeline-content:hover { transform: none; box-shadow: 0 1px 5px rgba(0,0,0,0.04); }
.timeline-item.past-event .timeline-title { color: #777; } .timeline-item.past-event .timeline-location { color: #888; } .timeline-item.past-event .timeline-description { color: #999; }

/* --- Plan Page --- */
.plan-container { max-width: 1200px; margin: 0 auto; }
.plan-header { background: white; padding: 1.5rem; border-radius: 15px; margin-bottom: 1.5rem; display: flex; justify-content: space-between; align-items: center; box-shadow: 0 0 15px rgba(0,0,0,0.05); flex-wrap: wrap; gap: 1rem; }
.header-content h2 { margin: 0 0 0.5rem; color: var(--accent-color); display: flex; align-items: center; }
.header-content h2 i { margin-right: 0.5rem; }
.header-content p { margin: 0; color: #777; font-size: 0.9em; }
.plan-filters { background: white; padding: 1rem; border-radius: 15px; margin-bottom: 1.5rem; display: flex; justify-content: space-between; align-items: center; box-shadow: 0 0 15px rgba(0,0,0,0.05); flex-wrap: wrap; gap: 1rem; }
.filter-buttons { display: flex; gap: 0.5rem; flex-wrap: wrap; }
.filter-btn { background: none; border: 1px solid #ddd; padding: 0.5rem 1rem; border-radius: 20px; cursor: pointer; transition: all 0.3s ease; color: #555; font-size: 0.9em; }
.filter-btn:hover { background: #f5f5f5; border-color: #ccc; }
.filter-btn.active { background: var(--primary-color); color: white; border-color: var(--primary-color); }
.filter-search { max-width: 250px; }
.task-board { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1.5rem; }
.task-column { background: #f8f9fa; border-radius: 15px; padding: 1rem; box-shadow: 0 0 10px rgba(0,0,0,0.03); display: flex; flex-direction: column; /* Ensure flex direction */ }
.column-header { display: flex; justify-content: space-between; align-items: center; padding-bottom: 1rem; border-bottom: 1px solid #eee; margin-bottom: 1rem; flex-shrink: 0; }
.column-header h3 { margin: 0; font-size: 1.1rem; color: var(--text-color); }
.task-count { background: #e9ecef; color: #495057; padding: 0.2rem 0.5rem; border-radius: 10px; font-size: 0.8rem; font-weight: 500; }
.task-list { display: flex; flex-direction: column; gap: 1rem; min-height: 200px; flex-grow: 1; overflow-y: auto; padding: 5px; padding-right: 5px; /* Scrollbar padding */ }
.task-card { background: white; border-radius: 10px; padding: 1rem; border-left: 4px solid transparent; transition: all 0.3s ease; box-shadow: 0 2px 5px rgba(0,0,0,0.05); cursor: pointer; }
.task-card:hover { transform: translateY(-3px); box-shadow: 0 5px 10px rgba(0,0,0,0.08); }
.task-card.short-term { border-left-color: #4CAF50; } .task-card.long-term { border-left-color: #2196F3; } .task-card.personal-bond { border-left-color: #FF4081; } .task-card.completed { border-left-color: #bbb; opacity: 0.7; } .task-card.hidden-task { display: none; }
.task-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.8rem; flex-wrap: wrap; gap: 0.5rem; }
.task-tag { font-size: 0.75rem; padding: 0.2rem 0.6rem; border-radius: 5px; font-weight: 500; }
.task-tag.short-term { background: rgba(76, 175, 80, 0.1); color: #4CAF50; } .task-tag.long-term { background: rgba(33, 150, 243, 0.1); color: #2196F3; } .task-tag.personal-bond { background: rgba(255, 64, 129, 0.1); color: #FF4081; }
.task-tag.training { background: rgba(255, 152, 0, 0.1); color: #FF9800; } .task-tag.fan-service { background: rgba(156, 39, 176, 0.1); color: #9C27B0; } .task-tag.performance { background: rgba(244, 67, 54, 0.1); color: #F44336; }
.task-priority { font-size: 0.75rem; padding: 0.2rem 0.6rem; border-radius: 5px; font-weight: 500; }
.task-priority.high { background: rgba(244, 67, 54, 0.1); color: #F44336; } .task-priority.medium { background: rgba(255, 152, 0, 0.1); color: #FF9800; } .task-priority.low { background: rgba(158, 158, 158, 0.1); color: #757575; }
.task-title { font-weight: 600; margin-bottom: 0.5rem; color: #333; }
.task-description { font-size: 0.9rem; color: #666; margin-bottom: 1rem; line-height: 1.5; }
.task-footer { display: flex; justify-content: space-between; align-items: center; font-size: 0.8rem; color: #777; flex-wrap: wrap; gap: 0.5rem; margin-top: auto; padding-top: 0.5rem; border-top: 1px dashed #eee; }
.task-deadline { display: flex; align-items: center; gap: 0.3rem; } .task-deadline i { color: #6c757d; }
.task-members { display: flex; margin-left: auto; }
.member-avatar { width: 28px; height: 28px; border-radius: 50%; overflow: hidden; margin-left: -8px; border: 2px solid white; background: #eee; box-shadow: 0 0 3px rgba(0,0,0,0.1); }
.member-avatar:first-child { margin-left: 0; } .member-avatar img { width: 100%; height: 100%; object-fit: cover; }


/* --- Song Page --- */
.song-container { max-width: 1200px; margin: 0 auto; }
.song-header { background: white; padding: 1.5rem; border-radius: 15px; margin-bottom: 1.5rem; display: flex; justify-content: space-between; align-items: center; box-shadow: 0 0 15px rgba(0,0,0,0.05); flex-wrap: wrap; gap: 1rem; }
.header-content h2 { margin: 0 0 0.5rem; color: var(--accent-color); display: flex; align-items: center; }
.header-content h2 i { margin-right: 0.5rem; }
.header-content p { margin: 0; color: #777; font-size: 0.9em; }
.creation-content { background: white; border-radius: 15px; padding: 2rem; box-shadow: 0 0 15px rgba(0,0,0,0.05); }
.creation-section { background: #f9f9f9; border-radius: 10px; padding: 1.5rem; margin-bottom: 1.5rem; }
.member-selection { display: flex; gap: 0.8rem; flex-wrap: wrap; }
.member-select-item { background: white; border: 1px solid #ddd; border-radius: 10px; padding: 0.8rem; display: flex; flex-direction: column; align-items: center; min-width: 90px; cursor: pointer; transition: all 0.3s ease; text-align: center; }
.member-select-item:hover { border-color: var(--primary-color); transform: translateY(-2px); box-shadow: 0 3px 8px rgba(0,0,0,0.05); }
.member-select-item.selected { border-color: var(--primary-color); background: rgba(var(--primary-color-rgb), 0.05); box-shadow: 0 0 0 2px var(--secondary-color); }
.member-select-item img { width: 45px; height: 45px; border-radius: 50%; margin-bottom: 0.5rem; object-fit: cover; background: #eee; }
.member-name { font-size: 0.85rem; font-weight: bold; margin-bottom: 0.2rem; }
.member-skill { font-size: 0.75rem; color: #777; }
.creation-summary { margin-top: 2rem; border-top: 1px solid #eee; padding-top: 2rem; }
.budget-summary, .song-preview {
    /* height: 100%; */ /* Removed */
    display: flex;
    flex-direction: column;
    min-height: 200px; /* Example min height */
}
.budget-items, .preview-items { background: #f9f9f9; border-radius: 10px; padding: 1.2rem; flex-grow: 1; }
.budget-item, .preview-item { display: flex; justify-content: space-between; margin-bottom: 0.6rem; padding-bottom: 0.6rem; border-bottom: 1px dashed #ddd; font-size: 0.9rem; }
.budget-item:last-child, .preview-item:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
.budget-item.total { font-weight: bold; color: var(--accent-color); border-top: 2px solid var(--secondary-color); margin-top: 0.8rem; padding-top: 0.8rem; font-size: 1rem; }
.item-name, .item-label { color: #555; flex-basis: 40%; }
.item-value { font-weight: 500; text-align: right; flex-basis: 55%; }

/* --- Summary Page --- */
.summary-container { padding: 2rem; }
#storySummaryList { /* Renamed from .summary-stack */
    padding: 2rem 0;
    transition: 0.25s ease;
    border: none;
    background-color: transparent;
    max-height: 680px; /* Set max height */
    overflow-y: auto;  /* Enable vertical scroll */
    padding-right: 10px; /* Space for scrollbar */
}
.summary-entry.card {
    background-color: #fff; border: 1px solid #eee; border-radius: 8px; padding: 0;
    position: relative; margin-bottom: 1.5rem; transition: 0.15s ease; cursor: default;
    box-shadow: 0 2px 5px rgba(0,0,0,0.05); width: 95%; max-width: 550px;
    margin-left: auto; margin-right: auto; border-bottom: none;
}
/* Disable stacking pseudo-elements for scroll container */
.summary-entry.card:before, .summary-entry.card:after { display: none; }
.card-content-wrapper { padding: 1.2rem 1.5rem; }
.entry-meta { margin-bottom: 0.6rem; font-size: 0.85em; color: var(--accent-color, #FF1493); opacity: 0.8; }
.entry-id { font-weight: 600; }
.entry-content p { margin: 0; line-height: 1.7; color: #444; text-indent: 0; }
.empty-summary-message { text-align: center; color: #aaa; padding: 3rem 1rem; font-style: italic; font-size: 1.1em; }

/* --- Training Page --- */
.training-container { padding: 2rem; background: #fff; border-radius: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.1); }
.training-header { text-align: center; margin-bottom: 2rem; position: relative; }
.training-header h2 { color: var(--primary-color); font-weight: bold; margin-bottom: 1rem; }
.training-stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem; margin-bottom: 2rem; }
.stat-card { background: linear-gradient(145deg, #ffffff, #f0f0f0); padding: 1rem; border-radius: 10px; text-align: center; box-shadow: 5px 5px 15px #d9d9d9, -5px -5px 15px #ffffff; transition: transform 0.3s ease; }
.stat-card:hover { transform: translateY(-5px); }
.stat-icon { font-size: 2rem; margin-bottom: 0.5rem; color: var(--accent-color); }
.stat-value { font-size: 1.5rem; font-weight: bold; color: var(--primary-color); }
.stat-label { font-size: 0.9rem; color: #666; }
.training-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 1.5rem; margin-top: 2rem; }
.training-card { background: white; border-radius: 15px; padding: 1.5rem; box-shadow: 0 4px 6px rgba(0,0,0,0.08); transition: all 0.3s ease; position: relative; overflow: hidden; border: 1px solid #eee; }
.training-card:hover { transform: translateY(-5px); box-shadow: 0 8px 12px rgba(var(--primary-color-rgb), 0.1); }
.training-card::before { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 5px; background: linear-gradient(to right, var(--secondary-color), var(--primary-color)); }
.training-card.locked { opacity: 0.7; filter: grayscale(0.5); }
.training-card.locked::after { content: '🔒'; position: absolute; top: 1rem; right: 1rem; font-size: 1.5rem; opacity: 0.7; }
.training-card.training-in-progress { border-color: var(--accent-color); box-shadow: 0 0 15px rgba(var(--primary-color-rgb), 0.2); animation: pulse 1.5s infinite ease-in-out; }
.training-title { font-size: 1.2rem; font-weight: bold; color: var(--primary-color); margin-bottom: 0.8rem; }
.training-desc { color: #555; margin-bottom: 1rem; font-size: 0.9rem; line-height: 1.5; }
.training-stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 0.5rem; margin: 1rem 0; }
.training-stat { display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; color: #555; }
.training-stat i { color: var(--accent-color); width: 1em; text-align: center; }
.training-actions { display: flex; justify-content: space-between; align-items: center; margin-top: 1.5rem; padding-top: 1rem; border-top: 1px dashed #eee; }
.btn-train { background: var(--primary-color); color: white; border: none; padding: 0.6rem 1.5rem; border-radius: 20px; cursor: pointer; transition: all 0.3s ease; font-weight: 500; }
.btn-train:hover:not(:disabled) { background: var(--accent-color); transform: translateY(-2px); box-shadow: 0 4px 8px rgba(var(--primary-color-rgb), 0.2); }
.btn-train:disabled { background: #ccc; cursor: not-allowed; transform: none; box-shadow: none; }
.training-cost { color: #666; font-size: 0.9rem; font-weight: 500; }
.training-cost i { color: gold; margin-right: 0.3rem; }
@keyframes pulse { 0% { transform: scale(1); box-shadow: 0 0 15px rgba(var(--primary-color-rgb), 0.2); } 50% { transform: scale(1.02); box-shadow: 0 0 25px rgba(var(--primary-color-rgb), 0.3); } 100% { transform: scale(1); box-shadow: 0 0 15px rgba(var(--primary-color-rgb), 0.2); } }

/* --- Modals --- */
.chapter-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; align-items: center; z-index: 2000; backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px); padding: 15px; box-sizing: border-box; }
.chapter-modal-content { background-color: white; border-radius: 10px; width: 95%; max-width: 650px; max-height: 90%; height: auto; overflow: hidden; box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2); display: flex; flex-direction: column; }
.chapter-modal-header { display: flex; justify-content: space-between; align-items: center; padding: 12px 15px; border-bottom: 1px solid #eee; background-color: #f8f9fa; /* position: sticky; top: 0; */ /* Avoid sticky header in modal */ z-index: 1; min-height: 50px; max-height: 50px; border-top-left-radius: 10px; border-top-right-radius: 10px; flex-shrink: 0; /* Prevent shrinking */ }
.chapter-modal-header h3 { margin: 0; color: var(--accent-color); font-size: 1.1rem; }
.close-btn { background: none; border: none; font-size: 28px; cursor: pointer; color: #6c757d; padding: 0 5px; line-height: 1; }
.close-btn:hover { color: var(--accent-color); }
.chapter-modal-body { padding: 15px; overflow-y: auto; flex: 1; padding-right: 5px; /* Scrollbar padding */}
.chapter-modal-body .history-item { display: flex; padding: 0.6rem 0; border-bottom: 1px solid #f0f0f0; width: 100%; font-size: 0.9rem; }
.chapter-modal-body .history-item:last-child { border-bottom: none; }
.chapter-modal-body .history-text { flex-grow: 1; color: #444; line-height: 1.6; }
.chapter-modal-body .history-text.narrator { font-style: italic; color: #666; }
.chapter-modal-body .history-text strong { color: var(--primary-color); margin-right: 5px; }
.chapter-title { text-align: center; margin-bottom: 15px; color: var(--accent-color); border-bottom: 1px solid var(--secondary-color); padding-bottom: 10px; font-size: 1.1rem; }
.chapter-list-container { width: 100%; max-height: 250px; overflow-y: auto; padding: 10px 0; border-top: 1px solid #eee; margin-top: 15px; padding-right: 5px; /* Scrollbar padding */}
.chapter-list { list-style: none; padding: 0; margin: 10px 0 0 0; }
.chapter-item { padding: 10px 15px; margin-bottom: 5px; background-color: white; border-radius: 5px; cursor: pointer; transition: all 0.2s ease; border: 1px solid #eee; color: var(--text-color); font-size: 0.95rem; }
.chapter-item:hover { background-color: var(--secondary-color); color: white; transform: translateX(3px); border-color: var(--secondary-color); }
.chapter-item.save-item .text-muted { margin-left: 10px; font-size: 0.8em; }
body.modal-open { overflow: hidden; /* Keep this to prevent body scroll when modal is open */ }

/* --- Loading Indicator --- */
.loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; align-items: center; z-index: 9999; color: white; font-size: 1.5em; text-align: center; padding: 20px; box-sizing: border-box; backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); }
.loading-spinner { border: 4px solid rgba(255, 255, 255, 0.3); border-radius: 50%; border-top: 4px solid #FFF; width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 15px; }
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

/* --- Scrollbar Styling --- */
/* Webkit */
::-webkit-scrollbar { width: 8px; height: 8px; }
::-webkit-scrollbar-track { background: rgba(var(--primary-color-rgb), 0.1); border-radius: 10px; }
::-webkit-scrollbar-thumb { background: var(--secondary-color); border-radius: 10px; border: 1px solid rgba(255, 255, 255, 0.5); }
::-webkit-scrollbar-thumb:hover { background: var(--primary-color); }
/* Firefox */
.content-area, #storySummaryList, .contact-list, .chat-messages, .member-profile, .task-list, .options-list, .text-box, .chapter-modal-body, .chapter-list-container, .nav-tabs /* If scrollable on large screens */
{
    scrollbar-width: thin;
    scrollbar-color: var(--secondary-color) rgba(var(--primary-color-rgb), 0.1);
}

/* --- Responsive Design --- */
@media (min-width: 992px) { /* Larger screens: single-line nav */
    .nav-tabs {
         flex-wrap: nowrap;
         overflow-x: auto; /* Allow horizontal scroll for nav */
         padding-right: 10px; /* Space for potential scrollbar */
    }
}

@media (max-width: 991.98px) { /* Medium devices (tablets) */
   .nav-tabs .nav-link { padding: 0.8rem 1.2rem; font-size: 0.95em; }
   .content-area { padding: 1rem; }

   /* --- 修改：保持三栏布局在中等屏幕 --- */
   .contact-container {
       /* 恢复或保持三栏布局，可以微调宽度 */
       grid-template-columns: 240px 1fr 280px; /* 示例：调整了宽度 */
       max-width: 1200px; /* 保持最大宽度限制，或根据需要调整 */
       /* 移除 max-width: 100%; */
   }
   .member-profile {
       display: block; /* 确保成员资料栏显示 */
   }
   /* --- 结束修改 --- */

   /* 保留其他中等屏幕的调整 */
   .contact-sidebar { border-radius: 15px 0 0 15px; } /* 可能需要根据三栏布局调整 */
   .chat-area { border-radius: 0; } /* 可能需要移除圆角 */
   .member-profile { border-radius: 0 15px 15px 0; } /* 给资料栏添加圆角 */


   .members-grid { grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); }
   .achievements-grid { grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); }
   .task-board { grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); }
   .training-grid { grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); }
   .info-bar .date-location { font-size: 0.85em; gap: 0.7rem; }
   .info-bar > button { font-size: 0.8em; }
   /* Ensure summary list still scrolls */
   #storySummaryList { max-height: 600px; }
}

@media (max-width: 767.98px) { /* Small devices (landscape phones) */
    /* Nav wraps automatically */
   .nav-tabs .nav-link { padding: 0.7rem 1rem; font-size: 0.9em; }
   .contact-container {
       grid-template-columns: 1fr; /* Single column layout */
       /* 【修改】移除固定高度和内部 overflow */
       /* height: 100%; */
       /* max-height: none; */
       /* overflow-y: hidden; */
       /* Use flex for vertical layout */
       display: flex;
       flex-direction: column;
   }
   .contact-sidebar {
       /* 【修改】Use max-height for list, not fixed % */
       /* height: auto; */
       max-height: 40%; /* Example max height */
       border-radius: 15px 15px 0 0;
       flex-shrink: 0; /* Prevent shrinking */
       /* Ensure internal list still scrolls */
       display: flex; flex-direction: column;
   }
   .contact-sidebar .contact-list { flex-grow: 1; overflow-y: auto; }
   .chat-area {
       /* 【修改】Let chat area grow */
       height: auto;
       flex-grow: 1;
       border-radius: 0 0 15px 15px;
       display: flex; flex-direction: column; /* Ensure internal flex */
       min-height: 300px; /* Ensure it has some visible height */
   }
   .chat-area .chat-messages { flex-grow: 1; overflow-y: auto; min-height: 150px; } /* Ensure messages scroll */
   .member-profile { display: none; }
   .info-bar { flex-wrap: wrap; padding: 0.6rem 1rem; }
   .info-bar .date-location { flex-basis: 100%; order: 2; margin-top: 0.5rem; justify-content: center; font-size: 0.8em; }
   .info-bar > button { order: 1; margin-left: 0; }
   .vn-container { min-height: 300px; height: 55%; /* Adjust height */ }
   .interaction-options { max-height: 45%; /* Adjust options height */ }
   .text-box-container {
           position: absolute; bottom: 0; left: 0; width: 100%;
           padding: 10px 15px; /* 可以稍微减少垂直 padding */
           z-index: 1000;
           max-height: 40%; /* 保持或微调最大高度 */
           box-sizing: border-box;
           /* 新增 Flexbox 布局 */
           display: flex;
           flex-direction: column;
       }
   .text-box { max-height: 120px; padding: 10px; font-size: 0.95em; }
   .character-sprite { height: 60%; } .character-sprite.left { left: 10px; } .character-sprite.right { right: 10px; }
   .creation-content .row > * { margin-bottom: 1rem; }
   /* .budget-summary, .song-preview { height: auto; } */ /* Removed */
   .members-grid { grid-template-columns: 1fr; }
   .member-card.horizontal .member-card-content { flex-direction: column; }
   .member-card.horizontal .member-avatar-container { width: 100%; height: 150px; padding: 10px; }
   .member-card.horizontal .member-avatar-large { width: 80px; height: 80px; }
   .member-card.horizontal .member-role-badge { bottom: 5px; font-size: 0.7em; }
   .member-card.horizontal .member-details-container { padding: 15px; }
   .task-board { grid-template-columns: 1fr; }
   .training-grid { grid-template-columns: 1fr; }
   .achievements-grid { grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); }
   .chapter-modal-content { width: 95%; max-height: 95%; }
   .chapter-modal-body { padding: 15px; }
   /* Ensure summary list still scrolls */
   #storySummaryList { max-height: 550px; }
}

@media (max-width: 575.98px) { /* Extra small devices (portrait phones) */
    .content-area { padding: 0.8rem; }
    .nav-tabs .nav-link { padding: 0.6rem 0.8rem; font-size: 0.85em; }
    .info-bar .date-location span { margin-left: 0.5rem !important; }
    .info-bar > button { padding: 0.2rem 0.4rem; font-size: 0.75em;}
    /* contact-container already 1 column */
    .contact-sidebar { max-height: 35%; } /* Further reduce list height */
    .chat-area { flex-grow: 1; }

    /* --- 关键修改：调整 VN 区域和小屏幕的高度分配 --- */
    .game-container {
        gap: 0.5rem; /* 减小元素间距 */
        min-height: 500px; /* 降低最小高度要求 */
        padding-bottom: 0.5rem;
    }
    .vn-container {
        /* 显著增加 scene 的相对高度，减少 vn-container 的整体占比 */
        /* height: auto; 不再固定高度百分比，让内容决定一部分 */
        flex-grow: 1; /* 让 VN 区域尝试填充空间 */
        min-height: 280px; /* 设置一个更小的最小高度，但要足够显示内容 */
        max-height: 60vh; /* 限制最大高度为视口高度的60% */
    }
    .text-box-container {
        position: relative; /* 改为相对定位，成为 vn-container 的 flex item */
        bottom: auto; /* 移除 bottom 定位 */
        left: auto; /* 移除 left 定位 */
        max-height: none; /* 移除 max-height 百分比 */
        height: auto; /* 高度由内部元素决定 */
        padding: 8px 10px; /* 减小内边距 */
        background-color: rgba(0, 0, 0, 0.7); /* 给容器加个背景，避免透明 */
        border-top: 1px solid rgba(255,255,255,0.2); /* 可选：加个分割线 */
        flex-shrink: 0; /* 防止被过度压缩 */
        z-index: 1; /* 确保在 scene 之上，如果 scene 没内容时 */
    }
    .name-box {
        margin-bottom: 3px; /* 减小间距 */
        padding: 3px 10px;
    }
    .text-box {
        font-size: 0.85em; /* 减小字体 */
        max-height: 70px; /* 限制文本框最大高度 (约3-4行) */
        padding: 8px 10px; /* 减小内边距 */
        margin-bottom: 5px;
    }
    .text-controls {
        margin-top: 3px; /* 减小间距 */
        gap: 5px; /* 减小按钮间距 */
    }
    .text-btn {
        padding: 3px 8px; /* 减小按钮大小 */
        font-size: 0.8em;
    }
     /* 调整立绘以适应新的布局 */
     .character-sprite {
          height: 75%; /* 相对于 scene-container 的高度 */
          max-width: 45%; /* 可以适当增大宽度占比 */
          bottom: 5px; /* 稍微抬高一点，避免被 text-box-container 遮挡过多 */
     }
     .character-sprite.left { left: 0; } /* 调整位置 */
     .character-sprite.right { right: 0; } /* 调整位置 */

    .interaction-options {
        /* 选项区域现在可以稍微高一点，因为它在 VN 下方 */
        max-height: 35vh; /* 限制最大高度为视口的 35% */
        flex-shrink: 0; /* 防止被过度压缩 */
        margin-top: 0.5rem;
        margin-bottom: 0; /* 移除底部外边距 */
    }
    .options-header { padding: 0.6rem 0.8rem; } .options-header h4 { font-size: 1rem; }
    .options-list { padding: 0.6rem 0.8rem; } .btn-option { font-size: 0.85em; padding: 0.6rem 0.8rem; margin-bottom: 0.5rem; }
    .custom-option-input { margin-top: 0.5rem; padding: 0 0.8rem 0.5rem; }
    #customOptionInput { font-size: 0.85em; }


    /* 其他小屏幕调整 */
    .member-card.horizontal .member-avatar-container { height: 120px; }
    .member-card.horizontal .member-avatar-large { width: 70px; height: 70px; }
    /* Ensure summary list still scrolls */
    #storySummaryList { max-height: 500px; }
}
   </style>
</head>
<body>
    <div class="container-fluid">
        <!-- 导航栏 -->
        <ul class="nav nav-tabs" id="mainNav">
            <li class="nav-item">
                <a class="nav-link active" data-page="story"><i class="fas fa-book-open"></i> 正文</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" data-page="contact"><i class="fas fa-comments"></i> 联系人</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" data-page="team"><i class="fas fa-users"></i> 团队信息</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" data-page="training"><i class="fas fa-dumbbell"></i> 特训计划</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" data-page="plan"><i class="fas fa-tasks"></i> 未来计划</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" data-page="song"><i class="fas fa-music"></i> 打造新歌</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" data-page="summary"><i class="fas fa-list-alt"></i> 故事总结</a>
            </li>
        </ul>

        <!-- 内容区域 -->
        <div class="content-area">
            <!-- 正文页面 -->
            <div id="storyPage" class="page active">
                <div class="game-container">
                    <!-- 顶部信息栏 -->
                    <div class="info-bar">
                        <div class="date-location">
                            <span id="story-date"><i class="far fa-calendar-alt"></i></span>
                            <span class="ms-3" id="story-location"><i class="fas fa-map-marker-alt"></i></span>
                            <span class="ms-3" id="story-chapter"><i class="fas fa-book"></i></span>
                            <span class="ms-3" id="story-funds"><i class="fas fa-yen-sign"></i></span>
                        </div>
                        <!-- 【新增】故事进展按钮 -->
                        <button id="btn-show-history" class="btn btn-sm btn-outline-light ms-3" title="故事进展">
                            <i class="fas fa-history"></i> 进展
                        </button>
                    </div>

                    <!-- 视觉小说风格的故事内容区域 -->
                    <div class="vn-container">
                        <!-- 场景和立绘容器 -->
                        <div id="scene-container" class="scene-container">
                            <!-- 特效遮罩层 -->
                            <div id="effect-overlay" class="effect-overlay"></div>
                        </div>

                        <!-- 文本显示区域 -->
                        <div class="text-box-container">
                            <div id="name-box" class="name-box"></div>
                            <div id="text-box" class="text-box">
                                <div id="story-content" class="story-content"></div> <!-- 注意：此 div 的内容由 JS 控制，本身不是历史记录容器 -->
                            </div>
                            <!-- 控制按钮 -->
                            <div class="text-controls">
                                <button id="btn-auto" class="text-btn">自动</button>
                                <button id="btn-reset" class="text-btn">重看一遍</button>
                                <button id="btn-load-save" class="text-btn" style="color: #dc3545; border-color: #dc3545;">读档</button>
                                <button id="btn-delete-records" class="text-btn" style="color: #ffffff; background-color: #dc3545; border-color: #dc3545;" title="删除所有游戏数据">
                                    <i class="fas fa-trash-alt"></i> 删除记录
                                </button>
                            </div>
                        </div>
                    </div>

                     <!-- 选项区域 -->
                    <div class="interaction-options">
                        <div class="options-header">
                            <h4>你的决定是？</h4>
                        </div>
                        <div class="options-list" id="story-options">
                            <!-- 选项将通过JavaScript动态生成 -->
                        </div>
                        <!-- 自定义输入选项也移到 interaction-options 内部 -->
                        <div class="custom-option-input mt-3" id="customOptionContainer" style="display: none;">
                            <label for="customOptionInput" class="form-label small text-muted">或者，你有其他的想法：</label>
                            <div class="input-group">
                                <input type="text" class="form-control" id="customOptionInput" placeholder="例如：今晚请客吃火锅...">
                                <button class="btn btn-outline-primary" type="button" id="submitCustomOptionBtn">确定</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 联系人页面 -->
            <div id="contactPage" class="page">
                <div class="contact-container">
                    <div class="contact-sidebar">
                        <div class="contact-search">
                            <div class="input-group">
                                <input type="text" class="form-control" placeholder="搜索成员..." id="contactSearchInput">
                                <button class="btn btn-outline-secondary" type="button" id="contactSearchBtn">
                                    <i class="fas fa-search"></i>
                                </button>
                            </div>
                        </div>
                        <div class="contact-list" id="contactList">
                            <!-- 联系人列表将由JavaScript动态生成 -->
                        </div>
                    </div>

                    <div class="chat-area">
                        <div class="chat-header">
                             <!-- 调整：简化聊天头部结构 -->
                             <div class="chat-title">
                                <img src="placeholder.png" alt="Avatar" id="chat-header-avatar" style="display: none;" onerror="this.onerror=null; this.src=PLACEHOLDER_IMG;">
                                 <h3 id="chat-title-name">选择联系人</h3> <!-- 添加ID -->
                             </div>
                            <div class="chat-actions"> <!-- 将按钮放入容器 -->
                                <button class="btn btn-light btn-sm" id="characterInfoBtn" title="角色信息">
                                    <i class="fas fa-user"></i>
                                </button>
                                <button class="btn btn-danger btn-sm" id="clearChatBtn" title="清除聊天记录"> <i class="fas fa-trash"></i> </button> <!-- 移到这里 -->
                            </div>
                        </div>

                        <div class="chat-messages" id="chatMessages">
                            <!-- 聊天消息将由JavaScript动态生成 -->
                             <div class="message-system"><span>选择一个联系人开始聊天。</span></div>
                        </div>

                        <div class="chat-input">
                            <div class="input-group">
                                <!-- 【删除】表情按钮 -->
                                <input type="text" class="form-control" placeholder="输入消息..." id="messageInput" aria-label="Message Input">
                                <button class="btn btn-primary" id="sendMessageBtn" title="发送"><i class="fas fa-paper-plane"></i></button>
                                <!-- 【删除】清除按钮（已移到头部） -->
                            </div>
                        </div>
                    </div>

                    <div class="member-profile" id="memberProfile">
                        <!-- 联系人资料将由JavaScript动态生成 -->
                         <div class="empty-profile">
                             <i class="fas fa-user fa-3x"></i>
                             <p>选择一个联系人查看详细资料</p>
                         </div>
                    </div>
                </div>
            </div>

            <!-- 团队信息页面 -->
            <div id="teamPage" class="page">
                <div class="team-container">
                    <div class="team-header">
                        <div class="team-info">
                            <h2 id="team-name">星光少女团</h2>
                            <div class="team-stats" id="team-stats">
                                <!-- 团队统计将由JS填充 -->
                            </div>
                        </div>
                        <!-- 可以添加团队操作按钮 -->
                         <div class="team-actions">
                             <button class="btn btn-outline-primary btn-sm" id="dataAnalysisBtn"><i class="fas fa-chart-line"></i> 数据分析</button>
                             <button class="btn btn-outline-secondary btn-sm" id="teamSettingsBtn"><i class="fas fa-cog"></i> 团队设置</button>
                         </div>
                    </div>

                    <!-- 团队成员卡片 -->
                    <div class="section-title mt-4">
                        <i class="fas fa-users"></i> 团队成员
                    </div>
                    <div class="members-grid" id="teamMembers">
                        <!-- 成员卡片将通过JavaScript动态生成 -->
                    </div>

                    <!-- 团队成就 -->
                    <div class="team-achievements">
                        <div class="section-title">
                           <i class="fas fa-trophy"></i> 团队成就
                        </div>
                        <div class="achievements-grid" id="team-achievements">
                             <!-- 成就将由JS填充 -->
                             <div class="empty-message text-center text-muted p-3">暂无团队成就记录</div>
                        </div>
                    </div>

                    <!-- 近期行程 -->
                    <div class="team-schedule">
                        <div class="section-title">
                            <i class="fas fa-calendar"></i> 近期行程
                        </div>
                        <div class="schedule-timeline" id="team-schedule">
                            <!-- 日程将由JS填充 -->
                             <div class="empty-message text-center text-muted p-3">暂无近期行程安排</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 未来计划页面 -->
            <div id="planPage" class="page">
                <div class="plan-container">
                    <!-- 页面标题和总览 -->
                    <div class="plan-header">
                        <div class="header-content">
                            <h2><i class="fas fa-tasks"></i> 未来计划</h2>
                            <p>管理团队的短期和长期目标，确保团队发展朝着正确的方向前进。</p>
                        </div>
                        <div class="header-actions">
                            <button class="btn btn-primary" id="newTaskBtn"><i class="fas fa-plus"></i> 新建任务</button>
                        </div>
                    </div>

                    <!-- 任务看板和过滤器 -->
                    <div class="plan-filters">
                        <div class="filter-buttons">
                            <button class="filter-btn active" data-filter="all">全部任务</button>
                            <button class="filter-btn" data-filter="short-term">短期任务</button>
                            <button class="filter-btn" data-filter="long-term">长期任务</button>
                            <button class="filter-btn" data-filter="personal-bond">个人羁绊</button>
                        </div>
                        <div class="filter-search">
                            <input type="text" class="form-control" id="taskSearchInput" placeholder="搜索任务...">
                        </div>
                    </div>

                    <!-- 任务看板 -->
                    <div class="task-board" id="taskBoard">
                        <!-- 待处理任务 -->
                        <div class="task-column">
                            <div class="column-header">
                                <h3>待处理</h3>
                                <span class="task-count" data-status="todo">0</span>
                            </div>
                            <div class="task-list" data-status="todo">
                                <!-- 任务卡片将由JS填充 -->
                                <p class="text-center text-muted small p-3">暂无待处理任务</p>
                            </div>
                        </div>

                        <!-- 进行中任务 -->
                        <div class="task-column">
                            <div class="column-header">
                                <h3>进行中</h3>
                                <span class="task-count" data-status="inprogress">0</span>
                            </div>
                            <div class="task-list" data-status="inprogress">
                                 <p class="text-center text-muted small p-3">暂无进行中任务</p>
                            </div>
                        </div>

                        <!-- 已完成任务 -->
                        <div class="task-column">
                            <div class="column-header">
                                <h3>已完成</h3>
                                <span class="task-count" data-status="completed">0</span>
                            </div>
                            <div class="task-list" data-status="completed">
                                <p class="text-center text-muted small p-3">暂无已完成任务</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 打造新歌页面 -->
            <div id="songPage" class="page">
                <div class="song-container">
                    <!-- 页面标题和进度 -->
                    <div class="song-header">
                        <div class="header-content">
                            <h2><i class="fas fa-music"></i> 打造新歌</h2>
                            <p>创建一首全新的歌曲，填写所有必要信息完成制作。</p>
                        </div>
                        <div class="header-actions">
                            <button class="btn btn-primary" id="startProductionBtn"><i class="fas fa-play"></i> 开始制作</button>
                        </div>
                    </div>

                    <!-- 合并在一个页面的所有选项 -->
                    <div class="creation-content">
                        <div class="row">
                            <!-- 左侧：基本信息 -->
                            <div class="col-md-6">
                                <!-- 主题选择 -->
                                <div class="creation-section">
                                    <h3 class="section-title"><i class="fas fa-lightbulb"></i> 1. 主题和风格</h3>

                                    <div class="form-group mb-4">
                                        <label for="songTheme" class="form-label">选择主题</label>
                                        <select class="form-select" id="songTheme">
                                            <option value="">请选择主题...</option>
                                            <option value="love">爱情</option>
                                            <option value="friendship">友情</option>
                                            <option value="dreams">追梦</option>
                                            <option value="growth">成长</option>
                                            <option value="courage">勇气</option>
                                            <option value="happiness">快乐</option>
                                            <option value="nature">自然</option>
                                            <option value="youth">青春</option>
                                            <option value="hope">希望</option>
                                            <option value="custom">自定义</option>
                                        </select>
                                        <div id="customThemeContainer" style="display: none;" class="mt-2">
                                            <input type="text" class="form-control" id="customTheme" placeholder="请输入自定义主题">
                                        </div>
                                    </div>

                                    <div class="form-group mb-4">
                                        <label class="form-label">选择曲风</label>
                                        <select class="form-select" id="songStyle">
                                            <option value="">请选择曲风...</option>
                                            <option value="pop">流行 Pop</option>
                                            <option value="dance">舞曲 Dance</option>
                                            <option value="ballad">抒情 Ballad</option>
                                            <option value="rnb">R&B</option>
                                            <option value="rock">摇滚 Rock</option>
                                            <option value="electronic">电子 Electronic</option>
                                            <option value="hiphop">嘻哈 Hip-Hop</option>
                                            <option value="jazz">爵士 Jazz</option>
                                            <option value="acoustic">原声 Acoustic</option>
                                            <option value="fusion">混合 Fusion</option>
                                        </select>
                                    </div>
                                </div>

                                <!-- 选择成员 -->
                                <div class="creation-section">
                                    <h3 class="section-title"><i class="fas fa-users"></i> 2. 选择参与成员</h3>

                                    <div class="mb-3">
                                        <label class="form-label">主唱 (单选)</label>
                                        <div class="member-selection" id="mainVocalSelection">
                                             <!-- 主唱选择项将通过JavaScript动态生成 -->
                                             <p class="text-muted small">请先加载成员数据</p>
                                        </div>
                                    </div>

                                    <div class="mb-3">
                                        <label class="form-label">和声/副唱 (多选)</label>
                                        <div class="member-selection multiple" id="subVocalSelection">
                                             <!-- 和声选择项将通过JavaScript动态生成 -->
                                              <p class="text-muted small">请先加载成员数据</p>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 右侧：制作团队和其他设置 -->
                            <div class="col-md-6">
                                <!-- 制作团队 -->
                                <div class="creation-section">
                                    <h3 class="section-title"><i class="fas fa-user-tie"></i> 3. 制作团队选择</h3>
                                    <div class="mb-3">
                                        <label for="composer" class="form-label">作曲</label>
                                        <select class="form-select" id="composer">
                                            <option value="">请加载制作团队数据...</option>
                                        </select>
                                    </div>

                                    <div class="mb-3">
                                        <label for="lyricist" class="form-label">作词</label>
                                        <select class="form-select" id="lyricist">
                                           <option value="">请加载制作团队数据...</option>
                                        </select>
                                    </div>

                                    <div class="mb-3">
                                        <label for="arranger" class="form-label">编曲</label>
                                        <select class="form-select" id="arranger">
                                            <option value="">请加载制作团队数据...</option>
                                        </select>
                                    </div>
                                </div>

                                <!-- MV计划 -->
                                <div class="creation-section">
                                    <h3 class="section-title"><i class="fas fa-film"></i> 4. MV制作计划</h3>

                                    <div class="mb-3">
                                        <label for="mvDirector" class="form-label">MV导演</label>
                                        <select class="form-select" id="mvDirector">
                                            <option value="">请加载制作团队数据...</option>
                                        </select>
                                    </div>

                                    <div class="mb-3">
                                        <label for="mvConcept" class="form-label">MV概念</label>
                                        <input type="text" class="form-control" id="mvConcept" placeholder="简单描述MV的主要概念...">
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- 预算和预览 -->
                        <div class="creation-summary">
                            <div class="row g-3">
                                <div class="col-lg-7">
                                    <div class="budget-summary">
                                        <h3 class="section-title"><i class="fas fa-wallet"></i> 预算概览</h3>
                                        <div class="budget-items" id="budgetItems">
                                            <p class="text-muted small">请先选择制作团队</p>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-lg-5">
                                    <div class="song-preview">
                                        <h3 class="section-title"><i class="fas fa-check-circle"></i> 歌曲概览</h3>
                                        <div class="preview-items" id="previewItems">
                                             <p class="text-muted small">请选择歌曲风格和主唱</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 故事总结页面 -->
            <div id="summaryPage" class="page">
                <div class="summary-container container py-4">
                    <h2 class="mb-4"><i class="fas fa-list-alt me-2"></i>故事总结回顾</h2>
                    <div id="storySummaryList" class="summary-stack"> <!-- 使用新类名 -->
                        <!-- 总结列表将由 JS 动态填充 -->
                        <p class="empty-summary-message">正在加载总结...</p>
                    </div>
                </div>
            </div>

            <!-- 特训计划页面 -->
            <div id="trainingPage" class="page">
                <div class="training-container">
                    <div class="training-header">
                        <h2>特训计划</h2>
                    </div>
                    <div class="training-grid">
                        <!-- 训练卡片 -->
                        <div class="training-card">
                            <h3 class="training-title">声乐训练</h3>
                            <p class="training-desc">提高声乐技巧，增强声音表现力</p>
                            <div class="training-stats-grid">
                                <div class="training-stat">
                                    <i class="fas fa-microphone"></i>
                                    <span>影响：音域、音准</span>
                                </div>
                                <div class="training-stat">
                                     <i class="fas fa-users"></i>
                                     <span>适合：主唱、和声</span>
                                </div>
                            </div>
                            <!-- 移除旧的进度条 -->
                            <div class="training-actions">
                                <button class="btn-train" data-type="vocal" data-cost="5000">开始训练</button>
                                <div class="training-cost"><i class="fas fa-yen-sign"></i> 5000</div>
                            </div>
                        </div>
                         <div class="training-card">
                            <h3 class="training-title">舞蹈训练</h3>
                            <p class="training-desc">提高舞蹈技巧，增强舞台表现力</p>
                            <div class="training-stats-grid">
                                <div class="training-stat">
                                    <i class="fas fa-running"></i>
                                    <span>影响：协调、精准</span>
                                </div>
                                <div class="training-stat">
                                     <i class="fas fa-users"></i>
                                     <span>适合：舞担、全体</span>
                                </div>
                            </div>
                            <div class="training-actions">
                                <button class="btn-train" data-type="dance" data-cost="5000">开始训练</button>
                                <div class="training-cost"><i class="fas fa-yen-sign"></i> 5000</div>
                            </div>
                        </div>
                        <div class="training-card">
                            <h3 class="training-title">表演训练</h3>
                            <p class="training-desc">提升舞台感染力和镜头感</p>
                            <div class="training-stats-grid">
                                <div class="training-stat">
                                    <i class="fas fa-theater-masks"></i>
                                    <span>影响：表情、表现力</span>
                                </div>
                                 <div class="training-stat">
                                     <i class="fas fa-users"></i>
                                     <span>适合：全体成员</span>
                                </div>
                            </div>
                            <div class="training-actions">
                                <button class="btn-train" data-type="performance" data-cost="5000">开始训练</button>
                                <div class="training-cost"><i class="fas fa-yen-sign"></i> 5000</div>
                            </div>
                        </div>
                         <div class="training-card">
                            <h3 class="training-title">魅力训练</h3>
                            <p class="training-desc">增强个人吸引力和粉丝互动能力</p>
                            <div class="training-stats-grid">
                                <div class="training-stat">
                                    <i class="fas fa-heart"></i>
                                    <span>影响：亲和、形象</span>
                                </div>
                                <div class="training-stat">
                                     <i class="fas fa-users"></i>
                                     <span>适合：门面、全体</span>
                                </div>
                            </div>
                            <div class="training-actions">
                                <button class="btn-train" data-type="charm" data-cost="5000">开始训练</button>
                                <div class="training-cost"><i class="fas fa-yen-sign"></i> 5000</div>
                            </div>
                        </div>
                         <div class="training-card">
                            <h3 class="training-title">综艺感训练</h3>
                            <p class="training-desc">提高在综艺节目中的应变和搞笑能力</p>
                            <div class="training-stats-grid">
                                <div class="training-stat">
                                    <i class="fas fa-tv"></i>
                                    <span>影响：反应、幽默</span>
                                </div>
                                 <div class="training-stat">
                                     <i class="fas fa-users"></i>
                                     <span>适合：综艺担当、全体</span>
                                </div>
                            </div>
                            <div class="training-actions">
                                <button class="btn-train" data-type="variety" data-cost="5000">开始训练</button>
                                <div class="training-cost"><i class="fas fa-yen-sign"></i> 5000</div>
                            </div>
                        </div>
                        <!-- 可以根据需要添加更多训练类型 -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 脚本引入 -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
const PLACEHOLDER_IMG = 'https://files.catbox.moe/alqtva.png'; // Default avatar URL

        // 游戏文本模板定义（不可变）
        let gameText = `<gametext>$1</gametext>`;

        // 基础数据结构定义
        const initialGameState = {
            story: {
                date: "",
                location: "",
                scene: "",
                dialogue: [],
                options: [],
                currentChapter: "",
                currentFunds: 0
            },
            characters: { members: [] }, // 确保 characters 有 members 数组
            contacts: [],
            team: {
                basicInfo: {},
                members: [],
                achievements: [],
                schedule: []
            },
            plan: [],
            song: {
                themes: [],
                styles: [],
                members: [], // 这个可能不需要了，成员从 characters 来
                productionTeams: {
                    composers: [],
                    lyricists: [],
                    arrangers: [],
                    mvDirectors: []
                }
            },
            storySummary: []
        };

        // 游戏状态
        let gameState = structuredClone(initialGameState); // 使用深拷贝初始化

        // 文本系统配置
        const TextSystem = {
            config: {
                baseSpeed: 50,
                autoPlayDelay: 2000,
                isAutoPlaying: false,
                isTyping: false,
                stopTypingCallback: null
            },
            currentScript: [],
            currentIndex: 0,
            isProcessingChapter: false,
            // 【修改】添加历史记录上限和存储数组
            MAX_HISTORY_LENGTH: 300,
            dialogueHistory: [],

            init() {
                this.bindEvents();
                this.showCurrentText();
            },

            bindEvents() {
                const textBox = document.getElementById('text-box');
                const btnAuto = document.getElementById('btn-auto');
                // const btnSkip = document.getElementById('btn-skip'); // Skip 按钮似乎未在 HTML 中定义
                const btnReset = document.getElementById('btn-reset');

                if (textBox) {
                    textBox.addEventListener('click', () => this.handleClick());
                }
                if (btnAuto) {
                    btnAuto.addEventListener('click', () => this.toggleAutoPlay());
                }
                // if (btnSkip) {
                //     btnSkip.addEventListener('click', () => this.skipToEnd());
                // }
                if (btnReset) {
                    btnReset.addEventListener('click', () => this.resetScript());
                }

                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' || e.code === 'Enter') {
                        // 避免在输入框激活时触发
                        if (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
                            this.handleClick();
                        }
                    }
                });
            },

             // 【修改开始：TextSystem.addToHistory】
            addToHistory: function(textItem) {
                // *** 添加历史记录上限逻辑 ***
                if (this.dialogueHistory.length >= this.MAX_HISTORY_LENGTH) {
                    const itemsToRemove = this.dialogueHistory.length - this.MAX_HISTORY_LENGTH + 1;
                    this.dialogueHistory.splice(0, itemsToRemove);
                    // console.log(`历史记录已满，移除了 ${itemsToRemove} 条旧记录。`);
                }
                // *** 历史记录上限逻辑结束 ***

                // 检查是否已经存在相同的文本，防止重复添加 (逻辑保持不变)
                const isDuplicate = this.dialogueHistory.some(existingItem => {
                    if (textItem.speaker === '旁白') {
                        return existingItem.speaker === '旁白' && existingItem.content === textItem.content;
                    } else {
                        return existingItem.speaker === textItem.speaker && existingItem.content === textItem.content;
                    }
                });

                if (isDuplicate) {
                    // console.log('重复的历史记录，跳过添加:', textItem);
                    return;
                }

                // 将新的历史记录项（原始对象）添加到数组中
                this.dialogueHistory.push(textItem);
                // console.log('已添加历史记录:', textItem, '当前总数:', this.dialogueHistory.length);

                // 不再需要更新 DOM 元素
            },
             // 【修改结束：TextSystem.addToHistory】


            showCurrentText() {
                if (this.currentIndex >= this.currentScript.length) {
                    console.log("剧本结束，显示选项并处理章节...");
                    this.showOptions();
                    // 异步处理章节，不阻塞选项显示
                    this.processChapterInWorldBook().catch(err => console.error("处理章节时出错:", err));
                    return;
                }

                const currentText = this.currentScript[this.currentIndex];
                 if (!currentText || typeof currentText.speaker === 'undefined' || typeof currentText.content === 'undefined') {
                     console.error(`当前剧本索引 ${this.currentIndex} 处的文本无效:`, currentText);
                     this.currentIndex++; // 跳过无效条目
                     this.showCurrentText(); // 尝试下一条
                     return;
                 }

                const nameBox = document.getElementById('name-box');
                const storyContent = document.getElementById('story-content');
                const textBox = document.getElementById('text-box');
                const effectOverlay = document.getElementById('effect-overlay');
                const sceneContainer = document.getElementById('scene-container');

                 if (!nameBox || !storyContent || !textBox || !effectOverlay || !sceneContainer) {
                      console.error("视觉小说 UI 元素缺失！");
                      return;
                 }

                // 重置特效和立绘
                textBox.className = 'text-box';
                effectOverlay.className = 'effect-overlay';
                sceneContainer.querySelectorAll('.character-sprite').forEach(sprite => sprite.remove());

                // 设置说话者和立绘
                if (currentText.speaker === '旁白') {
                    nameBox.style.display = 'none';
                } else {
                    nameBox.style.display = 'block';
                    nameBox.textContent = currentText.speaker;
                    const character = CharacterSystem.getCharacterByName(currentText.speaker); // 使用新方法按名称查找
                    if (character && character.avatar && character.avatar.trim() !== '') {
                        const sprite = document.createElement('img');
                        sprite.onerror = () => { sprite.remove(); };
                        sprite.src = character.avatar;
                        // TODO: 决定立绘位置 (左右或中间?) - 暂时都放左边
                        sprite.className = 'character-sprite left';
                        sprite.alt = character.name;
                        sceneContainer.appendChild(sprite);
                    }
                }

                // 逐字显示
                const textContainer = document.createElement('div');
                textContainer.className = `text-${currentText.style || 'normal'}`; // 添加默认样式
                storyContent.innerHTML = '';
                storyContent.appendChild(textContainer);

                let index = 0;
                this.config.isTyping = true;
                let animationFrameId = null;

                const type = (timestamp) => {
                    if (!this.config.isTyping) { // 检查是否被中断
                        textContainer.textContent = currentText.content;
                        if (this.config.isAutoPlaying) {
                            setTimeout(() => this.nextText(), this.config.autoPlayDelay);
                        }
                        this.addToHistory(currentText); // 完成后添加到历史
                        return;
                    }

                    // 使用 requestAnimationFrame 控制打字速度，减少卡顿可能
                    // (这里简化了，实际逐字效果需要更复杂的计时逻辑，暂时保持 setTimeout)
                    if (index < currentText.content.length) {
                        textContainer.textContent += currentText.content[index];
                        index++;
                        // 使用 setTimeout 模拟打字速度
                        setTimeout(() => requestAnimationFrame(type), this.config.baseSpeed);
                    } else {
                        this.config.isTyping = false;
                        this.addToHistory(currentText); // 完成后添加到历史
                        if (this.config.isAutoPlaying) {
                            setTimeout(() => this.nextText(), this.config.autoPlayDelay);
                        }
                         // 检查是否所有文本都显示完了
                         if (this.currentIndex >= this.currentScript.length - 1) {
                              console.log("到达剧本最后一条，准备显示选项...");
                              this.showOptions(); // 显示选项
                              this.processChapterInWorldBook().catch(err => console.error("处理章节时出错:", err)); // 处理章节
                         }
                    }
                };

                requestAnimationFrame(type); // 启动打字动画
            },

            handleClick() {
                if (this.config.isTyping) {
                    console.log("打字中点击，立即完成");
                    this.config.isTyping = false; // 这会中断 type() 中的循环
                    // 确保内容完整显示 (可能需要在 type 函数的检查中更可靠地设置)
                    // 找到当前显示的文本容器并设置完整内容
                     const textContainer = document.getElementById('story-content')?.firstChild;
                     if (textContainer && this.currentIndex < this.currentScript.length) {
                         textContainer.textContent = this.currentScript[this.currentIndex].content;
                         // 确保立即添加到历史记录
                         this.addToHistory(this.currentScript[this.currentIndex]);
                     }
                     // 如果是自动播放，取消延时
                     if (this.config.isAutoPlaying) {
                          // 可能需要清除之前的 setTimeout
                     }
                } else {
                    console.log("文本显示完毕点击，进入下一条");
                    this.nextText();
                }
            },

            nextText() {
                if (this.currentIndex < this.currentScript.length - 1) {
                     this.currentIndex++;
                     this.showCurrentText();
                } else if (this.currentIndex === this.currentScript.length - 1) {
                    // 这是最后一条，显示选项但不增加 currentIndex
                     console.log("已经是最后一条，显示选项。");
                     this.currentIndex++; // 手动增加索引表示结束
                     this.showOptions();
                     this.processChapterInWorldBook().catch(err => console.error("处理章节时出错:", err));
                } else {
                    console.log("剧本已结束或索引无效");
                    // 可能需要确保选项仍然可见
                    this.showOptions();
                }
            },

            toggleAutoPlay() {
                this.config.isAutoPlaying = !this.config.isAutoPlaying;
                const btnAuto = document.getElementById('btn-auto');
                 if(btnAuto) btnAuto.textContent = this.config.isAutoPlaying ? '停止' : '自动';

                if (this.config.isAutoPlaying && !this.config.isTyping) {
                    // 如果当前文本已显示完，并且开启了自动播放，则立即进入下一条
                     if (this.currentIndex < this.currentScript.length) {
                          this.nextText();
                     } else {
                          console.log("自动播放：已在剧本末尾，不自动前进。");
                     }
                }
            },

            
            resetScript() {
                console.log("重置剧本显示...");
                this.currentIndex = 0;
                this.config.isAutoPlaying = false;
                this.config.isTyping = false;
                const btnAuto = document.getElementById('btn-auto');
                if (btnAuto) btnAuto.textContent = '自动';
                // 清空历史记录？根据需求决定是否需要清空 this.dialogueHistory
                // this.dialogueHistory = [];
                this.showCurrentText(); // 从头显示
            },

            showOptions() {
                const activePage = document.querySelector('.page.active');
                if (!activePage || activePage.id !== 'storyPage') {
                    console.log("showOptions: 不在故事页面，跳过选项显示。");
                    toggleOptionsPanel(false); // 确保选项面板隐藏
                    return;
                }

                console.log("showOptions: 在故事页面，准备显示选项。");
                const optionsContainer = document.querySelector('.interaction-options');
                const optionsList = document.getElementById('story-options');
                const customOptionContainer = document.getElementById('customOptionContainer');

                if (!optionsContainer || !optionsList || !customOptionContainer) {
                    console.error("showOptions 错误: 缺少必要的 HTML 元素 (.interaction-options, #story-options, or #customOptionContainer)");
                    return;
                }

                optionsList.innerHTML = ''; // 清空现有选项
                let optionsToDisplay = [];
                let useDefaultOptions = false;
                const defaultOptions = [
                    "带大家到练习室排练新歌",
                    "宣布明天请客吃饭",
                    "叮嘱大家注意身体"
                ];

                // 检查 gameState.story.options 是否有效且非空
                if (gameState.story && Array.isArray(gameState.story.options) && gameState.story.options.length > 0) {
                     console.log("showOptions: 使用 LLM 提供的选项:", gameState.story.options);
                     optionsToDisplay = gameState.story.options;
                     useDefaultOptions = false;
                 } else {
                      console.log("showOptions: LLM 选项无效或为空，使用默认选项。");
                      optionsToDisplay = defaultOptions;
                      useDefaultOptions = true;
                 }


                if (optionsToDisplay.length > 0) {
                    toggleOptionsPanel(true); // 显示选项容器
                    optionsToDisplay.forEach((option, index) => {
                        const button = document.createElement('button');
                        button.className = 'btn btn-option mb-2 w-100';
                        button.textContent = option;
                        // 移除旧监听器（如果存在），然后添加新监听器
                        const newButton = button.cloneNode(true);
                        newButton.addEventListener('click', () => {
                             console.log(`选项按钮点击: "${option}", 索引: ${index}, isDefault: ${useDefaultOptions}`);
                             selectStoryOption(index + 1, newButton, useDefaultOptions); // 传递按钮本身和默认标记
                        });
                        optionsList.appendChild(newButton);
                    });
                    console.log("showOptions: 选项按钮已创建。");
                     // 显示自定义输入区域
                     customOptionContainer.style.display = 'block';

                } else {
                     console.warn("showOptions: 没有可显示的选项（包括默认选项）。隐藏选项面板和自定义输入。");
                     toggleOptionsPanel(false);
                     customOptionContainer.style.display = 'none'; // 隐藏自定义输入
                }

                // 绑定自定义输入按钮 (使用事件委托或克隆节点移除旧监听器)
                 const submitBtn = document.getElementById('submitCustomOptionBtn');
                 const customInput = document.getElementById('customOptionInput');
                 if (submitBtn && customInput) {
                      const newSubmitBtn = submitBtn.cloneNode(true);
                      submitBtn.parentNode.replaceChild(newSubmitBtn, submitBtn);
                      const newCustomInput = customInput.cloneNode(true);
                      customInput.parentNode.replaceChild(newCustomInput, customInput);

                      newSubmitBtn.addEventListener('click', () => {
                           const customText = newCustomInput.value.trim();
                           if (customText) {
                                console.log("自定义选项提交:", customText);
                                selectCustomOption(customText, optionsList); // 调用处理函数
                                newCustomInput.value = '';
                           } else {
                                alert("请输入你的想法！");
                           }
                      });
                      newCustomInput.addEventListener('keypress', (e) => {
                           if (e.key === 'Enter') {
                                e.preventDefault();
                                newSubmitBtn.click();
                           }
                      });
                       console.log("showOptions: 自定义输入监听器已绑定。");
                 } else {
                     console.error("showOptions 错误: 找不到自定义输入按钮或字段。");
                     customOptionContainer.style.display = 'none'; // 找不到元素则隐藏
                 }
                 console.log("--- showOptions 函数结束 ---");
            },

             // 【修改开始：TextSystem.processChapterInWorldBook】
             processChapterInWorldBook: async function() {
                 // 防止重复执行
                 if (this.isProcessingChapter) {
                      console.log("processChapterInWorldBook: 已在处理中，跳过。");
                      return;
                 }
                  // 检查章节名是否存在
                 if (!gameState.story || !gameState.story.currentChapter || !gameState.story.currentChapter.trim()) {
                     console.log("processChapterInWorldBook: 当前章节名无效或为空，跳过处理。");
                     return;
                 }

                 this.isProcessingChapter = true;
                 console.log(`processChapterInWorldBook: 开始处理章节 "${gameState.story.currentChapter}"`);

                 try {
                     // 检查 API 函数是否存在 (增加健壮性)
                     if (typeof getLorebooks !== 'function' || typeof createLorebook !== 'function' ||
                         typeof getLorebookEntries !== 'function' || typeof createLorebookEntry !== 'function') {
                         console.warn("processChapterInWorldBook: 缺少必要的酒馆 API 函数，无法处理章节。");
                         this.isProcessingChapter = false;
                         return;
                     }

                     const worldBookName = "明星的诞生";
                     const lorebookList = await getLorebooks();
                     let bookExists = lorebookList.includes(worldBookName);

                     if (!bookExists) {
                         console.log(`创建世界书 "${worldBookName}"...`);
                         await createLorebook(worldBookName);
                         console.log(`世界书 "${worldBookName}" 已创建。`);
                         await new Promise(resolve => setTimeout(resolve, 300)); // 等待生效
                     }

                     let chapterName = gameState.story.currentChapter;
                     // 规范化章节名
                     if (!/第\d+章/.test(chapterName)) {
                         const numMatch = chapterName.match(/\d+/);
                         const num = numMatch ? numMatch[0] : '未知';
                         chapterName = `第${num}章-${chapterName.replace(/第?\d+章?-?/,'').trim()}`;
                     }
                      console.log(`规范化章节名: "${chapterName}"`);

                     // 获取条目并检查是否存在
                     const entries = await getLorebookEntries(worldBookName);
                     const existingChapter = entries.find(entry =>
                         entry.comment === chapterName ||
                         entry.comment === gameState.story.currentChapter // 也检查原始名称
                     );

                     if (!existingChapter) {
                         console.log(`章节 "${chapterName}" 不存在，准备创建...`);
                         // *** 从 dialogueHistory 收集章节内容 ***
                         let chapterContent = '';
                         if (this.dialogueHistory && this.dialogueHistory.length > 0) {
                             chapterContent = this.dialogueHistory
                                 .map(item => {
                                     if (!item || typeof item.speaker === 'undefined' || typeof item.content === 'undefined') return ''; // 跳过无效项
                                     if (item.speaker === '旁白') {
                                         return item.content;
                                     } else {
                                         return `${item.speaker}: ${item.content}`;
                                     }
                                 })
                                 .filter(line => line.trim()) // 过滤空行
                                 .join('\n');
                             console.log(`收集到 ${this.dialogueHistory.length} 条对话生成章节内容 (长度: ${chapterContent.length})`);
                         } else {
                             console.warn("无法收集章节内容，dialogueHistory 为空。");
                         }
                         // *** 内容收集结束 ***

                         if (chapterContent.trim()) { // 仅在有内容时创建
                             try {
                                 const newEntry = await createLorebookEntry(worldBookName, {
                                     comment: chapterName,
                                     content: chapterContent,
                                     key: [chapterName, "章节回顾"], // 添加通用 key
                                     enabled: false, // 默认不启用
                                     type: 'constant',
                                     position: 'before_character_definition'
                                 });
                                 console.log(`已创建章节 "${chapterName}" 条目到世界书 "${worldBookName}" (uid: ${newEntry?.uid})`);
                                 await new Promise(resolve => setTimeout(resolve, 500)); // 稍作等待
                             } catch (error) {
                                 console.error(`创建章节条目 "${chapterName}" 失败:`, error);
                             }
                         } else {
                              console.warn(`章节 "${chapterName}" 内容为空或无效，跳过创建世界书条目。`);
                         }

                     } else {
                         console.log(`章节 "${chapterName}" (uid: ${existingChapter.uid}) 已存在于世界书中，无需重复创建。`);
                         // 可选：未来可以添加更新逻辑，如果需要覆盖旧内容
                     }

                     // 不再在此处显示章节列表

                 } catch (error) {
                     console.error('处理世界书章节时发生顶层错误:', error);
                 } finally {
                     this.isProcessingChapter = false;
                      console.log("processChapterInWorldBook: 处理结束。");
                 }
             },
             // 【修改结束：TextSystem.processChapterInWorldBook】

             // 【修改开始：TextSystem.displayChapterList】
             displayChapterList: async function(worldBookName = "明星的诞生", containerElement) {
                 if (!containerElement) {
                     console.error("displayChapterList 错误：未提供有效的容器元素。");
                     return;
                 }
                  console.log(`displayChapterList: 开始为容器 ${containerElement.id || '未命名容器'} 加载章节列表...`);

                  // 清空容器，准备重新渲染
                  containerElement.innerHTML = '<p class="text-muted small">正在加载章节列表...</p>';


                 try {
                      // 检查 API
                      if (typeof getLorebooks !== 'function' || typeof getLorebookEntries !== 'function') {
                          console.warn("displayChapterList: 缺少必要的酒馆 API 函数。");
                          containerElement.innerHTML = '<p class="text-danger small">无法加载章节列表 (API缺失)。</p>';
                          return;
                      }

                     const lorebookList = await getLorebooks();
                     if (!lorebookList.includes(worldBookName)) {
                         console.log(`世界书 "${worldBookName}" 不存在，无法显示章节列表`);
                         containerElement.innerHTML = `<p class="text-muted small">世界书 "${worldBookName}" 不存在。</p>`;
                         return;
                     }

                     await new Promise(resolve => setTimeout(resolve, 300)); // 等待潜在的条目创建完成
                     const entries = await getLorebookEntries(worldBookName);
                      if (!entries) {
                          console.warn(`获取世界书 "${worldBookName}" 条目失败。`);
                          containerElement.innerHTML = `<p class="text-warning small">无法获取 "${worldBookName}" 的条目信息。</p>`;
                          return;
                      }

                     // 去重和筛选章节
                     const uniqueEntries = [];
                     const seenComments = new Set();
                     entries.forEach(entry => {
                         if (entry && entry.comment && !seenComments.has(entry.comment)) { // 增加 entry 存在性检查
                             seenComments.add(entry.comment);
                             uniqueEntries.push(entry);
                         }
                     });

                     const chapterEntries = uniqueEntries.filter(entry =>
                         entry.comment &&
                         entry.comment.includes("章") && // 核心筛选条件
                         entry.comment.trim() !== ''
                     );
                     console.log(`筛选出 ${chapterEntries.length} 个章节条目。`);

                     // 排序
                     chapterEntries.sort((a, b) => {
                         const getChapterNumber = (comment) => {
                             const match = comment.match(/第(\d+)章/);
                             // 处理无法匹配数字的情况，给一个较大的默认值
                             return match ? parseInt(match[1]) : Infinity;
                         };
                         return getChapterNumber(a.comment) - getChapterNumber(b.comment);
                     });


                      // 清空容器的加载提示
                      containerElement.innerHTML = '';

                     // 渲染列表
                     if (chapterEntries.length > 0) {
                         const chapterListContainer = document.createElement('div');
                         chapterListContainer.id = 'chapter-list-container-in-modal'; // 使用唯一ID
                         chapterListContainer.className = 'chapter-list-container mt-4';

                         const listTitle = document.createElement('h4');
                         listTitle.textContent = '章节回顾';
                         listTitle.className = 'chapter-title'; // 复用样式
                         chapterListContainer.appendChild(listTitle);

                         const chapterList = document.createElement('ul');
                         chapterList.className = 'chapter-list';

                         chapterEntries.forEach(entry => {
                              if (!entry.uid) { // 跳过没有 UID 的无效条目
                                   console.warn("发现没有 UID 的章节条目:", entry);
                                   return;
                              }
                             const chapterItem = document.createElement('li');
                             chapterItem.className = 'chapter-item';
                             chapterItem.textContent = entry.comment;
                             chapterItem.dataset.uid = entry.uid;
                             // 添加点击事件，调用 showChapterContent
                             chapterItem.addEventListener('click', () => this.showChapterContent(worldBookName, entry));
                             chapterList.appendChild(chapterItem);
                         });

                         chapterListContainer.appendChild(chapterList);
                         containerElement.appendChild(chapterListContainer);
                          console.log("章节列表渲染完成。");
                     } else {
                          const noChaptersMessage = document.createElement('p');
                          noChaptersMessage.textContent = '暂无已保存的章节回顾。';
                          noChaptersMessage.className = 'text-muted small mt-3';
                          containerElement.appendChild(noChaptersMessage);
                          console.log("没有找到章节条目。");
                     }
                 } catch (error) {
                     console.error('显示章节列表时出错:', error);
                     containerElement.innerHTML = `<p class="text-danger small">加载章节列表时出错: ${error.message}</p>`;
                 }
             },
             // 【修改结束：TextSystem.displayChapterList】

            showChapterContent: async function(lorebookName, entry) { // 保持 async
                try {
                    console.log(`显示章节内容: "${entry.comment}" (uid: ${entry.uid})`);
                     // 移除旧的章节内容模态框
                     const existingModal = document.getElementById('chapterContentModal');
                     if(existingModal) existingModal.remove();

                    const modal = document.createElement('div');
                    modal.id = 'chapterContentModal'; // 给定唯一ID
                    modal.className = 'chapter-modal'; // 复用样式
                    modal.innerHTML = `
                        <div class="chapter-modal-content">
                            <div class="chapter-modal-header">
                                <h3>${entry.comment}</h3>
                                <button class="close-btn close-content-modal">&times;</button>
                            </div>
                            <div class="chapter-modal-body">
                                <p class="text-muted small mb-3">来自世界书：${lorebookName}</p>
                                <div class="chapter-content">
                                    ${entry.content.split('\n').map(line =>
                                        line.trim() ? `<p>${line}</p>` : ''
                                    ).join('')}
                                </div>
                            </div>
                        </div>
                    `;

                    // 关闭按钮事件
                     const closeModalFunc = () => {
                          const contentModal = document.getElementById('chapterContentModal');
                          if(contentModal){
                               document.body.classList.remove('modal-open'); // 移除防止滚动类
                               contentModal.remove();
                               document.removeEventListener('keydown', handleEscKeyFunc); // 移除 ESC 监听
                               console.log("章节内容模态框已关闭。");
                          }
                     };
                    modal.querySelector('.close-content-modal').addEventListener('click', closeModalFunc);
                    // 点击背景关闭
                    modal.addEventListener('click', (e) => { if (e.target === modal) closeModalFunc(); });
                    // 阻止内容区域点击冒泡
                    modal.querySelector('.chapter-modal-content').addEventListener('click', e => e.stopPropagation());
                     // ESC 键关闭
                     const handleEscKeyFunc = (e) => { if (e.key === 'Escape') closeModalFunc(); };
                     document.addEventListener('keydown', handleEscKeyFunc);


                    document.body.classList.add('modal-open'); // 添加防止滚动类
                    document.body.appendChild(modal);
                     // 滚动到顶部
                     modal.querySelector('.chapter-modal-body').scrollTop = 0;

                } catch (error) {
                    console.error('显示章节内容时出错:', error);
                    alert(`显示章节内容时出错: ${error.message}`);
                }
            }
        };

        // 数据处理系统
        const DataSystem = {
            DataExtractor: {
                extractMainText(data) {
                     // 增加健壮性检查
                    return (data && data.story) ? data.story : null;
                },
                extractCharacters(data) {
                    // 检查 data.characters 是否存在且有 members 数组
                     if (data && data.characters) {
                          if (Array.isArray(data.characters.members)) {
                               return data.characters; // 返回包含 members 的对象
                          } else if (typeof data.characters === 'object' && !Array.isArray(data.characters)) {
                                // 如果是旧格式（直接是对象），也接受，但最好统一
                                console.warn("Character data is in direct object format, expected { members: [...] }");
                                return { members: Object.values(data.characters) }; // 尝试转换为新格式
                          }
                     }
                     return null; // 无效或缺失时返回 null
                },
                extractTeamText(data) {
                    return (data && data.team) ? data.team : null;
                },
                extractPlanText(data) {
                    // 确保返回的是数组
                     return (data && Array.isArray(data.plan)) ? data.plan : [];
                },
                extractSongText(data) {
                     return (data && data.song) ? data.song : null;
                },
                 extractContactText(data) { // 这个函数现在似乎没被直接使用，contacts 由 CharacterSystem 构建
                     console.warn("DataExtractor.extractContactText 被调用，但 contacts 现在由 CharacterSystem 构建。");
                     // 保持返回 CharacterSystem 的数据
                     return CharacterSystem.getContactsData();
                 }
            },

            UIUpdater: {
                backgroundScenes: { /* ... 保持不变 ... */
                    '夜晚居酒屋外': 'https://files.catbox.moe/no55n1.png',
                    '热闹的居酒屋': 'https://files.catbox.moe/cf55mg.png',
                    '夜晚户外': 'https://files.catbox.moe/ysxwsp.png',
                    '白日街道': 'https://files.catbox.moe/zkolss.webp',
                    '白日公园': 'https://files.catbox.moe/ot4hgl.jpg',
                    '卧室': 'https://files.catbox.moe/j6868o.jpg',
                    '排练室': 'https://pub-0f03753252fb439e966a538d805f20ef.r2.dev/docs/1745022771155.jpg',
                    '夜晚地铁': 'https://pub-0f03753252fb439e966a538d805f20ef.r2.dev/docs/1745022518757.jpg',
                    '白日地铁': 'https://pub-0f03753252fb439e966a538d805f20ef.r2.dev/docs/1745022511637.jpg',
                    '后台': 'https://pub-0f03753252fb439e966a538d805f20ef.r2.dev/docs/1745022497044.jpg',
                    '快餐店': 'https://pub-0f03753252fb439e966a538d805f20ef.r2.dev/docs/1745018316924.jpg',
                    '餐厅': 'https://pub-0f03753252fb439e966a538d805f20ef.r2.dev/docs/1745018308565.jpg',
                    '公司': 'https://pub-0f03753252fb439e966a538d805f20ef.r2.dev/docs/1745023272560.jpg',
                    '走廊': 'https://pub-0f03753252fb439e966a538d805f20ef.r2.dev/docs/1745023260798.jpg',
                    '酒吧': 'https://pub-0f03753252fb439e966a538d805f20ef.r2.dev/docs/1745018299983.jpg',
                    '超市': 'https://pub-0f03753252fb439e966a538d805f20ef.r2.dev/docs/1745022926433.jpg',
                    '便利店': 'https://pub-0f03753252fb439e966a538d805f20ef.r2.dev/docs/1745022917817.jpg',
                    '酒店': 'https://files.catbox.moe/5n8h7t.jpg',
                    '白日餐馆': 'https://files.catbox.moe/7izle2.jpg',
                    '白日海滩': 'https://files.catbox.moe/xof2f5.jpg',
                    '傍晚海滩': 'https://files.catbox.moe/ha3vp8.jpg',
                    '办公室': 'https://files.catbox.moe/ododjk.webp',
                    '{{user}}的家': 'https://files.catbox.moe/tvlorq.jpg',
                    '游乐场': 'https://files.catbox.moe/vrawrl.jpg',
                    '乡下': 'https://files.catbox.moe/ofpa2r.jpg',
                    '起居室': 'https://pub-0f03753252fb439e966a538d805f20ef.r2.dev/docs/1745039019840.jpg',
                    '天台': 'https://files.catbox.moe/oc9nzs.jpg',
                    '白日繁华的市中心': 'https://files.catbox.moe/ododjk.webp',
                    'livehouse': 'https://pub-0f03753252fb439e966a538d805f20ef.r2.dev/docs/1744643469669.jpg',
                    '大型舞台': 'https://pub-0f03753252fb439e966a538d805f20ef.r2.dev/docs/1744643572359.jpg'
                 },
                sceneKeywords: { /* ... 保持不变 ... */
                    '酒店': ['大酒店', '宾馆', '旅店', '民宿', '旅社', '旅馆'],
                    '卧室': ['房间', '寝室', '睡房', '宿舍'],
                    '白日餐馆': ['饭店', '餐厅', '食堂', '饭馆', '小吃店'],
                    '办公室': ['工作室', '写字楼', '办公区', '工作间'],
                    '走廊': ['走廊', '过道', '通道', '走道', '走廊道', '过道道', '通道道', '走道道', '走廊道道', '过道道道', '通道道道', '走道道道'],
                    '公司': ['公司', '企业', '机构', '组织', '单位', '机构', '组织', '单位', '公司', '企业', '机构', '组织', '单位', '公司', '企业', '机构', '组织', '单位'],
                    '白日地铁': ['地铁', '地下铁', '地铁站', '地下铁站', '地铁站台', '地下铁站台'],
                    '后台': ['后台', '后台区域', '休息室', '后台化妆间', '后台准备室', '后台休息室', '化妆间', '准备室', '休息室'],
                    '超市': ['超市', '商场', '购物中心', '百货商店', '大卖场'],
                    '快餐店': ['快餐店', '快餐餐厅', '快餐连锁店', '快餐小吃店'],
                    '餐厅': ['餐厅', '饭店', '餐馆', '饭馆', '食堂'],
                    '酒吧': ['酒吧', '小酒馆', '酒肆', '酒馆'],
                    '起居室': ['起居室', '客厅', '会客厅', '起居间', '起居区域'],
                    '便利店': ['便利店', '小卖部', '杂货店', '小商店'],
                    '排练室': ['排练室', '练习室', '训练室', '排练房'],
                    '白日街道': ['马路', '大街', '街上', '街头', '人行道', '公共区域'],
                    '白日公园': ['花园', '绿地', '游园', '草坪', '公园', '公园绿地', '公园草坪', '公园花园'],
                    '游乐场': ['游乐园', '主题公园', '乐园', '游园会'],
                    '居酒屋': ['酒吧', '小酒馆', '酒肆', '酒馆'],
                    '乡下': ['农村', '田野', '农场', '乡村', '山庄'],
                    '白日海滩': ['海边', '沙滩', '海岸', '沙岸'],
                    'livehouse': ['演出场地', '小型音乐会场', '现场演出'],
                    '大型舞台': ['演唱会', '演出会场', '表演舞台', '音乐厅', '剧场', '体育馆', '录制现场', '舞台', '表演场地', '表演现场', '表演舞台', '表演会场', '表演音乐厅', '表演剧场', '表演体育馆', '表演录制现场', '节目现场', '会场', '音乐厅', '剧场', '体育馆', '表演录制现场']
                },

                processSceneBackground(sceneDescription) {
                     if (!sceneDescription) return null;
                     const desc = sceneDescription.trim(); // 去除空格
                     if (this.backgroundScenes[desc]) return this.backgroundScenes[desc];
                     for (const [key, url] of Object.entries(this.backgroundScenes)) {
                         if (desc.includes(key)) return url;
                     }
                     for (const [scene, keywords] of Object.entries(this.sceneKeywords)) {
                          if (keywords.some(keyword => desc.includes(keyword))) {
                              return this.backgroundScenes[scene];
                          }
                     }
                      console.warn(`未找到匹配的背景图: "${desc}"`);
                     // 如果完全没有匹配，可以返回一个默认背景或 null
                     // return 'default-background.jpg';
                     return null; // 或者返回 null 让背景透明/黑色
                },

                updateMainText(mainTextData) {
                    if (!mainTextData) {
                        console.warn("updateMainText: 收到无效数据");
                        return;
                    }
                     // 更新 DOM，增加元素存在性检查
                     const storyDateEl = document.getElementById('story-date');
                     if (storyDateEl) storyDateEl.innerHTML = `<i class="far fa-calendar-alt"></i> ${mainTextData.date || '未知日期'}`;

                     const storyLocationEl = document.getElementById('story-location');
                     if (storyLocationEl) storyLocationEl.innerHTML = `<i class="fas fa-map-marker-alt"></i> ${mainTextData.location || '未知地点'}`;

                     const storyChapterEl = document.getElementById('story-chapter');
                     if (storyChapterEl) storyChapterEl.innerHTML = `<i class="fas fa-book"></i> ${mainTextData.currentChapter || '未命名章节'}`;

                     const storyFundsEl = document.getElementById('story-funds');
                     if (storyFundsEl) storyFundsEl.innerHTML = `<i class="fas fa-yen-sign"></i> ${mainTextData.currentFunds !== undefined ? formatCurrency(mainTextData.currentFunds) : '???'}`;

                    const sceneContainer = document.getElementById('scene-container');
                    if (sceneContainer) {
                         if (mainTextData.scene) {
                              const backgroundUrl = this.processSceneBackground(mainTextData.scene);
                              sceneContainer.style.backgroundImage = backgroundUrl ? `url('${backgroundUrl}')` : 'none';
                         } else {
                              sceneContainer.style.backgroundImage = 'none'; // 清除背景
                         }
                    }
                    // 更新特训页面的资金显示（如果该页面存在）
                    const trainingFundsStatEl = document.getElementById('training-funds-stat');
                    if (trainingFundsStatEl) {
                        trainingFundsStatEl.textContent = mainTextData.currentFunds !== undefined ? formatCurrency(mainTextData.currentFunds) : '???';
                    }
                },

                updateContactText() {
                    const contactList = document.getElementById('contactList');
                    if (!contactList) {
                        console.error("错误：找不到联系人列表元素 #contactList");
                        return;
                    }
                    // 直接使用 gameState.contacts，它应该已经被 CharacterSystem 更新
                    const contactsToRender = gameState.contacts || [];
                    console.log(`渲染联系人列表，共 ${contactsToRender.length} 人`);

                    contactList.innerHTML = contactsToRender.map(contact => {
                        if (!contact || !contact.name) {
                            console.warn("渲染联系人列表时遇到无效的联系人数据:", contact);
                            return '';
                        }
                         // 确保 avatar 是有效的 URL 或 PLACEHOLDER_IMG
                         const avatarSrc = (contact.avatar && typeof contact.avatar === 'string' && contact.avatar.trim() !== '') ? contact.avatar : PLACEHOLDER_IMG; // 使用常量
                         const isActive = contact.name === currentContact ? 'active' : '';
                         const unreadBadgeHtml = contact.unread > 0 ? `<span class="unread-badge">${contact.unread}</span>` : '';
                         const statusClass = contact.status === 'online' ? 'online' : (contact.status === 'busy' ? 'busy' : (contact.status === 'away' ? 'away' : 'offline'));

                        return `
                        <div class="contact-item ${isActive}" data-contact="${contact.name}" data-id="${contact.id || ''}">
                            <div class="contact-avatar">
                               <img src="${avatarSrc}" alt="${contact.name}" onerror="this.onerror=null; this.src=PLACEHOLDER_IMG;">
                                <span class="status-badge ${statusClass}"></span>
                            </div>
                            <div class="contact-info">
                                <div class="contact-name-time">
                                    <span class="contact-name">${contact.name}</span>
                                    <span class="contact-time">${contact.lastTime || ''}</span>
                                </div>
                                <div class="contact-preview">
                                    <span class="preview-text">${contact.lastMessage || '...'}</span>
                                    ${unreadBadgeHtml}
                                </div>
                            </div>
                        </div>
                        `;
                    }).join('');

                    // 重新绑定点击事件
                    contactList.querySelectorAll('.contact-item').forEach(item => {
                         // 使用克隆节点技巧移除旧监听器，避免重复绑定
                         const newItem = item.cloneNode(true);
                         item.parentNode.replaceChild(newItem, item);
                         newItem.addEventListener('click', () => {
                              const contactName = newItem.getAttribute('data-contact');
                              if (contactName) {
                                   switchContact(contactName);
                              }
                         });
                    });
                },

                updateTeamText(teamData) {
                    if (!teamData) {
                         console.warn("updateTeamText: 收到无效数据");
                         return;
                    }
                    console.log("更新团队信息 UI...");

                    // 更新基本信息
                    const teamInfo = document.getElementById('team-name');
                    if (teamInfo) teamInfo.textContent = teamData.name || '星光少女团';

                    const teamStats = document.getElementById('team-stats');
                    if (teamStats) {
                        const basicInfo = teamData.basicInfo || {};
                        teamStats.innerHTML = `
                            <div class="stat">
                                <i class="fas fa-heart"></i>
                                <span>粉丝数：${basicInfo.fans || '0'}</span>
                            </div>
                            <div class="stat">
                                <i class="fas fa-music"></i>
                                <span>原创曲目：${basicInfo.songs || '0'}首</span>
                            </div>
                            <div class="stat">
                                <i class="fas fa-trophy"></i>
                                <span>演出场次：${basicInfo.performances || '0'}场</span>
                            </div>
                        `;
                        // 更新特训页面的粉丝统计
                         const trainingFansStatEl = document.getElementById('training-fans-stat');
                         if(trainingFansStatEl) trainingFansStatEl.textContent = basicInfo.fans || '0';
                         // 可以添加团队人气的更新，如果 basicInfo 中有的话
                         const trainingPopStatEl = document.getElementById('training-popularity-stat');
                          if(trainingPopStatEl) trainingPopStatEl.textContent = basicInfo.popularity || '0'; // 假设有 popularity 字段
                    }

                    // 更新成员信息 (使用 CharacterSystem 的数据更可靠)
                    const membersGrid = document.getElementById('teamMembers');
                    if (membersGrid) {
                         const teamMembersData = CharacterSystem.getTeamMembersData(); // 从 CharacterSystem 获取最新数据
                         console.log(`渲染团队成员列表，共 ${teamMembersData.length} 人`);
                         if (teamMembersData.length > 0) {
                              membersGrid.innerHTML = teamMembersData.map(member => {
                                   const skills = member.stats || {}; // 确保 skills 是对象
                                   const getSkillValue = (key) => skills[key] !== undefined && skills[key] !== null ? skills[key] : 0;
                                    // 确保 avatar 是有效的 URL 或 PLACEHOLDER_IMG
                                    const avatarSrc = (member.avatar && typeof member.avatar === 'string' && member.avatar.trim() !== '') ? member.avatar : PLACEHOLDER_IMG; // 使用常量

                                   return `
                                   <div class="member-card horizontal" data-member-id="${member.id || member.name}" onclick="handleMemberCardClick('${member.id || member.name}')"> <!-- 添加 onclick -->
                                       <div class="member-card-content">
                                           <div class="member-avatar-container">
                                               <img src="${avatarSrc}" alt="${member.name}" class="member-avatar-large" onerror="this.onerror=null; this.src=PLACEHOLDER_IMG;">
                                               <span class="member-role-badge">${member.role || '成员'}</span>
                                           </div>
                                           <div class="member-details-container">
                                               <div class="member-header">
                                                   <h4 class="member-name">${member.name}</h4>
                                                   ${member.position ? `<p class="member-position">${member.position}</p>` : ''}
                                               </div>
                                               <div class="member-stats-horizontal">
                                                   <div class="stat-item-horizontal">
                                                       <span class="label"><i class="fas fa-microphone-alt"></i> 声乐</span>
                                                       <div class="progress"><div class="progress-bar" style="width: ${getSkillValue('vocal')}%"></div></div>
                                                       <span class="value">${getSkillValue('vocal')}</span>
                                                   </div>
                                                   <div class="stat-item-horizontal">
                                                       <span class="label"><i class="fas fa-running"></i> 舞蹈</span>
                                                       <div class="progress"><div class="progress-bar" style="width: ${getSkillValue('dance')}%"></div></div>
                                                       <span class="value">${getSkillValue('dance')}</span>
                                                   </div>
                                                   <div class="stat-item-horizontal">
                                                        <span class="label"><i class="fas fa-theater-masks"></i> 表演</span>
                                                        <div class="progress"><div class="progress-bar" style="width: ${getSkillValue('performance')}%"></div></div>
                                                        <span class="value">${getSkillValue('performance')}</span>
                                                    </div>
                                                    <div class="stat-item-horizontal">
                                                        <span class="label"><i class="fas fa-heart"></i> 魅力</span>
                                                        <div class="progress"><div class="progress-bar" style="width: ${getSkillValue('charm')}%"></div></div>
                                                        <span class="value">${getSkillValue('charm')}</span>
                                                    </div>
                                                    <div class="stat-item-horizontal">
                                                        <span class="label"><i class="fas fa-tv"></i> 综艺</span>
                                                        <div class="progress"><div class="progress-bar" style="width: ${getSkillValue('variety')}%"></div></div>
                                                        <span class="value">${getSkillValue('variety')}</span>
                                                    </div>
                                               </div>
                                           </div>
                                       </div>
                                   </div>
                                   `;
                              }).join('');
                         } else {
                              membersGrid.innerHTML = '<p class="text-center text-muted p-3">团队中还没有成员。</p>';
                         }
                    }

                     // 更新成就信息
                     const achievementsGrid = document.getElementById('team-achievements');
                     if (achievementsGrid) { // 检查 teamData.achievements 是否为数组
                          if (teamData.achievements && Array.isArray(teamData.achievements) && teamData.achievements.length > 0) {
                               achievementsGrid.innerHTML = teamData.achievements.map(achievement => {
                                    if (!achievement || !achievement.title) return ''; // 跳过无效成就
                                    return `
                                    <div class="achievement-card">
                                        <div class="achievement-icon">
                                            <i class="fas ${achievement.icon || 'fa-trophy'}"></i>
                                        </div>
                                        <div class="achievement-info">
                                            <h4>${achievement.title}</h4>
                                            <p>${achievement.date || '未知日期'}</p>
                                            <p class="description">${achievement.description || ''}</p>
                                        </div>
                                    </div>
                                    `;
                               }).join('');
                          } else {
                               achievementsGrid.innerHTML = '<div class="empty-message text-center text-muted p-3">暂无团队成就记录</div>';
                          }
                     }


                    // 更新日程信息
                    const scheduleTimeline = document.getElementById('team-schedule');
                     if (scheduleTimeline) { // 检查 teamData.schedule 是否为数组
                          if (teamData.schedule && Array.isArray(teamData.schedule) && teamData.schedule.length > 0) {
                               scheduleTimeline.style.position = 'relative'; // 确保有相对定位
                               scheduleTimeline.innerHTML = teamData.schedule.map(item => {
                                    if (!item || !item.title) return ''; // 跳过无效日程
                                    return `
                                    <div class="timeline-item ${item.isPast ? 'past-event' : ''}">
                                        <div class="timeline-date">
                                            <span class="timeline-month">${item.month || '??'}</span>
                                            <span class="timeline-day">${item.day || '??'}</span>
                                        </div>
                                        <div class="timeline-content">
                                            <h5 class="timeline-title">${item.title}</h5>
                                            <div class="timeline-location"><i class="fas fa-map-marker-alt"></i> ${item.location || '未知地点'}</div>
                                            <p class="timeline-description">${item.description || ''}</p>
                                        </div>
                                    </div>
                                    `;
                               }).join('');
                          } else {
                               scheduleTimeline.innerHTML = '<div class="empty-message text-center text-muted p-3">暂无近期行程安排</div>';
                          }
                     }
                      console.log("团队信息 UI 更新完成。");
                },

                 // 更新计划信息 (现在由 renderTaskList 处理，这个可以简化或移除)
                 updatePlanText(planData) {
                      if (!planData) {
                           console.warn("updatePlanText: 收到无效数据");
                           return; // 直接返回
                      }
                       console.log("updatePlanText: 调用 renderTaskList 渲染计划...");
                       renderTaskList(); // 调用渲染函数
                 },

                updateSongText(songData) {
                     if (!songData) {
                          console.warn("updateSongText: 收到无效数据");
                          return; // 直接返回
                     }
                      console.log("updateSongText: 调用 renderSongOptions 和 updateSongSummary...");
                     renderSongOptions(); // 调用渲染函数
                     updateSongSummary(); // 更新摘要
                }
            },

             // 【删除】不再需要 handleExternalData，直接使用 updateGameState
            // handleExternalData(data) { ... }

            init() {
                 // 【删除】移除 DOM 观察器逻辑
                // this.setupDOMObserver();

                // 绑定事件监听器
                this.bindEvents();
                // 发送就绪事件
                this.dispatchReadyEvent();
                 console.log("DataSystem 初始化完成 (无 DOM 观察器)。");
            },

            // 【删除】移除 setupDOMObserver
            // setupDOMObserver() { ... }

            bindEvents() {
                // 监听窗口大小变化 (可选，如果需要响应式调整)
                // window.addEventListener('resize', () => {
                //     this.handleResize();
                // });
                 // 不需要监听页面切换了，由全局 switchPage 处理
            },

             // 【删除】移除 handlePageChange
             // handlePageChange(page) { ... }

            // 【删除】移除 handleResize 和 updateLayout (如果不需要响应式)
            // handleResize() { ... }
            // updateLayout() { ... }

            dispatchReadyEvent() {
                const readyEvent = new CustomEvent('gameSystemReady');
                window.dispatchEvent(readyEvent);
                 console.log("gameSystemReady 事件已分发。");
            },
        };
/**
 * 更新指定角色在世界书 "明星的诞生" 中的条目内容。
 * 会查找备注为 "成员[角色名]的详细信息" 的条目，
 * 并更新或添加 声乐、舞蹈、表演、魅力、综艺感、当前心情、当下好感度 的数值。
 * @param {string} characterName 要更新的角色名字
 * @param {object} characterData 包含最新角色数据的对象 (应包含 stats, mood, affection)
 */
 async function updateCharacterLorebookEntry(characterName, characterData) {
    if (!characterName || !characterData) {
        console.warn("updateCharacterLorebookEntry: 缺少角色名或角色数据，跳过更新。");
        return;
    }

    console.log(`尝试更新角色 "${characterName}" 的世界书条目...`);
    const worldBookName = "明星的诞生";
    // 标准化条目备注，移除空格并转小写以便匹配
    const targetCommentBase = `成员${characterName}的详细信息`;
    const targetCommentNormalized = targetCommentBase.replace(/\s+/g, '').toLowerCase();

    try {
        // 检查必要的 API 函数
        if (typeof getLorebookEntries !== 'function' || typeof setLorebookEntries !== 'function') {
            console.warn(`世界书 API 函数 (get/set) 不可用，无法更新角色 "${characterName}" 的条目。`);
            return;
        }

        // 获取所有条目
        const allEntries = await getLorebookEntries(worldBookName);
        if (!allEntries) {
            console.warn(`无法获取世界书 "${worldBookName}" 的条目列表，无法更新角色 "${characterName}"。`);
            return;
        }

        // 查找对应的条目
        const entryToUpdate = allEntries.find(entry =>
            entry && entry.comment && entry.uid != null &&
            entry.comment.replace(/\s+/g, '').toLowerCase() === targetCommentNormalized
        );

        if (!entryToUpdate) {
            console.warn(`在世界书 "${worldBookName}" 中未找到角色 "${characterName}" 的详细信息条目 (预期备注: "${targetCommentBase}")。`);
            return;
        }

        console.log(`找到角色 "${characterName}" 的条目 (UID: ${entryToUpdate.uid})，准备更新内容。`);

        let currentContent = entryToUpdate.content || "";
        let newContent = currentContent;
        let changed = false;

        // 定义要更新的字段及其在世界书中的标签
        const fieldsToUpdate = {
            '声乐': characterData.stats?.vocal,
            '舞蹈': characterData.stats?.dance,
            '表演': characterData.stats?.performance,
            '魅力': characterData.stats?.charm,
            '综艺感': characterData.stats?.variety,
            '当前心情': characterData.mood,
            '当下好感度': characterData.affection
        };

        // 遍历字段进行更新或添加
        for (const [label, value] of Object.entries(fieldsToUpdate)) {
            if (value === undefined || value === null) {
                // console.log(`  - 角色 "${characterName}" 数据中缺少字段 "${label}"，跳过此字段更新。`);
                continue; // 如果新数据中没有这个值，则不更新
            }

            const numericValue = parseInt(value); // 确保是数字
            if (isNaN(numericValue)) {
                console.warn(`  - 角色 "${characterName}" 的字段 "${label}" 值 "${value}" 不是有效数字，跳过。`);
                continue;
            }

            // 正则表达式匹配行：以 "- " 开头，标签名，中文或英文冒号，可选空格，数字
            // \s* 匹配0或多个空格，[：:] 匹配中文或英文冒号
            const regex = new RegExp(`^- ${label}\\s*[：:]\\s*\\d+`, 'm');
            const newLine = `- ${label}： ${numericValue}`; // 注意使用中文冒号保持一致

            if (regex.test(newContent)) {
                // 如果找到匹配行，替换整行
                const oldLineMatch = newContent.match(regex);
                if (oldLineMatch && oldLineMatch[0] !== newLine) { // 只有在值不同时才替换
                    console.log(`  - 更新 "${characterName}" 的 "${label}" 从 "${oldLineMatch[0]}" 为 "${newLine}"`);
                    newContent = newContent.replace(regex, newLine);
                    changed = true;
                }
            } else {
                // 如果找不到匹配行，在末尾添加新行
                console.log(`  - 为 "${characterName}" 添加新字段 "${label}": ${numericValue}`);
                // 确保添加前有换行符（如果内容非空）
                if (newContent.trim() !== '' && !newContent.endsWith('\n')) {
                   newContent += '\n';
                }
                newContent += newLine + '\n'; // 添加新行并加一个换行符
                changed = true;
            }
        }

        // 如果内容有变化，则调用 API 更新
        if (changed) {
            console.log(`内容已更改，调用 setLorebookEntries 更新角色 "${characterName}" (UID: ${entryToUpdate.uid})...`);
            // setLorebookEntries 通常需要一个数组
            await setLorebookEntries(worldBookName, [{
                uid: entryToUpdate.uid,
                content: newContent.trim() // 去除末尾可能多余的换行符
                // 可以选择性地更新其他字段，如 'enabled', 'key' 等，如果需要的话
                // key: entryToUpdate.key,
                // enabled: entryToUpdate.enabled,
                // comment: entryToUpdate.comment // 保持备注不变
            }]);
            console.log(`角色 "${characterName}" 的世界书条目更新成功。`);
        } else {
            console.log(`角色 "${characterName}" 的世界书条目内容无需更新。`);
        }

    } catch (error) {
        console.error(`更新角色 "${characterName}" 的世界书条目时出错:`, error);
    }
}
        // --- 角色管理系统 ---
        const CharacterSystem = {
            characters: {}, // 存储角色数据 { id: characterObject }

            init(membersData) {
                 if (!membersData || !Array.isArray(membersData)) {
                      console.warn("CharacterSystem.init: 收到无效的成员数据，应为数组。");
                      this.characters = {}; // 清空或保持旧数据？清空更安全
                      return;
                 }
                 console.log(`CharacterSystem.init: 初始化/更新 ${membersData.length} 个成员...`);
                  // 保留本地存储的头像信息
                  const currentAvatars = {};
                  Object.values(this.characters).forEach(char => {
                      if (char.avatar && char.avatar.startsWith('data:image')) {
                          currentAvatars[char.id] = char.avatar;
                      }
                  });

                  this.characters = membersData.reduce((acc, char) => {
                     if (char && char.id != null) { // 确保有 ID
                          // 合并状态：优先本地存储，其次是传入数据，最后是默认
                           const existingAvatar = currentAvatars[char.id]; // 本地存储 (Base64)
                           let finalAvatar = PLACEHOLDER_IMG; // 默认值

                           if (existingAvatar) {
                                finalAvatar = existingAvatar; // 优先使用本地存储的头像
                           } else if (char.avatar && typeof char.avatar === 'string' && char.avatar.trim() !== '') {
                                finalAvatar = char.avatar; // 其次使用传入数据中的有效头像
                           }
                           // 如果经历了以上步骤 finalAvatar 仍然无效 (如传入的 avatar 是 null 或空)，则会保持 PLACEHOLDER_IMG

                           acc[char.id] = {
                               ...char, // 基础是新数据
                               avatar: finalAvatar // 确保 avatar 总有一个有效值
                           };
                     } else {
                         console.warn("CharacterSystem.init: 发现无效或缺少 ID 的成员数据:", char);
                     }
                     return acc;
                 }, {});
                 console.log("CharacterSystem 初始化/更新完成:", Object.keys(this.characters).length, "个有效成员");
            },

            getCharacter(id) {
                return this.characters[id];
            },

            getCharacterByName(name) { // 新增：按名称查找
                return Object.values(this.characters).find(char => char.name === name);
            },

            getAllMembers() {
                return Object.values(this.characters);
            },

            getContactsData() {
                console.log("getContactsData: 开始构建联系人数据...");
                return Object.values(this.characters).map(char => {
                    if (!char || !char.id || !char.name) {
                         console.warn("getContactsData: 发现无效角色数据，跳过:", char);
                         return null; // 返回 null，稍后过滤
                    }
                    // 从 localStorage 加载该联系人的聊天记录
                    const savedMessages = loadChatHistory(char.name);
                    // 确保 messages 是数组
                    const messages = Array.isArray(savedMessages) ? savedMessages : (Array.isArray(char.messages) ? char.messages : []);

                    let lastMessage = '';
                    let lastTime = '';
                    if (messages.length > 0) {
                         // 查找最后一条非系统/日期消息
                         for (let i = messages.length - 1; i >= 0; i--) {
                              const lastMsg = messages[i];
                              if (lastMsg && lastMsg.content && lastMsg.type !== 'system' && lastMsg.type !== 'date') {
                                   lastMessage = lastMsg.type === 'sent' ? `你: ${lastMsg.content}` : lastMsg.content;
                                   lastTime = lastMsg.time || formatMessageTime(); // 确保有时间戳
                                   break; // 找到后退出循环
                              }
                         }
                    }

                    // 确保 avatar 是有效的 URL 或 placeholder
                    const avatarSrc = (char.avatar && typeof char.avatar === 'string' && char.avatar.length > 5) ? char.avatar : 'placeholder.png';

                    // 返回完整的联系人数据，包含所有必要字段
                    return {
                        id: char.id,
                        name: char.name,
                        avatar: avatarSrc, // 使用处理过的头像
                        status: char.status || 'offline', // 默认 offline
                        statusClass: char.status === 'online' ? 'online' : (char.status === 'busy' ? 'busy' : (char.status === 'away' ? 'away' : 'offline')),
                        lastMessage: lastMessage,
                        lastTime: lastTime,
                        unread: char.unread || 0,
                        messages: messages, // 使用合并/加载后的消息
                        // 保留其他可能需要的属性
                        stats: char.stats || {},
                        tags: Array.isArray(char.tags) ? char.tags : [],
                        bio: char.bio || '',
                        role: char.role || '成员',
                        mood: char.mood !== undefined ? char.mood : 50, // 默认值
                        affection: char.affection !== undefined ? char.affection : 0, // 默认值
                        fullName: char.fullName || char.name,
                        interests: char.interests || '',
                        relationships: char.relationships || '',
                        recentStatus: char.recentStatus || '',
                         isGroup: char.isGroup || false // 是否为群组
                    };
                }).filter(Boolean); // 过滤掉 null 值
                 console.log("getContactsData: 联系人数据构建完成。");
            },


            getTeamMembersData() {
                 return Object.values(this.characters).map(char => {
                     if (!char || !char.id || !char.name) return null; // 跳过无效数据
                      // 确保 avatar 是有效的 URL 或 placeholder
                     const avatarSrc = (char.avatar && typeof char.avatar === 'string' && char.avatar.length > 5) ? char.avatar : 'placeholder.png';
                     const stats = char.stats || {}; // 确保 stats 是对象

                      return {
                          id: char.id,
                          name: char.name,
                          avatar: avatarSrc,
                          role: char.role || '成员',
                          position: char.position || '', // 添加 position
                          stats: { // 确保所有技能值存在，默认为 0
                              vocal: stats.vocal !== undefined ? stats.vocal : 0,
                              dance: stats.dance !== undefined ? stats.dance : 0,
                              performance: stats.performance !== undefined ? stats.performance : 0,
                              charm: stats.charm !== undefined ? stats.charm : 0,
                              variety: stats.variety !== undefined ? stats.variety : 0
                          }
                      };
                 }).filter(Boolean); // 过滤无效数据
            },

             getSongMembersData() {
                 return Object.values(this.characters).map(char => {
                      if (!char || !char.id || !char.name) return null; // 跳过无效数据
                       // 确保 avatar 是有效的 URL 或 placeholder
                     const avatarSrc = (char.avatar && typeof char.avatar === 'string' && char.avatar.length > 5) ? char.avatar : 'placeholder.png';
                      const vocalSkill = (char.stats && char.stats.vocal !== undefined) ? char.stats.vocal : 0; // 获取声乐技能，默认为 0

                      return {
                          id: char.id, // 添加 ID
                          name: char.name,
                          avatar: avatarSrc,
                          skill: vocalSkill
                      };
                 }).filter(Boolean);
            }
        };


        // --- State ---
        let currentContact = "";
        let currentFilter = 'all';

        // --- Utility Functions ---
        function formatCurrency(amount) {
             // 确保 amount 是数字
             const num = Number(amount);
             if (isNaN(num)) {
                  return '???'; // 或者返回其他错误提示
             }
            return `${num.toLocaleString('zh-CN')}`;
        }

        function formatMessageTime(date = new Date()) {
            // 确保 date 是 Date 对象
             if (!(date instanceof Date) || isNaN(date.getTime())) {
                  date = new Date(); // 如果无效，使用当前时间
             }
             try {
                  return `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
             } catch (e) {
                  console.error("formatMessageTime 错误:", e, "输入:", date);
                  return "??:??";
             }
        }
        function formatNumber(num) {
             const number = Number(num);
             if (isNaN(number)) return '0'; // 处理无效数字
             if (number >= 1000000) return (number / 1000000).toFixed(1).replace(/\.0$/, '') + 'M';
             if (number >= 1000) return (number / 1000).toFixed(1).replace(/\.0$/, '') + 'K';
             return number.toString();
        }

        // --- Local Storage Functions ---
        function saveChatHistory(contactName, messages) {
            if (!contactName || !Array.isArray(messages)) return;
            try {
                const MAX_CHAT_HISTORY = 50; // 保存最近 50 条
                const messagesToSave = messages.slice(-MAX_CHAT_HISTORY);
                const storageKey = `chatHistory_${contactName}`;
                localStorage.setItem(storageKey, JSON.stringify(messagesToSave));
            } catch (error) {
                console.error(`保存 ${contactName} 聊天记录失败:`, error);
                if (error.name === 'QuotaExceededError') {
                     console.warn("LocalStorage 已满，尝试清理旧聊天记录...");
                     cleanupOldChatHistories(); // 尝试清理
                     // 可以选择再次尝试保存，或提示用户
                }
            }
        }

        function loadChatHistory(contactName) {
            if (!contactName) return null;
            try {
                const storageKey = `chatHistory_${contactName}`;
                const savedMessages = localStorage.getItem(storageKey);
                return savedMessages ? JSON.parse(savedMessages) : null;
            } catch (error) {
                console.error(`加载 ${contactName} 聊天记录失败:`, error);
                // 如果解析失败，可能数据已损坏，考虑删除
                // localStorage.removeItem(`chatHistory_${contactName}`);
                return null;
            }
        }

        function cleanupOldChatHistories() {
             console.log("尝试清理旧的聊天记录...");
             let removedCount = 0;
             try {
                 const keysToRemove = [];
                 for (let i = 0; i < localStorage.length; i++) {
                     const key = localStorage.key(i);
                     if (key && key.startsWith('chatHistory_')) {
                         // 可以根据时间戳或简单地随机删除一部分
                         // 这里简单地删除前几个找到的
                         keysToRemove.push(key);
                         if (keysToRemove.length >= 5) break; // 例如，一次最多删除 5 个旧记录
                     }
                 }
                 keysToRemove.forEach(key => {
                     localStorage.removeItem(key);
                     removedCount++;
                     console.log(`已移除旧聊天记录: ${key}`);
                 });
             } catch (error) {
                 console.error("清理聊天记录时出错:", error);
             }
             return removedCount;
        }

        function storeImageLocally(identifier, dataUrl) {
             if (!identifier || !dataUrl || !dataUrl.startsWith('data:image')) return;
            try {
                const key = `stored_image_${identifier}`;
                localStorage.setItem(key, dataUrl);
                // 更新图片索引
                let imageIndex = JSON.parse(localStorage.getItem('image_index') || '[]');
                if (!imageIndex.includes(key)) {
                    imageIndex.push(key);
                    // 限制索引大小，防止无限增长
                     const MAX_INDEX_SIZE = 50; // 例如，最多记录 50 个头像
                     if (imageIndex.length > MAX_INDEX_SIZE) {
                          const keysToRemove = imageIndex.splice(0, imageIndex.length - MAX_INDEX_SIZE);
                          // 理论上也应该删除对应的 localStorage 条目，但为了简化，这里只维护索引
                          console.warn(`图片索引超过 ${MAX_INDEX_SIZE}，已移除旧索引:`, keysToRemove);
                     }
                    localStorage.setItem('image_index', JSON.stringify(imageIndex));
                }
            } catch (error) {
                console.error('保存图片到本地存储时出错:', error);
                if (error.name === 'QuotaExceededError') {
                    console.warn("LocalStorage 已满，尝试清理旧图片...");
                    cleanupOldImages();
                    // 可以再次尝试保存，但可能再次失败
                }
            }
        }

        function loadImageFromLocalStorage(identifier) {
            if (!identifier) return null;
            const key = `stored_image_${identifier}`;
            return localStorage.getItem(key);
        }

        function cleanupOldImages() {
             console.log("尝试清理旧的图片数据...");
             let removedCount = 0;
            try {
                const imageIndex = JSON.parse(localStorage.getItem('image_index') || '[]');
                const KEYS_TO_KEEP = 20; // 保留最近 20 张
                if (imageIndex.length > KEYS_TO_KEEP) {
                    const keysToRemove = imageIndex.slice(0, imageIndex.length - KEYS_TO_KEEP);
                    keysToRemove.forEach(key => {
                        localStorage.removeItem(key);
                        removedCount++;
                        console.log(`已移除旧图片: ${key}`);
                    });
                    const newIndex = imageIndex.slice(imageIndex.length - KEYS_TO_KEEP);
                    localStorage.setItem('image_index', JSON.stringify(newIndex));
                }
            } catch (error) {
                console.error('清理旧图片时出错:', error);
            }
             return removedCount;
        }

        function loadStoredImages() {
            let avatarsLoaded = false;
            try {
                 const characters = CharacterSystem.getAllMembers();
                 if (!characters || characters.length === 0) return false;

                 characters.forEach(character => {
                      if (!character || character.id == null) return; // 跳过无效角色
                      const storedImage = loadImageFromLocalStorage(character.id);
                      if (storedImage) {
                           character.avatar = storedImage; // 直接更新 CharacterSystem 中的对象
                           avatarsLoaded = true;
                      }
                 });
                  if (avatarsLoaded) console.log("部分或全部头像已从本地存储加载。");
            } catch (error) {
                 console.error("加载本地存储头像时出错:", error);
            }
            return avatarsLoaded;
        }

        // --- LLM Interaction & State Update ---
        async function loadGameDataFromChat() {
             // 防止重复加载
             if (window.gameDataLoading) {
                 console.log('游戏数据正在加载中，跳过重复加载请求');
                 return;
             }
              if (window.gameDataLoaded && gameState && gameState.story && gameState.story.date) { // 更可靠的检查
                  console.log('游戏数据似乎已加载，跳过重复加载过程');
                  return;
              }

             window.gameDataLoading = true;
             showLoadingIndicator("加载游戏数据..."); // 显示加载提示

             try {
                 // 检查必要的 API 函数
                 if (typeof getChatMessages !== 'function' || typeof setChatMessage !== 'function') {
                     console.warn('酒馆 API 函数 (getChatMessages/setChatMessage) 不存在，尝试备用加载...');
                      // 使用备用数据 (如果提供)
                     if (window.externalData) {
                          updateGameState(window.externalData);
                          window.gameDataLoaded = true; // 标记加载完成
                          console.log('已从预设 externalData 加载游戏状态');
                     } else {
                          console.error("酒馆 API 和 externalData 均不可用，无法加载初始数据。");
                          alert("无法加载游戏数据，请检查控制台。可能需要刷新或检查前端助手。");
                     }
                     return; // 无论备用是否成功，都结束
                 }

                 // 获取楼层 0 消息
                 const messages = await getChatMessages(0);
                 if (!messages || messages.length === 0 || !messages[0].message) {
                     console.error('无法获取楼层 0 数据或消息为空');
                     if (window.externalData) {
                          console.warn('尝试使用 externalData 作为后备。');
                          updateGameState(window.externalData);
                          window.gameDataLoaded = true;
                     } else {
                          alert("无法加载存档数据。请确保楼层 0 有内容或提供 externalData。");
                     }
                     return;
                 }

                 const message = messages[0].message;
                 const gameTextMatch = message.match(/<gametext>([\s\S]*?)<\/gametext>/i);

                 if (!gameTextMatch || gameTextMatch.length < 2) {
                      console.warn('楼层 0 未找到 <gametext> 标签。内容:', message);
                      if (window.externalData) {
                           console.warn('尝试使用 externalData 作为后备。');
                           updateGameState(window.externalData);
                           window.gameDataLoaded = true;
                      } else {
                           alert("存档格式错误：未找到 <gametext> 标签。");
                      }
                 } else {
                      try {
                           const gameDataJSON = gameTextMatch[1].trim();
                           // 清理潜在的 Markdown 代码块标记
                           let cleanedJsonString = gameDataJSON.replace(/^```json\s*/, '').replace(/\s*```$/, '');
                           cleanedJsonString = cleanedJsonString.trim();

                           // 基本的 JSON 格式检查
                            if (!cleanedJsonString.startsWith('{') || !cleanedJsonString.endsWith('}')) {
                                throw new Error("提取的 gametext 内容不是有效的 JSON 对象格式。");
                            }

                           const gameData = JSON.parse(cleanedJsonString);
                           console.log("成功解析楼层 0 数据，准备更新游戏状态...");
                           updateGameState(gameData); // 更新状态
                           console.log('游戏数据加载成功 (来自 loadGameDataFromChat)');
                           window.gameDataLoaded = true; // 标记加载完成
                      } catch (e) {
                           console.error('解析楼层 0 游戏数据失败:', e);
                           console.error('尝试解析的文本:', gameTextMatch[1].trim());
                           if (window.externalData) {
                                console.warn('解析失败，尝试使用 externalData 作为后备。');
                                updateGameState(window.externalData);
                                window.gameDataLoaded = true;
                           } else {
                                alert(`解析存档数据失败: ${e.message}\n请检查楼层 0 的 <gametext> 内容或提供 externalData。`);
                           }
                      }
                 }
             } catch (error) {
                 console.error('加载游戏数据时发生顶层错误:', error);
                 if (window.externalData) {
                      console.warn('顶层错误，尝试使用 externalData 作为后备。');
                     updateGameState(window.externalData);
                     window.gameDataLoaded = true;
                 } else {
                     alert(`加载游戏数据时出错: ${error.message}`);
                 }
             } finally {
                 window.gameDataLoading = false;
                 hideLoadingIndicator(); // 隐藏加载提示
                 console.log("loadGameDataFromChat: 加载流程结束。");
             }
        }

        async function deleteGameRecords() {
            const confirmation1 = confirm("【警告】这将删除世界书「明星的诞生」中几乎所有游戏数据！\n\n这包括：\n- 所有章节回顾\n- 所有角色详细信息条目\n- 所有游戏存档\n\n此操作不可逆！确定要继续吗？");

            if (!confirmation1) {
                console.log("删除记录操作已取消 (第一次确认)。");
                return;
            }

            const confirmation2 = confirm("【最终确认】真的要删除「明星的诞生」世界书内除系统保留条目外的数据吗？\n\n请再次确认，这将清空你的游戏进度！");

            if (!confirmation2) {
                console.log("删除记录操作已取消 (第二次确认)。");
                return;
            }

            console.log("开始删除游戏记录...");
            showLoadingIndicator("正在删除记录...");
            disableInteractions(); // 禁用交互防止意外操作

            const worldBookName = "明星的诞生";
            const uidsToKeep = [0, 1, 2]; // 指定要保留的 UID

            try {
                // 检查 API
                if (typeof getLorebookEntries !== 'function' || typeof deleteLorebookEntry !== 'function') {
                    throw new Error("世界书 API 函数 (getLorebookEntries 或 deleteLorebookEntry) 不可用。");
                }

                // 获取所有条目
                const allEntries = await getLorebookEntries(worldBookName);
                if (!allEntries) {
                    // 如果获取失败，也可能意味着世界书不存在，可以认为没有需要删除的
                    console.warn(`无法获取世界书 "${worldBookName}" 的条目，可能无需删除。`);
                    // 【修改】在 finally 之前 return 时，需要确保 UI 恢复
                    hideLoadingIndicator();
                    enableInteractions();
                    alert("无法获取世界书信息，删除操作未执行。");
                    return; // 直接退出
                }

                // 筛选出需要删除的条目
                const entriesToDelete = allEntries.filter(entry => entry && entry.uid != null && !uidsToKeep.includes(entry.uid));

                if (entriesToDelete.length === 0) {
                    console.log("没有需要删除的条目。");
                    // 【修改】在 finally 之前 return 时，需要确保 UI 恢复
                    hideLoadingIndicator();
                    enableInteractions();
                    alert("没有找到需要删除的游戏记录。");
                    return; // 提前退出
                }

                console.log(`准备删除 ${entriesToDelete.length} 个条目...`);

                // 逐个删除条目 (注意: 频繁调用 API 可能较慢)
                let deletedCount = 0;
                let failedCount = 0;
                for (const entry of entriesToDelete) {
                    try {
                        const success = await deleteLorebookEntry(worldBookName, entry.uid);
                        if (success) {
                            deletedCount++;
                            console.log(`  - 已删除条目 UID: ${entry.uid}, Comment: "${entry.comment}"`);
                        } else {
                            failedCount++;
                            console.warn(`  - 删除条目 UID: ${entry.uid} 失败。`);
                        }
                        // await new Promise(resolve => setTimeout(resolve, 50)); // 可选延迟
                    } catch (deleteError) {
                        failedCount++;
                        console.error(`  - 删除条目 UID: ${entry.uid} 时发生错误:`, deleteError);
                    }
                }

                console.log(`删除操作完成。成功删除 ${deletedCount} 个条目，失败 ${failedCount} 个。`);
                alert(`游戏记录删除完成！\n成功删除 ${deletedCount} 个条目。\n${failedCount > 0 ? `有 ${failedCount} 个条目删除失败，请检查控制台。` : ''}`);

                // 可选：删除后提示用户
                alert("记录已删除。建议刷新页面或重新加载聊天以确保更改生效。");

            } catch (error) {
                console.error("删除游戏记录过程中发生错误:", error);
                alert(`删除游戏记录时发生错误: ${error.message}`);
            } finally {
                hideLoadingIndicator();
                enableInteractions(); // 重新启用交互
                 console.log("deleteGameRecords finally block executed."); // 添加日志确认执行
            }
            // 【修复】移除了这里多余的右花括号
        }
        function updateCharacterAvatar(characterId, avatarDataUrl) {
    console.log(`尝试为 ID: ${characterId} 更新头像`);
    // 1. 更新 CharacterSystem 中的数据
    const character = CharacterSystem.getCharacter(characterId); // 假设 CharacterSystem 有此方法
    if (character) {
        character.avatar = avatarDataUrl; // 更新内存中的头像数据
        console.log(`角色 ${character.name} 的头像数据已在内存中更新。`);

        // 2. 保存到本地存储
        storeImageLocally(characterId, avatarDataUrl); // 调用保存函数

        // 3. 可选：标记游戏状态已改变，以便下次保存
        window.gameStateChanged = true;

        // 4. 可选：如果其他地方（如联系人列表、团队页面）也显示头像，可能需要触发它们的更新
        DataSystem.UIUpdater.updateContactText(); // 例如：更新联系人列表
        // renderTeamPage(); // 如果团队页面显示头像且当前是活动页面

    } else {
        console.error(`updateCharacterAvatar: 未找到 ID 为 ${characterId} 的角色。`);
        alert("更新头像失败：找不到对应的角色数据。");
    }
}
        async function updateGameState(data) { // 【修改】添加 async 关键字
            console.log('%c--- updateGameState START ---', 'color: blue; font-weight: bold;');
            console.time("updateGameStateDuration");

            if (!data || typeof data !== 'object') { // 增加类型检查
                console.warn("updateGameState 接收到的数据无效 (非对象或 null)，退出。");
                console.timeEnd("updateGameStateDuration");
                console.log('%c--- updateGameState END (无效数据) ---', 'color: blue; font-weight: bold;');
                return;
            }
             console.log('收到用于更新的数据结构预览:', Object.keys(data)); // 打印顶层键

             // --- 状态更新 ---
            // 1. 更新非角色部分
            console.time("updateNonCharacterState");
             // 使用 structuredClone 确保深拷贝和隔离，避免引用问题
             // 合并时以 initialGameState 为基础，用 data 覆盖，确保基础结构存在
             gameState.story = { ...initialGameState.story, ...(data.story || {}) };
             gameState.team = {
                 // 合并 basicInfo，确保基础结构
                 basicInfo: { ...initialGameState.team.basicInfo, ...(data.team?.basicInfo || {}) },
                 // 合并 members, achievements, schedule，确保是数组
                 members: Array.isArray(data.team?.members) ? data.team.members : initialGameState.team.members,
                 achievements: Array.isArray(data.team?.achievements) ? data.team.achievements : initialGameState.team.achievements,
                 schedule: Array.isArray(data.team?.schedule) ? data.team.schedule : initialGameState.team.schedule
             };
             gameState.plan = Array.isArray(data.plan) ? data.plan : initialGameState.plan;
             gameState.song = {
                 ...initialGameState.song,
                 ...(data.song || {}),
                 // 确保 productionTeams 结构完整
                 productionTeams: {
                      ...initialGameState.song.productionTeams,
                      ...(data.song?.productionTeams || {}),
                      composers: Array.isArray(data.song?.productionTeams?.composers) ? data.song.productionTeams.composers : initialGameState.song.productionTeams.composers,
                      lyricists: Array.isArray(data.song?.productionTeams?.lyricists) ? data.song.productionTeams.lyricists : initialGameState.song.productionTeams.lyricists,
                      arrangers: Array.isArray(data.song?.productionTeams?.arrangers) ? data.song.productionTeams.arrangers : initialGameState.song.productionTeams.arrangers,
                      mvDirectors: Array.isArray(data.song?.productionTeams?.mvDirectors) ? data.song.productionTeams.mvDirectors : initialGameState.song.productionTeams.mvDirectors
                 }
             };
             console.timeEnd("updateNonCharacterState");


             // 2. 更新故事总结 (保持详细日志和健壮性)
             console.time("updateStorySummaryState");
             console.log("处理前 gameState.storySummary:", JSON.stringify(gameState.storySummary));
             let existingSummaries = Array.isArray(gameState.storySummary) ? [...gameState.storySummary] : [];
             let newSummariesInData = (data.storySummary && Array.isArray(data.storySummary)) ? data.storySummary : [];
             let summariesChanged = false;
             if (newSummariesInData.length > 0) {
                  const existingIds = new Set(existingSummaries.map(s => s.id));
                  newSummariesInData.forEach(newItem => {
                       if (newItem && typeof newItem.id === 'number' && typeof newItem.content === 'string' && newItem.content.trim()) {
                            if (!existingIds.has(newItem.id)) {
                                 existingSummaries.push(newItem);
                                 existingIds.add(newItem.id);
                                 summariesChanged = true;
                            } else {
                                 const idx = existingSummaries.findIndex(s => s.id === newItem.id);
                                 if (idx !== -1 && existingSummaries[idx].content !== newItem.content) {
                                      existingSummaries[idx].content = newItem.content;
                                      summariesChanged = true;
                                 }
                            }
                       }
                  });
                  if (summariesChanged) {
                       existingSummaries.sort((a, b) => a.id - b.id);
                       gameState.storySummary = existingSummaries; // 更新全局状态
                       console.log(`storySummary 更新完成，最终 ${gameState.storySummary.length} 条。`);
                  } else {
                       console.log("收到的 storySummary 未导致变化。");
                  }
             } else if (existingSummaries.length === 0) {
                  gameState.storySummary = []; // 确保是空数组
             }
             console.log("处理后 gameState.storySummary:", JSON.stringify(gameState.storySummary));
             console.timeEnd("updateStorySummaryState");


             // 3. 更新角色系统 (使用提取器获取数据)
             console.time("updateCharacterSystem");
             const charactersData = DataSystem.DataExtractor.extractCharacters(data); // 使用提取器
             let charactersToUpdateInLorebook = []; // 【修改】用于存储需要更新世界书的角色数据

             if (charactersData && Array.isArray(charactersData.members)) { // 【修改】确保 members 是数组
                 CharacterSystem.init(charactersData.members); // 更新内存中的角色状态
                 charactersToUpdateInLorebook = charactersData.members; // 【修改】标记这些收到的角色需要更新世界书
                 loadStoredImages(); // 加载本地头像覆盖
             } else {
                 console.warn("警告：数据中缺少有效的 characters.members，角色系统可能未更新。");
             }
             console.timeEnd("updateCharacterSystem");

             // ========================================================
             // 【新增】更新世界书角色条目
             // ========================================================
             console.time("updateLorebookEntries");
             if (charactersToUpdateInLorebook.length > 0) {
                 console.log(`检测到 ${charactersToUpdateInLorebook.length} 个角色数据需要同步到世界书...`);
                 // 使用 Promise.all 等待所有更新完成（并发执行，可能更快）
                 await Promise.all(charactersToUpdateInLorebook.map(charData => {
                     if (charData && charData.name) {
                         // 从 *更新后* 的 CharacterSystem 获取最新的完整数据（包含可能合并的本地头像等）
                         // 或者直接使用 charData，假设它就是最新的（取决于你的逻辑哪个更权威）
                         // 这里我们用 charData，因为它直接来自触发更新的数据源
                         return updateCharacterLorebookEntry(charData.name, charData);
                     }
                     return Promise.resolve(); // 对于无效数据，返回一个已解决的 Promise
                 })).catch(err => {
                     // 捕捉并行更新中可能发生的任何错误
                     console.error("并行更新世界书条目时发生错误:", err);
                 });
                 console.log("世界书角色条目同步尝试完成。");
             } else {
                 console.log("本次更新数据中不包含角色信息，跳过世界书同步。");
             }
             console.timeEnd("updateLorebookEntries");
             // ========================================================
             // 【新增结束】
             // ========================================================

             // 4. 重建联系人数据 (这个应该在角色系统和世界书更新 *之后*)
             console.time("rebuildContacts");
             try {
                 gameState.contacts = CharacterSystem.getContactsData(); // 从更新后的 CharacterSystem 获取
                 console.log(`联系人数据已重建，共 ${gameState.contacts.length} 个。`);
             } catch (charError) {
                  console.error("重建 gameState.contacts 时出错:", charError);
                  gameState.contacts = [];
             }
             console.timeEnd("rebuildContacts");

             // 5. 更新 UI (使用更新后的 gameState 数据)
             console.time("updateUI");
             console.log('开始更新界面...');
             try {
                 // 传递更新后的 gameState 部分给 UI 更新器
                 DataSystem.UIUpdater.updateMainText(gameState.story);
                 DataSystem.UIUpdater.updateContactText(); // 这个函数内部会读取 gameState.contacts
                 DataSystem.UIUpdater.updateTeamText(gameState.team);
                 DataSystem.UIUpdater.updatePlanText(gameState.plan); // 这个会调用 renderTaskList
                 DataSystem.UIUpdater.updateSongText(gameState.song); // 这个会调用 renderSongOptions

                 // 如果总结页面当前活动，强制重新渲染
                 const summaryPageElement = document.getElementById('summaryPage');
                 if (summaryPageElement?.classList.contains('active')) {
                     console.log("总结页面活动，触发渲染...");
                     renderStorySummaryPage();
                 }
                 // 【新增】如果联系人页面活动，强制刷新聊天和资料
                 const contactPageElement = document.getElementById('contactPage');
                 if(contactPageElement?.classList.contains('active') && currentContact){
                    console.log("联系人页面活动，刷新聊天和资料...");
                    renderChatContent(currentContact);
                    renderProfile(currentContact);
                 }
                 // 【新增】如果团队页面活动，强制刷新
                 const teamPageElement = document.getElementById('teamPage');
                 if(teamPageElement?.classList.contains('active')){
                    console.log("团队页面活动，刷新...");
                    renderTeamPage();
                 }
                 // 【新增】如果训练页面活动，强制刷新
                 const trainingPageElement = document.getElementById('trainingPage');
                  if(trainingPageElement?.classList.contains('active')){
                     console.log("训练页面活动，刷新统计...");
                     initTrainingPage(); // 更新统计数据
                  }


             } catch (uiError) { console.error("更新 UI 时出错:", uiError); }
             console.log('界面更新完成。');
             console.timeEnd("updateUI");

             // 6. 更新文本系统
             console.time("updateTextSystem");
             if (gameState.story && Array.isArray(gameState.story.dialogue)) { // 检查 gameState.story.dialogue
                 TextSystem.currentScript = gameState.story.dialogue;
                 TextSystem.currentIndex = 0; // 重置索引
                 console.log(`文本系统剧本已更新，共 ${TextSystem.currentScript.length} 条`);
                 const storyPageElement = document.getElementById('storyPage');
                 if (storyPageElement?.classList.contains('active')) {
                      // 使用 setTimeout 确保 UI 更新完成后再显示文本
                      setTimeout(() => {
                           console.log("故事页面激活，显示新剧本...");
                           TextSystem.showCurrentText(); // 显示第一条
                           // 检查新剧本是否直接结束
                           if (TextSystem.currentIndex >= TextSystem.currentScript.length) {
                                console.log("新剧本为空或已在结尾，显示选项。");
                                TextSystem.showOptions();
                           }
                      }, 0);
                 }
             } else {
                  console.warn("新状态中 story.dialogue 无效或为空，文本系统未更新剧本");
                  TextSystem.currentScript = [];
                  TextSystem.currentIndex = 0;
                  const storyPageElement = document.getElementById('storyPage');
                  if (storyPageElement?.classList.contains('active')) {
                       const storyContentEl = document.getElementById('story-content');
                       if (storyContentEl) storyContentEl.innerHTML = '<div class="text-normal">无故事内容。</div>';
                       toggleOptionsPanel(false); // 隐藏选项
                  }
             }
             console.timeEnd("updateTextSystem");

             console.log('游戏状态更新完成');
             window.gameDataLoaded = true;
             console.timeEnd("updateGameStateDuration");
             console.log('%c--- updateGameState END ---', 'color: blue; font-weight: bold;');
        }
        // 保存游戏状态
        let saveInProgress = false; // 可选：保留防抖/节流逻辑
        let lastSaveTime = 0;
        async function saveGameState() {
            // 可选：取消注释以启用防抖/节流
            // if (!window.gameDataLoaded) { console.log('Game data not loaded, skipping save.'); return; }
            // if (saveInProgress) { console.log('Save already in progress, skipping.'); return; }
            // const now = Date.now();
            // if (now - lastSaveTime < 5000) { console.log('Saving too frequently, skipping.'); return; }
            // saveInProgress = true;
            // lastSaveTime = now;
            console.log("saveGameState: 开始执行保存...");

            try {
                // --- 1. 创建状态副本 ---
                console.log("创建 gameState 副本用于保存...");
                let stateToSave;
                try {
                    stateToSave = structuredClone(gameState); // 创建深拷贝
                } catch (cloneError) {
                    console.error("创建 gameState 副本失败 (structuredClone):", cloneError);
                    alert("保存失败：无法复制游戏状态。");
                    return; // 退出保存流程
                }

                // --- 2. 从副本中移除 Base64 头像 ---
                console.log("从副本中移除 Base64 头像...");
                // 确保 removeBase64Avatars 函数存在
                if (typeof removeBase64Avatars === 'function') {
                    removeBase64Avatars(stateToSave); // 从副本中移除头像
                    console.log("Base64 头像数据已尝试从副本移除。");
                } else {
                    console.warn("removeBase64Avatars 函数未定义，无法移除头像。将保存包含头像的数据。");
                    // 可以选择中止保存或继续保存带头像的数据
                }

                // --- 3. 准备要保存的字符串 ---
                let gameStateStr;
                try {
                    gameStateStr = JSON.stringify(stateToSave); // Stringify 修改后的副本
                } catch (stringifyError) {
                    console.error("将游戏状态转换为 JSON 字符串时失败:", stringifyError);
                    alert("保存失败：无法序列化游戏状态。");
                    return; // 退出保存流程
                }
                const formattedMessage = `<gametext>${gameStateStr}</gametext>`;
                console.log(`准备保存的数据大小约: ${Math.round(formattedMessage.length / 1024)} KB`);

                // --- 4. 检查 setChatMessage 函数 ---
                if (typeof setChatMessage === 'function') {
                    // --- 调用 setChatMessage ---
                    console.log("调用 setChatMessage (refresh: 'none') 保存状态...");
                    await setChatMessage({ message: formattedMessage }, 0, { refresh: 'none' });
                    console.log('游戏状态已通过 setChatMessage 保存。');
                } else {
                    // --- 如果 setChatMessage 不可用，使用本地存储 ---
                    console.warn('setChatMessage 函数不存在，将使用本地存储保存');
                    try {
                        localStorage.setItem('gameState', formattedMessage); // 保存包含 gametext 标签的字符串
                        console.log('游戏状态已保存到本地存储');
                    } catch (lsError) {
                        console.error("保存到本地存储失败:", lsError);
                        alert("保存到本地存储失败，可能是空间不足。");
                    }
                }

            } catch (error) {
                // 捕获 setChatMessage 或其他意外错误
                console.error('保存游戏状态时发生顶层错误:', error);
                alert(`保存游戏状态时出错: ${error.message}`);
                // --- 5. 尝试本地备份（可选） ---
                try {
                    console.warn('保存时出错，尝试备份到本地存储...');
                    const backupState = structuredClone(gameState); // 重新克隆原始状态
                    if (typeof removeBase64Avatars === 'function') {
                        removeBase64Avatars(backupState); // 同样移除头像
                    }
                    localStorage.setItem('gameStateBackup', JSON.stringify(backupState)); // 备份纯净 JSON
                    console.log('移除头像后的游戏状态已尝试备份到本地存储');
                } catch (backupError) {
                    console.error('备份游戏状态到本地存储时出错:', backupError);
                }
            } finally {
                 // 可选：重置防抖标志
                 // saveInProgress = false;
                 console.log("saveGameState: 保存流程结束。");
            }
        }


        // --- Loading Indicator & Interaction Lock ---
        function showLoadingIndicator(message = "处理中...") {
            hideLoadingIndicator(); // 确保移除旧的
            const overlay = document.createElement('div');
            overlay.id = 'loadingOverlay';
            overlay.className = 'loading-overlay';
            overlay.innerHTML = `<div><div class="loading-spinner"></div><p>${message}</p></div>`;
            document.body.appendChild(overlay);
        }
        function hideLoadingIndicator() {
            const overlay = document.getElementById('loadingOverlay');
            if (overlay) overlay.remove();
        }
        function disableInteractions() {
            console.log("禁用交互...");
            document.querySelectorAll('button, input, select, .nav-link, .contact-item, .member-card, .style-mini-card, .member-select-item, .filter-btn, .chapter-item, .text-box').forEach(el => {
                 if (el.id !== 'loadingOverlay' && !el.closest('#loadingOverlay')) { // 避免禁用加载指示器本身
                      el.disabled = true;
                      el.style.pointerEvents = 'none'; // 对链接等元素也生效
                      el.style.cursor = 'wait';
                 }
            });
             document.body.style.cursor = 'wait';
        }
        function enableInteractions() {
            console.log("启用交互...");
            document.querySelectorAll('button, input, select, .nav-link, .contact-item, .member-card, .style-mini-card, .member-select-item, .filter-btn, .chapter-item, .text-box').forEach(el => {
                 el.disabled = false;
                 el.style.pointerEvents = 'auto';
                 el.style.cursor = ''; // 恢复默认光标
            });
             document.body.style.cursor = 'default';
             // 恢复特定按钮的文本/图标 (如果需要)
            const submitCustomOptionBtn = document.getElementById('submitCustomOptionBtn');
            if (submitCustomOptionBtn) submitCustomOptionBtn.innerHTML = '确定';
            const startProductionBtn = document.getElementById('startProductionBtn');
            if (startProductionBtn) startProductionBtn.innerHTML = '<i class="fas fa-play"></i> 开始制作';
        }

        // --- Text Extraction ---
        function extractGameText(responseText) {
            if (!responseText) return null;

            const gameTextTagLower = '<gametext>';
            const storyKeySequence = '"story":'; // 要查找的关键序列（不包含'{'，因为'{'要先找到）
            let currentSearchIndex = 0; // 从字符串开头开始搜索

            while (currentSearchIndex < responseText.length) {
                // 1. 查找下一个 <gametext> 标签
                const startIndex = responseText.toLowerCase().indexOf(gameTextTagLower, currentSearchIndex);
                if (startIndex === -1) {
                    console.warn("extractGameText: 未能在剩余文本中找到 <gametext> 标签。");
                    return null; // 搜索结束，未找到
                }

                // 2. 找到 <gametext> 标签结束后的位置
                const tagEndIndex = startIndex + gameTextTagLower.length;

                // 3. 从标签结束后查找第一个 '{'，跳过空白和代码块标记
                let jsonStartIndex = -1;
                const maxScanLengthAfterTag = 100; // 限制扫描范围
                const scanEndIndex = Math.min(tagEndIndex + maxScanLengthAfterTag, responseText.length);

                for (let i = tagEndIndex; i < scanEndIndex; i++) {
                    const char = responseText[i];
                    if (char === '{') {
                        jsonStartIndex = i;
                        console.log(`[提取阶段] 在索引 ${startIndex} 找到 <gametext>，并在索引 ${jsonStartIndex} 处找到起始 '{'`);
                        break;
                    } else if (!/\s/.test(char) && char !== '`' && !(char === 'j' && responseText.substring(i, i+4).toLowerCase() === 'json')) {
                        console.log(`[提取阶段] 在索引 ${startIndex} 的 <gametext> 之后遇到意外字符 '${char}'，继续搜索下一个 <gametext>`);
                        jsonStartIndex = -2; // 特殊标记，表示不符合，需要继续外层循环
                        break;
                    }
                }

                if (jsonStartIndex === -1) { // 在扫描范围内未找到 '{'
                    console.log(`[提取阶段] 在索引 ${startIndex} 的 <gametext> 之后未找到 '{'，继续搜索下一个 <gametext>`);
                    currentSearchIndex = tagEndIndex; // 从标签后继续搜索
                    continue; // 继续外层 while 循环
                }
                 if (jsonStartIndex === -2) { // 遇到意外字符
                      currentSearchIndex = tagEndIndex; // 从标签后继续搜索
                      continue; // 继续外层 while 循环
                 }


                // 4. 【新增】检查 '{' 后面是否紧跟着 "story": { （允许空白）
                let storyKeyIndex = -1;
                const maxScanLengthAfterBrace = 50; // 限制扫描范围
                const scanEndIndexForStory = Math.min(jsonStartIndex + 1 + maxScanLengthAfterBrace, responseText.length);

                for (let i = jsonStartIndex + 1; i < scanEndIndexForStory; i++) {
                    if (!/\s/.test(responseText[i])) { // 找到第一个非空白字符
                        // 检查是否以 "story": 开头
                        if (responseText.substring(i).startsWith(storyKeySequence)) {
                            // 再检查 "story": 后面是否紧跟着 { (允许空白)
                             let secondBraceIndex = -1;
                             const storyKeyEndIndex = i + storyKeySequence.length;
                             for (let j = storyKeyEndIndex; j < scanEndIndexForStory; j++){
                                  if(!/\s/.test(responseText[j])){
                                       if(responseText[j] === '{'){
                                            secondBraceIndex = j;
                                            storyKeyIndex = i; // 确认找到 "story": { 模式
                                            console.log(`[提取阶段] 在索引 ${jsonStartIndex} 的 '{' 之后，于索引 ${storyKeyIndex} 找到 "${storyKeySequence}" 并在索引 ${secondBraceIndex} 找到 '{'`);
                                       } else {
                                            console.log(`[提取阶段] 在索引 ${startIndex} 的 <gametext>{...} 中，"${storyKeySequence}" 之后不是 '{' (而是 '${responseText[j]}')，继续搜索下一个 <gametext>`);
                                       }
                                       break; // 找到第一个非空白就跳出内层 j 循环
                                  }
                             }
                        } else {
                             console.log(`[提取阶段] 在索引 ${startIndex} 的 <gametext>{...} 中，'{' 后的第一个非空白字符不是以 "${storyKeySequence}" 开头，继续搜索下一个 <gametext>`);
                        }
                        break; // 找到第一个非空白就跳出外层 i 循环
                    }
                }
                // --- 【新增结束】---

                if (storyKeyIndex === -1) { // 如果没有找到 "story": { 模式
                    currentSearchIndex = jsonStartIndex + 1; // 从 '{' 之后继续搜索下一个 <gametext>
                    continue; // 继续外层 while 循环
                }

                // 5. 如果找到了 <gametext>...{"story": { 模式，则进行括号匹配查找结尾 '}'
                // (括号匹配逻辑保持不变)
                let braceLevel = 0;
                let jsonEndIndex = -1;
                let inString = false;
                let escapeNext = false;

                for (let i = jsonStartIndex; i < responseText.length; i++) {
                    const char = responseText[i];
                    if (escapeNext) { escapeNext = false; continue; }
                    if (char === '\\') { escapeNext = true; continue; }
                    if (char === '"' && !escapeNext) { inString = !inString; }

                    if (!inString) {
                        if (char === '{') {
                            braceLevel++;
                        } else if (char === '}') {
                            braceLevel--;
                            if (braceLevel === 0) {
                                jsonEndIndex = i;
                                console.log(`[提取阶段] 在索引 ${jsonEndIndex} 处找到匹配的 '}'`);
                                break;
                            }
                        }
                    }
                     if (braceLevel < 0) {
                          console.warn("extractGameText: 检测到无效的括号层级，JSON 可能已损坏。");
                          return null; // 结构错误，直接失败
                     }
                }

                if (jsonEndIndex === -1) {
                    console.warn("extractGameText: 从找到的 '<gametext>...{\"story\": {' 开始未能找到匹配的结束 '}'。");
                    // 这里不再继续搜索，因为已经找到了符合开头的块但结构不完整
                    return null;
                }

                // 6. 提取 JSON 字符串
                const potentialJson = responseText.substring(jsonStartIndex, jsonEndIndex + 1).trim();

                if (potentialJson.startsWith('{') && potentialJson.endsWith('}')) {
                    console.log("[提取阶段] 成功提取符合 '<gametext>...{\"story\": {' 模式的 JSON 块:", potentialJson);
                    return potentialJson; // 找到了符合所有条件的块，返回结果
                } else {
                    console.error("extractGameText: 提取逻辑异常，最终结果非 {} 包裹。");
                    // 理论上不应发生，但也返回 null
                    return null;
                }
            } // 结束 while 循环

            // 如果循环结束仍未找到符合条件的块
            console.warn("extractGameText: 遍历完成，未能找到符合 '<gametext>...{\"story\": {' 模式的有效块。");
            return null;
        }
        function extractReplyContent(text) {
             if (!text) return "";
             const match = text.match(/<message1>([\s\S]*?)<\/message1>/i);
             return match ? match[1].trim() : text.trim();
        }
        function parseEntryContent(content) { // (保持不变)
            if (!content) return "";
            const details = [];
            const lines = content.split('\n');
            const fieldsToExtract = { /* ... */ }; // 保持原样
            let isInInfoSection = false;
            const simpleInfoRegex = /^\s*-\s*(\S+)\s*[:：]\s*(.+)/;
            lines.forEach(line => { /* ... */ }); // 保持原样
            return details.length > 0 ? `角色${details.find(d => d.startsWith("姓名:"))?.split(':')[1]?.trim() || ''}的相关信息如下：\n- ${details.join('\n- ')}\n\n请参考以上信息进行回复。\n\n---\n\n` : "";
        }

        // --- World Book & Saving ---
        async function toggleWorldBookEntries(entriesToEnable = [], entriesToDisable = []) {
            const worldBookName = "明星的诞生";
             console.log(`切换世界书 "${worldBookName}" 条目: 启用[${entriesToEnable.join('/') || '无'}], 禁用[${entriesToDisable.join('/') || '无'}]`);
            try {
                if (typeof getLorebookEntries !== 'function' || typeof setLorebookEntries !== 'function') {
                    console.warn("世界书 API 函数不可用，跳过切换。");
                    return;
                }
                const allEntries = await getLorebookEntries(worldBookName);
                if (!allEntries) {
                     console.warn(`无法获取 "${worldBookName}" 条目，跳过。`);
                     return;
                }

                let changed = false;
                const entriesToUpdate = [];

                allEntries.forEach(entry => {
                     if (!entry || typeof entry.comment !== 'string' || entry.uid == null) return; // 跳过无效条目

                    const entryComment = entry.comment;
                    let currentEnabledStatus = entry.enabled;
                    let targetEnabledStatus = currentEnabledStatus; // 假设不变

                    if (entriesToEnable.includes(entryComment)) {
                        targetEnabledStatus = true; // 目标是启用
                    } else if (entriesToDisable.includes(entryComment)) {
                        targetEnabledStatus = false; // 目标是禁用
                    }

                     // 如果目标状态与当前状态不同，则标记更改并准备更新
                     if (targetEnabledStatus !== currentEnabledStatus) {
                          changed = true;
                          entriesToUpdate.push({ uid: entry.uid, enabled: targetEnabledStatus });
                           console.log(`  - ${targetEnabledStatus ? '启用' : '禁用'}条目: "${entryComment}" (uid: ${entry.uid})`);
                     }
                });

                if (changed) {
                    console.log(`检测到 ${entriesToUpdate.length} 个条目状态变更，调用 setLorebookEntries...`);
                    await setLorebookEntries(worldBookName, entriesToUpdate);
                    console.log(`世界书 "${worldBookName}" 条目状态更新成功。`);
                } else {
                    console.log(`所有目标条目状态已是最新，无需更新世界书。`);
                }
            } catch (error) {
                console.error(`切换世界书条目状态时出错:`, error);
            }
        }
        async function autoSaveToWorldBook() {
            const worldBookName = "明星的诞生";
            const baseEntryComment = "存档";
            const entrySuffix = "（不要删，不用打开）";
            console.log("autoSaveToWorldBook: 开始自动存档...");

            try {
                 // --- 1. 检查 API ---
                 if (typeof getLorebooks !== 'function' || typeof createLorebook !== 'function' ||
                     typeof getLorebookEntries !== 'function' || typeof createLorebookEntry !== 'function') {
                     console.warn("世界书 API 函数不完整，无法执行自动存档。");
                     return;
                 }

                 // --- 2. 检查并创建世界书 ---
                 const lorebookList = await getLorebooks();
                 if (!lorebookList.includes(worldBookName)) {
                     console.log(`世界书 "${worldBookName}" 不存在，正在创建...`);
                     await createLorebook(worldBookName);
                     await new Promise(resolve => setTimeout(resolve, 300)); // 等待生效
                     console.log(`世界书 "${worldBookName}" 已创建。`);
                 }

                 // --- 3. 查找最大存档序号 ---
                 let maxSaveNum = 0;
                 const saveRegex = new RegExp(`^${baseEntryComment}(\\d+)${entrySuffix.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}$`);
                 try {
                     const allEntries = await getLorebookEntries(worldBookName);
                     if (allEntries) {
                         allEntries.forEach(entry => {
                             if (entry && entry.comment) {
                                 const match = entry.comment.match(saveRegex);
                                 if (match && match[1]) {
                                     const num = parseInt(match[1], 10);
                                     if (!isNaN(num) && num > maxSaveNum) maxSaveNum = num;
                                 }
                             }
                         });
                     }
                 } catch (findError) {
                     console.error("查找现有存档时出错:", findError);
                     // 即使查找出错，仍然可以尝试创建存档 1
                 }
                 const nextSaveNum = maxSaveNum + 1;
                 const newEntryComment = `${baseEntryComment}${nextSaveNum}${entrySuffix}`;
                 console.log(`下一个存档序号: ${nextSaveNum}, 名称: "${newEntryComment}"`);

                 // --- 4. 创建状态副本并移除 Base64 头像 ---
                 console.log("创建 gameState 副本用于世界书存档...");
                 let stateToSaveForWorldBook;
                 try {
                     stateToSaveForWorldBook = structuredClone(gameState);
                 } catch (cloneError) {
                     console.error("创建 gameState 副本失败 (structuredClone):", cloneError);
                     alert("自动存档失败：无法复制游戏状态。");
                     return;
                 }
                 console.log("从副本中移除 Base64 头像...");
                 if (typeof removeBase64Avatars === 'function') {
                     removeBase64Avatars(stateToSaveForWorldBook);
                     console.log("Base64 头像数据已尝试从副本移除。");
                 } else {
                     console.warn("removeBase64Avatars 函数未定义，无法移除头像。将保存包含头像的数据到世界书。");
                 }

                 // --- 5. 准备要保存的 JSON 字符串 ---
                 let currentStateJSON;
                 try {
                     currentStateJSON = JSON.stringify(stateToSaveForWorldBook); // Stringify 修改后的副本
                 } catch (stringifyError) {
                     console.error("将游戏状态转换为 JSON 字符串时失败:", stringifyError);
                     alert("自动存档失败：无法序列化游戏状态。");
                     return;
                 }
                 console.log(`准备保存到世界书的数据大小约: ${Math.round(currentStateJSON.length / 1024)} KB`);

                 // --- 6. 创建新存档条目 ---
                 console.log(`正在创建新存档条目: "${newEntryComment}"`);
                 await createLorebookEntry(worldBookName, {
                     comment: newEntryComment,
                     content: currentStateJSON, // 保存纯净的 JSON 字符串
                     enabled: false,
                     key: ["游戏存档", `存档${nextSaveNum}`, "GameStateBackup"],
                     type: 'constant',
                     position: 'before_character_definition'
                 });
                 console.log(`新的存档条目 "${newEntryComment}" 已创建。`);

            } catch (error) {
                // 捕获API检查、世界书操作等错误
                console.error("自动存档到世界书时发生顶层错误:", error);
                // 可以选择性地 alert 用户，但自动保存失败通常不需要打断用户
                // alert(`自动存档失败: ${error.message}`);
            } finally {
                 console.log("autoSaveToWorldBook: 存档流程结束。");
            }
        }
        async function openLoadSaveModal() {
            const worldBookName = "明星的诞生";
            const baseEntryComment = "存档";
            const entrySuffix = "（不要删，不用打开）";
            const saveRegex = new RegExp(`^${baseEntryComment}(\\d+)${entrySuffix.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}$`);

            console.log("尝试打开读档弹窗...");
             showLoadingIndicator("加载存档列表..."); // 显示加载提示

            try {
                if (typeof getLorebookEntries !== 'function') {
                     throw new Error("世界书 API 函数 (getLorebookEntries) 不可用。");
                }

                // 获取所有条目
                const allEntries = await getLorebookEntries(worldBookName);
                 if (!allEntries) {
                      throw new Error(`无法获取世界书 "${worldBookName}" 的条目。`);
                 }

                // 筛选、添加序号、排序
                const saveEntries = allEntries
                    .filter(entry => entry && entry.comment && entry.uid != null && saveRegex.test(entry.comment)) // 增加有效性检查
                    .map(entry => {
                        const match = entry.comment.match(saveRegex);
                        entry.saveNumber = match ? parseInt(match[1], 10) : 0;
                        return entry;
                    })
                    .sort((a, b) => b.saveNumber - a.saveNumber); // 按序号降序排序 (最新的在前面)

                 console.log(`找到 ${saveEntries.length} 个有效存档条目并排序。`);


                 // 创建弹窗 HTML
                 const modal = document.createElement('div');
                 modal.className = 'chapter-modal load-save-modal';
                 modal.id = 'loadSaveModal';

                 let saveListHtml = '';
                 if (saveEntries.length > 0) {
                      saveListHtml = saveEntries.map(entry => `
                          <li class="chapter-item save-item" data-entry-uid="${entry.uid}" data-entry-comment="${entry.comment}">
                             存档 ${entry.saveNumber} <span class="text-muted small">(${entry.comment.replace(entrySuffix,'').replace(baseEntryComment,'')})</span>
                          </li>
                      `).join('');
                 } else {
                      saveListHtml = '<li class="text-muted p-3 text-center">没有可加载的存档。</li>';
                 }

                 modal.innerHTML = `
                     <div class="chapter-modal-content">
                         <div class="chapter-modal-header">
                             <h3>选择要读取的存档</h3>
                             <button class="close-btn close-load-modal-btn">×</button>
                         </div>
                         <div class="chapter-modal-body">
                             <ul class="chapter-list">
                                 ${saveListHtml}
                             </ul>
                         </div>
                         <div class="chapter-modal-footer" style="padding: 15px 20px; text-align: right; border-top: 1px solid #eee;">
                              <button class="btn btn-secondary close-load-modal-btn">取消</button>
                         </div>
                     </div>
                 `;

                 // 添加关闭事件
                 const closeModal = () => { /* ... 保持不变 ... */
                    const existingModal = document.getElementById('loadSaveModal');
                    if (existingModal) {
                        document.body.classList.remove('modal-open');
                        existingModal.remove();
                        document.removeEventListener('keydown', handleEscKey); // 移除 ESC 监听
                        console.log("读档弹窗已关闭。");
                    }
                };
                 modal.querySelectorAll('.close-load-modal-btn').forEach(btn => btn.addEventListener('click', closeModal));
                 modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(); });
                 modal.querySelector('.chapter-modal-content').addEventListener('click', e => e.stopPropagation());
                 // ESC 键关闭
                 const handleEscKey = (e) => { if (e.key === 'Escape') closeModal(); };
                 document.addEventListener('keydown', handleEscKey);

                 // 添加存档条目点击事件 (事件委托)
                 const saveListElement = modal.querySelector('.chapter-list');
                 if (saveListElement) {
                     saveListElement.addEventListener('click', async (e) => {
                          const saveItem = e.target.closest('.save-item');
                          if (saveItem && saveItem.dataset.entryUid) {
                               const uidToLoad = parseInt(saveItem.dataset.entryUid, 10);
                               const commentToLoad = saveItem.dataset.entryComment;
                                if (!isNaN(uidToLoad)) { // 确保 UID 有效
                                     console.log(`尝试加载存档: ${commentToLoad} (uid: ${uidToLoad})`);
                                     closeModal(); // 先关闭弹窗
                                     await loadGameStateFromEntry(worldBookName, uidToLoad); // 调用加载函数
                                } else {
                                     console.error("无效的存档 UID:", saveItem.dataset.entryUid);
                                     alert("加载失败：存档标识无效。");
                                }
                          }
                     });
                 }

                 // 显示弹窗
                 document.body.classList.add('modal-open');
                 document.body.appendChild(modal);
                 console.log("读档弹窗已显示。");

            } catch (error) {
                console.error("打开读档弹窗时出错:", error);
                alert(`加载存档列表失败: ${error.message}`);
            } finally {
                 hideLoadingIndicator(); // 无论成功失败都隐藏加载提示
            }
        }
        async function loadGameStateFromEntry(lorebookName, entryUid) {
             console.log(`开始从世界书 "${lorebookName}" 加载 UID: ${entryUid} 的存档...`);
             showLoadingIndicator("读取存档中..."); // 显示加载

             try {
                  if (typeof getLorebookEntries !== 'function') {
                       throw new Error("世界书 API 函数 (getLorebookEntries) 不可用。");
                  }

                 // 获取特定条目 (确保 filter 格式正确，或者获取全部再过滤)
                 // 尝试直接获取所有条目然后查找，更可靠
                 const allEntries = await getLorebookEntries(lorebookName);
                 if (!allEntries) throw new Error("无法获取世界书条目。");
                 const entryToLoad = allEntries.find(e => e && e.uid === entryUid); // 查找匹配的 UID

                 if (!entryToLoad) {
                      throw new Error(`在 "${lorebookName}" 中未找到 UID 为 ${entryUid} 的存档条目。`);
                 }
                 console.log("成功获取到存档条目信息。");

                 const entryContent = entryToLoad.content;
                 if (!entryContent || !entryContent.trim()) {
                      throw new Error(`存档条目 (uid: ${entryUid}) 内容为空。`);
                 }

                 // 提取 gametext 内容
                 let extractedGameText = extractGameText(entryContent);
                 if (!extractedGameText) {
                     console.warn("存档内容中未找到 <gametext> 标签，尝试直接解析...");
                     extractedGameText = entryContent.trim();
                     // 再次检查是否是 JSON
                     if (!extractedGameText.startsWith('{') || !extractedGameText.endsWith('}')) {
                          throw new Error("存档格式无效（缺少gametext或内容非JSON）。");
                     }
                 }

                 // 清理并解析 JSON
                 let cleanedText = extractedGameText.trim();
                  // --- 复用清理逻辑 ---
                 cleanedText = cleanedText.replace(/^```json\s*/, '').replace(/\s*```$/, '');
                 cleanedText = cleanedText.replace(/^```\s*/, '').replace(/\s*```$/, '');
                  // 移除可能的干扰标签 (根据实际情况添加)
                 // while (/<thinking>[\s\S]*?<\/thinking>/i.test(cleanedText)) { cleanedText = cleanedText.replace(/<thinking>[\s\S]*?<\/thinking>/i, ''); }
                 const firstBraceIndex = cleanedText.indexOf('{');
                 const lastBraceIndex = cleanedText.lastIndexOf('}');
                 if (firstBraceIndex === -1 || lastBraceIndex === -1 || lastBraceIndex < firstBraceIndex) {
                     throw new Error("清理后的存档文本中找不到有效的 JSON 对象边界 '{}'");
                 }
                 cleanedText = cleanedText.substring(firstBraceIndex, lastBraceIndex + 1);
                 cleanedText = cleanedText.trim();
                  // --- 清理结束 ---

                 if (!cleanedText.startsWith('{') || !cleanedText.endsWith('}')) {
                      throw new Error("最终清理后的存档文本不是有效的 JSON 对象格式。");
                 }

                 const loadedGameData = JSON.parse(cleanedText);
                 console.log("成功解析存档数据。");

                 // 更新游戏状态 (会触发 UI 更新和头像加载)
                 console.log("使用加载的存档数据更新游戏状态...");
                 updateGameState(loadedGameData);
                 console.log("游戏状态已从存档加载并更新。");

                 // 如果当前在故事页面，重置文本显示
                  if (document.getElementById('storyPage').classList.contains('active')) {
                      console.log("重置故事文本显示...");
                      TextSystem.resetScript(); // 显示新加载对话的开头
                  } else {
                      // 如果不在故事页，切换过去？或者下次切换时会自动显示
                       console.log("当前不在故事页面，切换时将显示新加载的剧本。");
                  }

                 alert(`存档 "${entryToLoad.comment}" 加载成功！`);

             } catch (error) {
                 console.error(`从存档 (uid: ${entryUid}) 加载游戏状态时出错:`, error);
                 alert(`加载存档失败: ${error.message}`);
             } finally {
                  hideLoadingIndicator(); // 隐藏加载提示
             }
        }
        /**
         * Recursively removes avatar properties that contain Base64 data URLs
         * from a given object or array (operates in place on the input).
         * IMPORTANT: Always call this on a DEEP COPY of the game state, not the original.
         * @param {object|array} objOrArray The object or array to process.
         */
         function removeBase64Avatars(objOrArray) {
            if (!objOrArray || typeof objOrArray !== 'object') {
                return; // Ignore non-objects/arrays and null
            }

            if (Array.isArray(objOrArray)) {
                // If it's an array, iterate through its elements
                objOrArray.forEach(item => removeBase64Avatars(item));
            } else {
                // If it's an object, check for the avatar property
                if (objOrArray.hasOwnProperty('avatar') && typeof objOrArray.avatar === 'string' && objOrArray.avatar.startsWith('data:image')) {
                    // Remove the Base64 avatar property
                    delete objOrArray.avatar;
                    // console.log("Removed Base64 avatar for:", objOrArray.name || objOrArray.id || 'unknown object');
                }

                // Recursively process nested objects and arrays within this object
                for (const key in objOrArray) {
                    if (objOrArray.hasOwnProperty(key)) {
                        removeBase64Avatars(objOrArray[key]);
                    }
                }
            }
        }
        function findMatchingBrace(str, startIndex) {
            if (!str || startIndex < 0 || str[startIndex] !== '{') { // Added null check for str
                return -1;
            }
            let braceCount = 1;
            for (let i = startIndex + 1; i < str.length; i++) {
                if (str[i] === '{') {
                    braceCount++;
                } else if (str[i] === '}') {
                    braceCount--;
                    if (braceCount === 0) {
                        return i; // Found the matching closing brace
                    }
                }
            }
            return -1; // No matching brace found
        }
        // --- Page Navigation & Initialization ---
        function switchPage(targetPageId) {
            console.log(`切换到页面: ${targetPageId}`);
            const currentActiveLink = document.querySelector('.nav-link.active');
            if (currentActiveLink && currentActiveLink.dataset.page === targetPageId) {
                console.log('已经在当前页面，跳过切换');
                return;
            }

            // Deactivate all
            document.querySelectorAll('.nav-link').forEach(link => link.classList.remove('active'));
            document.querySelectorAll('.page').forEach(page => page.classList.remove('active'));

            // Activate target
            const targetLink = document.querySelector(`.nav-link[data-page="${targetPageId}"]`);
            const targetPage = document.getElementById(targetPageId + 'Page');

            if (targetLink) targetLink.classList.add('active');
            if (targetPage) {
                targetPage.classList.add('active');
                console.log(`页面 ${targetPageId}Page 已激活`);

                // --- 调用页面渲染/更新逻辑 ---
                 console.log(`为页面 ${targetPageId} 调用渲染/更新函数...`);
                 try { // 添加 try-catch 保护页面渲染逻辑
                      if (targetPageId === 'story') {
                           initStoryPage(); // 确保故事页面初始化或刷新显示
                      } else if (targetPageId === 'contact') {
                           initContactPage(); // 确保联系人列表和当前聊天/资料是最新的
                      } else if (targetPageId === 'team') {
                           renderTeamPage(); // 总是重新渲染团队数据
                      } else if (targetPageId === 'plan') {
                           renderTaskList(); // 重新渲染任务列表
                           filterTasks(currentFilter); // 应用过滤器
                           updateTaskCounts(); // 更新计数
                      } else if (targetPageId === 'song') {
                           renderSongOptions(); // 重新渲染歌曲选项
                           updateSongSummary(); // 更新摘要
                      } else if (targetPageId === 'summary') {
                           renderStorySummaryPage(); // 渲染故事总结
                      } else if (targetPageId === 'training') {
                          initTrainingPage(); // 更新特训页面的统计数据
                      }
                 } catch (renderError) {
                      console.error(`渲染页面 ${targetPageId} 时出错:`, renderError);
                      // 可以考虑显示一个通用的错误提示
                 }

            } else {
                 console.error(`错误：找不到 ID 为 ${targetPageId}Page 的页面元素！`);
                 // Fallback: 激活第一个页面
                 const firstPage = document.querySelector('.page');
                 if (firstPage) firstPage.classList.add('active');
                 const firstLink = document.querySelector('.nav-link');
                 if (firstLink) firstLink.classList.add('active');
            }
             console.log(`页面切换至 ${targetPageId} 完成。`);
        }

        function initStoryPage() {
             console.log('初始化/刷新故事页面显示');
             if (TextSystem.currentScript && TextSystem.currentScript.length > 0) {
                  TextSystem.showCurrentText(); // 显示当前或第一条文本
                  if (TextSystem.currentIndex >= TextSystem.currentScript.length) {
                       TextSystem.showOptions(); // 如果已结束，显示选项
                  }
             } else {
                  const storyContent = document.getElementById('story-content');
                  if (storyContent) storyContent.innerHTML = '<div class="text-normal">暂无故事内容。</div>';
                  toggleOptionsPanel(false); // 隐藏选项
             }
        }

        function initContactPage() {
             console.log('初始化/刷新联系人页面');
             DataSystem.UIUpdater.updateContactText(); // 更新列表

             // 确保当前选择的联系人信息被渲染
             const contactExists = gameState.contacts.some(c => c.name === currentContact);
             if (currentContact && contactExists) {
                  // 确保对应的列表项是 active
                  document.querySelectorAll('.contact-item').forEach(item => {
                       item.classList.toggle('active', item.dataset.contact === currentContact);
                  });
                  renderChatContent(currentContact);
                  renderProfile(currentContact);
             } else {
                   // 如果当前联系人无效或不存在，选择第一个或清空
                  currentContact = gameState.contacts.length > 0 ? gameState.contacts[0].name : "";
                   if (currentContact) {
                        switchContact(currentContact); // 切换到第一个
                   } else {
                        renderChatContent(null); // 清空聊天区
                        renderProfile(null); // 清空资料区
                         // 更新聊天头部
                         const chatTitleNameEl = document.getElementById('chat-title-name');
                         const chatHeaderAvatarEl = document.getElementById('chat-header-avatar');
                         if(chatTitleNameEl) chatTitleNameEl.textContent = '选择联系人';
                         if(chatHeaderAvatarEl) chatHeaderAvatarEl.style.display = 'none';
                   }
             }
        }

        function renderTeamPage() {
             console.log('渲染团队页面');
             DataSystem.UIUpdater.updateTeamText(gameState.team); // 使用最新状态渲染
        }

        // Plan Page: renderTaskList, filterTasks, updateTaskCounts 已存在

        // Song Page: renderSongOptions, updateSongSummary 已存在

        // Summary Page: renderStorySummaryPage 已存在
        function renderStorySummaryPage() {
            console.log("开始渲染故事总结页面 (堆叠卡片风格)...");
            const summaryListContainer = document.getElementById('storySummaryList');
            if (!summaryListContainer) {
                 console.error("错误：找不到故事总结列表容器 #storySummaryList");
                 return;
            }
             summaryListContainer.classList.remove('list-group');
             summaryListContainer.classList.add('summary-stack');
             summaryListContainer.innerHTML = ''; // 清空旧内容

             const summaries = Array.isArray(gameState.storySummary) ? gameState.storySummary : [];
             console.log(`准备渲染故事总结，共 ${summaries.length} 条`);

             if (summaries.length > 0) {
                  // 不需要重新排序，假设 updateGameState 中已排序
                  summaries.forEach(item => {
                       if (item && typeof item.id === 'number' && typeof item.content === 'string' && item.content.trim() !== '') {
                           summaryListContainer.innerHTML += `
                               <div class="summary-entry card">
                                   <div class="card-content-wrapper">
                                     <div class="entry-meta">
                                       <span class="entry-id">记录 #${item.id}</span>
                                     </div>
                                     <div class="entry-content">
                                       <p>${item.content.replace(/\n/g, '<br>')}</p> <!-- 替换换行为br -->
                                     </div>
                                   </div>
                               </div>
                           `;
                       } else {
                           console.warn("渲染总结时发现无效或空的条目:", item);
                       }
                  });
             } else {
                  summaryListContainer.innerHTML = '<p class="empty-summary-message">还没有值得回顾的故事片段呢。</p>';
             }
              console.log("故事总结列表渲染完成。");
        }


        function initTrainingPage() {
             console.log('更新特训计划页面统计数据');
             updateTrainingStats(); // 更新统计数据
             // 不需要初始化进度条动画，因为移除了进度条显示
             // initProgressBars();
        }


        // --- Story Actions ---
        async function selectStoryOption(optionNumber, buttonElement, isDefault = false) {
            const optionIndex = optionNumber - 1;
            let optionsSource = isDefault ? [
                 "带大家到练习室排练新歌",
                 "宣布明天请客吃饭",
                 "叮嘱大家注意身体"
            ] : (gameState.story?.options || []);
            let selectedOptionText = (optionIndex >= 0 && optionIndex < optionsSource.length) ? optionsSource[optionIndex] : null;

            if (!selectedOptionText) {
                 console.error("选择的选项无效:", optionNumber, "isDefault:", isDefault, "Source:", optionsSource);
                 alert("选择的选项无效！");
                 // enableInteractions(); // finally 中会处理
                 return;
            }
             console.log(`玩家选择了选项 ${optionNumber}: ${selectedOptionText}`);

            showLoadingIndicator("处理选项中...");
            disableInteractions();
             if(buttonElement) buttonElement.style.backgroundColor = 'rgba(var(--primary-color-rgb), 0.2)';

            try {
                 await toggleWorldBookEntries(['COT', '格式要求'], ['COT（chat）']);
                 await autoSaveToWorldBook();

                 // 获取故事总结上下文
                 let summaryContext = "【最近的故事总结回顾】\n";
                 const summaries = Array.isArray(gameState.storySummary) ? gameState.storySummary : [];
                 if (summaries.length > 0) {
                      const recentSummaries = summaries.slice(-3);
                      summaryContext += recentSummaries.length > 0
                           ? recentSummaries.map(s => `${s.id}. ${s.content}`).join('\n')
                           : "暂无总结。";
                 } else { summaryContext += "暂无总结。"; }
                 summaryContext += "\n";

                // 构建注入的系统指令
                const systemInstruction = `--- CORE ACTION THIS TURN ---\n` +
                                         `**Player Character Action:** {{user}} chose the following option:\n` +
                                         `**Action Text:** "${selectedOptionText}"\n` +
                                         `**Instruction:** This decision is the **ABSOLUTE FOCUS** for this turn's response. You **MUST** generate the narrative and game state update based *directly* on this specific action being taken *now*. Do **NOT** generate alternative plot progressions or ignore this action.\n\n` +
                                         `--- Execution Context & Guidelines ---\n` +
                                         `${summaryContext}\n` + // 将总结放入指令中
                                         `【<回复格式> 指令】\n` + // 引用外部的 CoT/回复格式
                                         `Please strictly follow the rules defined in \`<回复格式>\` (your CoT, Thinking Format v3.0). Specifically:\n` +
                                         `1. Narrative MUST show the Action Text above being acted upon immediately.\n` +
                                         `2. Depict realistic NPC reactions to *this specific decision*.\n` +
                                         `3. Calculate state changes (mood, affection, funds if applicable, chapter, next options) directly resulting from *this decision*.\n` +
                                         `4. Output ONLY the \`<gametext>\` containing the *complete* updated game state reflecting the consequences of this action.\n`;

                console.log("System Instruction for generate:", systemInstruction);

                // 调用 generate，将玩家选项文本放入 user_input，指令放入 injects
                const rawLLMResponse = await generate({
                    user_input: selectedOptionText, // 用户的选择作为 user_input
                    should_stream: false,
                    injects: [ // 其他上下文和指令放入 injects
                        {
                            role: 'system',
                            content: systemInstruction,
                            position: 'before_prompt', // 放在最前面强调
                            depth: 0, // 主指令通常深度为0
                            should_scan: false // 指令不需要扫描世界书
                        }
                    ],
                    // max_chat_history: 'all' // 或者根据需要限制
                });

                console.log("收到 LLM 原始响应 (剧情选项):", rawLLMResponse);

                // --- (后续解析 gametext 和更新状态的逻辑不变) ---
                let newGameData = null;
                let messageToSave = rawLLMResponse;
                const extractedJsonString = extractGameText(rawLLMResponse);

                if (extractedJsonString) {
                    console.log("[解析阶段] 准备解析:", extractedJsonString);
                    try {
                        newGameData = JSON.parse(extractedJsonString);
                        messageToSave = `<gametext>${extractedJsonString}</gametext>`;
                        console.log("[解析阶段] JSON 解析成功。");
                    } catch (parseError) {
                        console.error("[解析阶段] JSON 解析失败:", parseError);
                        console.error("失败时尝试解析的字符串:", extractedJsonString);
                        alert(`解析游戏状态时出错: ${parseError.message}. LLM 可能返回了无效的格式。`);
                        newGameData = null;
                    }
                } else {
                    console.error("未能从 LLM 响应中提取有效的 <gametext>{...}</gametext> 块。");
                    if (rawLLMResponse && !rawLLMResponse.includes('<gametext>') && !rawLLMResponse.includes('{') && rawLLMResponse.trim().length > 5) {
                         console.warn("响应中无 gametext 或 JSON，尝试作为旁白处理。");
                         newGameData = structuredClone(gameState);
                         newGameData.story.dialogue = newGameData.story.dialogue || [];
                         newGameData.story.dialogue.push({ speaker: "旁白", content: rawLLMResponse.trim(), style: "normal" });
                         newGameData.story.options = [];
                         messageToSave = `<gametext>${JSON.stringify(newGameData)}</gametext>`;
                    } else {
                        alert("处理失败：无法从回复中获取有效的游戏状态数据。");
                        newGameData = null;
                    }
                }

                if (newGameData) {
                    updateGameState(newGameData);
                    console.log("游戏状态和UI已更新。准备静默保存...");
                    if (typeof setChatMessage === 'function') {
                        await setChatMessage({ message: messageToSave }, 0, { refresh: 'none' });
                        console.log("静默保存完成。");
                    } else {
                        console.warn("setChatMessage 函数不可用，无法静默保存。");
                    }
                } else {
                    console.error("由于提取或解析失败，未能生成有效的 newGameData，跳过状态更新和保存。");
                }
                // --- (结束) ---

            } catch (error) {
                 console.error("处理剧情选项时发生顶层错误:", error);
                 alert(`处理选项时发生错误: ${error.message}\n请检查控制台。`);
            } finally {
                 hideLoadingIndicator();
                 enableInteractions();
                 if (buttonElement) buttonElement.style.backgroundColor = '';
                 console.log("selectStoryOption finally block executed.");
            }
        }
        
        async function selectCustomOption(customText, optionsListElement) {
            console.log(`玩家输入了自定义选项: ${customText}`);

            showLoadingIndicator("处理您的想法中...");
            disableInteractions();

            try {
                await toggleWorldBookEntries(['COT', '格式要求'], ['COT（chat）']);
                await autoSaveToWorldBook();

                // 获取故事总结上下文
                let summaryContext = "【最近的故事总结回顾】\n";
                const summaries = Array.isArray(gameState.storySummary) ? gameState.storySummary : [];
                if (summaries.length > 0) {
                    const recentSummaries = summaries.slice(-3);
                    summaryContext += recentSummaries.length > 0
                        ? recentSummaries.map(s => `${s.id}. ${s.content}`).join('\n')
                        : "暂无总结。";
                } else { summaryContext += "暂无总结。"; }
                summaryContext += "\n";

                // 构建注入的系统指令
                const systemInstruction = `--- CORE ACTION THIS TURN ---\n` +
                                         `**Player Character Action:** {{user}} decided based on their own thought:\n` +
                                         `**Action Text/Thought:** "${customText}"\n` +
                                         `**Instruction:** This decision/thought is the ABSOLUTE FOCUS for this turn's response. You MUST generate the narrative and game state update based *directly* on this specific action being taken *now*. Do NOT generate alternative plot progressions or ignore this action.\n\n` +
                                         `--- Execution Context & Guidelines ---\n` +
                                         `${summaryContext}\n` +
                                         `【<回复格式> 指令】\n` + // 引用外部的 CoT/回复格式
                                         `Please strictly follow the rules defined in \`<回复格式>\` (your CoT, Thinking Format v3.0). Specifically:\n` +
                                         `1. Narrative MUST show the Action Text/Thought above being acted upon immediately (or internal reaction if it's just a thought).\n`+
                                         `2. Depict realistic NPC reactions to *this specific decision*.\n` +
                                         `3. Calculate state changes (mood, affection, funds if applicable, chapter, next options) directly resulting from *this decision*.\n` +
                                         `4. Output ONLY the \`<gametext>\` containing the *complete* updated game state reflecting the consequences of this action.\n`;

                console.log("System Instruction for generate:", systemInstruction);

                // 调用 generate，将玩家自定义文本放入 user_input，指令放入 injects
                const rawLLMResponse = await generate({
                    user_input: customText, // 玩家的自定义输入作为 user_input
                    should_stream: false,
                    injects: [ // 其他上下文和指令放入 injects
                        {
                            role: 'system',
                            content: systemInstruction,
                            position: 'before_prompt',
                            depth: 0,
                            should_scan: false
                        }
                    ]
                    // max_chat_history: 'all'
                });

                console.log("收到 LLM 原始响应 (自定义选项):", rawLLMResponse);

                // --- (后续解析 gametext 和更新状态的逻辑不变) ---
                let newGameData = null;
                let messageToSave = rawLLMResponse;
                const extractedJsonString = extractGameText(rawLLMResponse);

                if (extractedJsonString) {
                    console.log("[解析阶段] 准备解析:", extractedJsonString);
                    try {
                        newGameData = JSON.parse(extractedJsonString);
                        messageToSave = `<gametext>${extractedJsonString}</gametext>`;
                        console.log("[解析阶段] JSON 解析成功。");
                    } catch (parseError) {
                        console.error("[解析阶段] JSON 解析失败:", parseError);
                        console.error("失败时尝试解析的字符串:", extractedJsonString);
                        alert(`解析游戏状态时出错: ${parseError.message}. LLM 可能返回了无效的格式。`);
                        newGameData = null;
                    }
                } else {
                    console.error("未能从 LLM 响应中提取有效的 <gametext>{...}</gametext> 块。");
                    if (rawLLMResponse && !rawLLMResponse.includes('<gametext>') && !rawLLMResponse.includes('{') && rawLLMResponse.trim().length > 5) {
                         console.warn("响应中无 gametext 或 JSON，尝试作为旁白处理。");
                         newGameData = structuredClone(gameState);
                         newGameData.story.dialogue = newGameData.story.dialogue || [];
                         newGameData.story.dialogue.push({ speaker: "旁白", content: rawLLMResponse.trim(), style: "normal" });
                         newGameData.story.options = [];
                         messageToSave = `<gametext>${JSON.stringify(newGameData)}</gametext>`;
                    } else {
                        alert("处理失败：无法从回复中获取有效的游戏状态数据。");
                        newGameData = null;
                    }
                }

                if (newGameData) {
                    updateGameState(newGameData);
                    console.log("游戏状态和UI已更新。准备静默保存...");
                    if (typeof setChatMessage === 'function') {
                         await setChatMessage({ message: messageToSave }, 0, { refresh: 'none' });
                         console.log("静默保存完成。");
                    } else {
                         console.warn("setChatMessage 函数不可用，无法静默保存。");
                    }
                } else {
                    console.error("由于提取或解析失败，未能生成有效的 newGameData，跳过状态更新和保存。");
                }
                // --- (结束) ---

            } catch (error) {
                 console.error("处理自定义选项时发生顶层错误:", error);
                 alert(`处理你的想法时发生错误: ${error.message}\n请检查控制台。`);
            } finally {
                 hideLoadingIndicator();
                 enableInteractions();
                 const submitBtn = document.getElementById('submitCustomOptionBtn');
                 if (submitBtn) submitBtn.innerHTML = '确定';
                 const customInput = document.getElementById('customOptionInput');
                 if (customInput) customInput.value = '';
                 console.log("selectCustomOption finally block executed.");
            }
        }
        function toggleOptionsPanel(show) {
            const optionsContainer = document.querySelector('.interaction-options');
            if (optionsContainer) {
                optionsContainer.style.display = show ? 'block' : 'none';
            }
        }

        // 【新增】显示历史记录模态框的函数
        async function showHistoryModal() {
            console.log('打开故事进展模态框...');
            showLoadingIndicator("加载历史记录..."); // 显示加载提示

            // 移除可能已存在的旧模态框
            const existingModal = document.getElementById('historyModal');
            if (existingModal) existingModal.remove();

            const modal = document.createElement('div');
            modal.id = 'historyModal';
            modal.className = 'chapter-modal';

            const modalContent = document.createElement('div');
            modalContent.className = 'chapter-modal-content';

            const modalHeader = document.createElement('div');
            modalHeader.className = 'chapter-modal-header';
            modalHeader.innerHTML = `
                <h3>故事进展</h3>
                <button class="close-btn close-history-modal">×</button>
            `;

            const modalBody = document.createElement('div');
            modalBody.className = 'chapter-modal-body';

            // --- 填充模态框内容 ---
             // 1. 添加当前章节标题
             if (gameState.story && gameState.story.currentChapter) {
                  const chapterTitleEl = document.createElement('div');
                  chapterTitleEl.className = 'chapter-title mb-3';
                  chapterTitleEl.innerHTML = `<h4>当前章节: ${gameState.story.currentChapter}</h4>`;
                  modalBody.appendChild(chapterTitleEl);
             }

            // 2. 添加对话历史记录
            const dialogueHistoryContainer = document.createElement('div');
            dialogueHistoryContainer.id = 'modal-dialogue-history';
            dialogueHistoryContainer.style.marginBottom = '2rem';
            dialogueHistoryContainer.style.maxHeight = '40vh'; // 限制对话历史高度
            dialogueHistoryContainer.style.overflowY = 'auto'; // 添加滚动条

            if (TextSystem.dialogueHistory && TextSystem.dialogueHistory.length > 0) {
                 // 只显示最近 N 条，例如 50 条，避免模态框过长
                 const recentHistory = TextSystem.dialogueHistory.slice(-50);
                recentHistory.forEach(item => {
                    const historyItem = document.createElement('div');
                    historyItem.className = 'history-item';
                    if (item.speaker === '旁白') {
                        historyItem.innerHTML = `<div class="history-text narrator">${item.content}</div>`;
                    } else {
                        historyItem.innerHTML = `<div class="history-text"><strong>${item.speaker}:</strong> ${item.content}</div>`;
                    }
                    dialogueHistoryContainer.appendChild(historyItem);
                });
            } else {
                dialogueHistoryContainer.innerHTML = '<p class="text-muted">暂无对话记录。</p>';
            }
            modalBody.appendChild(dialogueHistoryContainer);

             // 3. 添加章节列表容器（稍后由 displayChapterList 填充）
             const chapterListPlaceholder = document.createElement('div');
             chapterListPlaceholder.id = 'modal-chapter-list-placeholder';
             modalBody.appendChild(chapterListPlaceholder);


            // --- 组装模态框 ---
            modalContent.appendChild(modalHeader);
            modalContent.appendChild(modalBody);
            modal.appendChild(modalContent);

            // --- 添加关闭事件 ---
            const closeModal = () => { /* ... 保持不变 ... */
                const modalToClose = document.getElementById('historyModal');
                if (modalToClose) {
                    document.body.classList.remove('modal-open');
                    modalToClose.remove();
                     document.removeEventListener('keydown', handleEscKey); // 移除 ESC 监听
                }
            };
            modal.querySelectorAll('.close-history-modal').forEach(btn => btn.addEventListener('click', closeModal));
            modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(); });
            modalContent.addEventListener('click', e => e.stopPropagation());
            const handleEscKey = (e) => { if (e.key === 'Escape') closeModal(); };
            document.addEventListener('keydown', handleEscKey);

            // --- 显示模态框 ---
            document.body.classList.add('modal-open');
            document.body.appendChild(modal);

            // --- 异步加载章节列表 ---
            try {
                 if (typeof TextSystem.displayChapterList === 'function') {
                     console.log('正在加载章节列表到模态框...');
                      await TextSystem.displayChapterList("明星的诞生", chapterListPlaceholder); // 传入占位符容器
                 } else {
                      console.error("TextSystem.displayChapterList 函数未定义！");
                      chapterListPlaceholder.innerHTML = '<p class="text-danger">无法加载章节列表。</p>';
                 }
            } catch (error) {
                 console.error("加载章节列表时出错:", error);
                 chapterListPlaceholder.innerHTML = `<p class="text-danger">加载章节列表失败: ${error.message}</p>`;
            } finally {
                 hideLoadingIndicator(); // 隐藏加载提示
                  // 对话历史滚动到底部 (如果内容多的话)
                 dialogueHistoryContainer.scrollTop = dialogueHistoryContainer.scrollHeight;
            }
        }


        // --- Contact Page Functions ---
        function clearCurrentChat() {
            if (!currentContact) return;
            if (!confirm(`确定要清除与 ${currentContact} 的所有聊天记录吗？此操作不可恢复。`)) return;

            const contact = gameState.contacts.find(c => c.name === currentContact);
            if (!contact) return;

            contact.messages = [];
            contact.lastMessage = '';
            contact.lastTime = '';
            localStorage.removeItem(`chatHistory_${currentContact}`); // 清除本地存储
            window.gameStateChanged = true;

            renderChatContent(currentContact);
            DataSystem.UIUpdater.updateContactText(); // 更新列表预览
            console.log(`${currentContact} 的聊天记录已清除。`);
        }

        function switchContact(contactName) {
            console.log("切换联系人至:", contactName);
            if (!contactName) { // 处理切换到空联系人的情况
                 currentContact = "";
                 // 清空聊天区和资料区
                 renderChatContent(null);
                 renderProfile(null);
                  // 更新聊天头部
                 const chatTitleNameEl = document.getElementById('chat-title-name');
                 const chatHeaderAvatarEl = document.getElementById('chat-header-avatar');
                 if(chatTitleNameEl) chatTitleNameEl.textContent = '选择联系人';
                 if(chatHeaderAvatarEl) chatHeaderAvatarEl.style.display = 'none';
                  // 更新列表 active 状态
                 document.querySelectorAll('.contact-item').forEach(item => item.classList.remove('active'));
                 return;
            }

            const contact = gameState.contacts.find(c => c.name === contactName);
            if (!contact) {
                 console.error(`错误：找不到联系人 ${contactName}`);
                 return;
            }

            currentContact = contactName;

            // 更新列表 active 状态
            document.querySelectorAll('.contact-item').forEach(item => {
                item.classList.toggle('active', item.dataset.contact === contactName);
            });

            // 清除未读标记 (如果需要立即生效)
            if (contact.unread > 0) {
                 contact.unread = 0;
                 window.gameStateChanged = true; // 标记状态改变
                 DataSystem.UIUpdater.updateContactText(); // 立即更新列表 UI
            }

            // 更新聊天界面标题和头像
            const chatTitleNameEl = document.getElementById('chat-title-name');
             const chatHeaderAvatarEl = document.getElementById('chat-header-avatar');
             if(chatTitleNameEl) chatTitleNameEl.textContent = contactName;
             if(chatHeaderAvatarEl){
                  chatHeaderAvatarEl.src = contact.avatar || 'placeholder.png';
                  chatHeaderAvatarEl.alt = contactName;
                  chatHeaderAvatarEl.style.display = 'inline-block'; // 显示头像
                   chatHeaderAvatarEl.onerror = () => { chatHeaderAvatarEl.src = 'placeholder.png'; }; // 错误处理
             }

            // 渲染聊天记录和资料卡
            renderChatContent(contactName);
            renderProfile(contactName);
        }

        function renderChatContent(contactName) {
            const chatMessagesEl = document.getElementById('chatMessages');
            if (!chatMessagesEl) return;

             // 清空现有消息
             chatMessagesEl.innerHTML = '';

             if (!contactName) { // 没有选择联系人
                  chatMessagesEl.innerHTML = '<div class="message-system"><span>选择一个联系人开始聊天。</span></div>';
                  return;
             }

            const contact = gameState.contacts.find(c => c.name === contactName);
             if (!contact) {
                  chatMessagesEl.innerHTML = `<div class="message-system"><span>无法加载 ${contactName} 的聊天记录。</span></div>`;
                  return;
             }


            const messages = contact.messages || [];
            if (messages.length === 0) {
                chatMessagesEl.innerHTML = `<div class="message-system"><span>与 ${contactName} 开始新的对话吧！</span></div>`;
            } else {
                // 添加日期分隔符逻辑 (简化)
                let lastDateStr = '';
                messages.forEach(message => {
                     let messageDate = new Date(); // 默认今天
                     // 尝试从 message.time 解析日期，如果失败则忽略日期分隔
                     // (更可靠的方式是在保存消息时存储完整时间戳)
                     const currentDateStr = messageDate.toLocaleDateString();
                     if (currentDateStr !== lastDateStr) {
                          chatMessagesEl.innerHTML += `<div class="message-date"><span>${currentDateStr}</span></div>`;
                          lastDateStr = currentDateStr;
                     }

                     let messageHtml = '';
                     const timeStr = message.time || formatMessageTime(); // 确保有时间
                      // 确保 avatar 是有效的 URL 或 placeholder
                      const avatarSrc = (contact.avatar && typeof contact.avatar === 'string' && contact.avatar.length > 5) ? contact.avatar : 'placeholder.png';

                      switch (message.type) {
                          case 'system':
                               messageHtml = `<div class="message-system"><span>${message.content || ''}</span></div>`;
                               break;
                          case 'sent':
                               messageHtml = `
                                   <div class="chat-message sent">
                                       <div class="message-content">
                                           <div class="message-text">${message.content || ''}</div>
                                           <div class="message-time">${timeStr}</div>
                                       </div>
                                   </div>`;
                               break;
                          case 'received':
                          default:
                               // 确保 avatar 是有效的 URL 或 PLACEHOLDER_IMG (在这里再次确认)
                               const messageAvatarSrc = (avatarSrc && typeof avatarSrc === 'string' && avatarSrc.trim() !== '') ? avatarSrc : PLACEHOLDER_IMG; // 使用常量
                               messageHtml = `
                                   <div class="chat-message received">
                                       <img src="${messageAvatarSrc}" alt="${contact.name}" class="message-avatar" onerror="this.onerror=null; this.src=PLACEHOLDER_IMG;">
                                       <div class="message-content">
                                           <div class="message-text">${message.content || ''}</div>
                                           <div class="message-time">${timeStr}</div>
                                       </div>
                                   </div>`;
                               break;
                     }
                     chatMessagesEl.innerHTML += messageHtml;
                });
            }

            // 滚动到底部
             requestAnimationFrame(() => { // 延迟滚动确保 DOM 更新
                  chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
             });
        }

        function renderProfile(contactName) { // (保持之前的版本，已包含健壮性检查)
            const memberProfileEl = document.getElementById('memberProfile');
            if (!memberProfileEl) return;

            if (!contactName) { // 处理未选择联系人的情况
                 memberProfileEl.innerHTML = `<div class="empty-profile"><i class="fas fa-user fa-3x"></i><p>选择一个联系人查看详细资料</p></div>`;
                 return;
            }

            const contact = gameState.contacts.find(c => c.name === contactName);
            if (!contact || contact.isGroup) {
                 memberProfileEl.innerHTML = `<div class="empty-profile"><i class="fas ${contact?.isGroup ? 'fa-users' : 'fa-user'} fa-3x"></i><p>${contact?.isGroup ? '群聊信息' : '无法加载该联系人资料'}</p></div>`;
                 return;
            }

            // 获取角色数据 (优先 CharacterSystem, 再 gameState.team.members, 最后 gameState.contacts)
            const character = CharacterSystem.getCharacter(contact.id);
            const teamMember = gameState.team?.members?.find(m => m.id === contact.id || m.name === contactName); // 增加 name 匹配
            const profileData = character || teamMember || contact; // 合并数据源

            // 处理技能 stats (确保存在且为数字)
            const skills = profileData.stats || profileData.skills || {};
            const getSkill = (key) => (skills[key] !== undefined && !isNaN(Number(skills[key]))) ? Number(skills[key]) : 'N/A';

            const tags = Array.isArray(profileData.tags) ? profileData.tags : [];
            const mood = profileData.mood !== undefined ? profileData.mood : 50;
            const affection = profileData.affection !== undefined ? profileData.affection : 0;
             // 确保 avatar 是有效的 URL 或 PLACEHOLDER_IMG
             const avatarSrc = (profileData.avatar && typeof profileData.avatar === 'string' && profileData.avatar.trim() !== '') ? profileData.avatar : PLACEHOLDER_IMG; // 使用常量


            memberProfileEl.innerHTML = `
                <div class="profile-header">
                    <div class="avatar-container position-relative">
                       <img src="${avatarSrc}" alt="${contactName}" class="profile-avatar" onerror="this.onerror=null; this.src=PLACEHOLDER_IMG;">
                        <button class="btn btn-sm btn-primary position-absolute bottom-0 end-0" id="changeAvatarBtn" style="border-radius: 50%; width: 32px; height: 32px; padding: 0; margin: 0 5px 5px 0;"><i class="fas fa-camera"></i></button>
                        <input type="file" id="avatarFileInput" style="display:none" accept="image/*">
                    </div>
                    <h3>${profileData.fullName || contactName}</h3>
                    <p class="text-muted">${profileData.role || '成员'}</p>
                    <div class="profile-tags">${tags.map(tag => `<span class="tag">${tag}</span>`).join('')}</div>
                </div>
                <div class="profile-stats">
                    <div class="stat-item"><div class="stat-value">${getSkill('vocal')}</div><div class="stat-label">声乐</div></div>
                    <div class="stat-item"><div class="stat-value">${getSkill('dance')}</div><div class="stat-label">舞蹈</div></div>
                    <div class="stat-item"><div class="stat-value">${getSkill('performance')}</div><div class="stat-label">表演</div></div>
                    <div class="stat-item"><div class="stat-value">${getSkill('charm')}</div><div class="stat-label">魅力</div></div>
                    <div class="stat-item"><div class="stat-value">${getSkill('variety')}</div><div class="stat-label">综艺感</div></div>
                </div>
                <div class="profile-stats mt-3">
                    <div class="stat-item"><div class="stat-value" style="color: #ff6b6b;">${mood}</div><div class="stat-label">心情值</div></div>
                    <div class="stat-item"><div class="stat-value" style="color: #ff4081;">${affection}</div><div class="stat-label">好感度</div></div>
                </div>
                <div class="profile-info">
                    ${profileData.bio ? `<h4>个人简介</h4><p>${profileData.bio}</p>` : ''}
                    ${profileData.profile ? `<h4>详细资料</h4><p>${profileData.profile.replace(/\n/g, '<br>')}</p>` : ''}
                    ${profileData.interests ? `<h4>兴趣爱好</h4><p>${profileData.interests}</p>` : ''}
                    ${profileData.relationships ? `<h4>关系</h4><p>${profileData.relationships}</p>` : ''}
                    ${profileData.recentStatus ? `<h4>最近状态</h4><p>${profileData.recentStatus}</p>` : ''}
                </div>
            `;

             // 绑定头像上传事件 (保持不变)
            const changeAvatarBtn = document.getElementById('changeAvatarBtn');
            const avatarFileInput = document.getElementById('avatarFileInput');
             if (changeAvatarBtn && avatarFileInput) { /* ... 事件绑定逻辑 ... */
                 changeAvatarBtn.addEventListener('click', () => avatarFileInput.click());
                 avatarFileInput.addEventListener('change', (e) => {
                      if (e.target.files && e.target.files[0]) {
                           const file = e.target.files[0];
                           const reader = new FileReader();
                           reader.onload = (event) => {
                                const avatarDataUrl = event.target.result;
                                updateCharacterAvatar(contact.id, avatarDataUrl); // 更新数据和存储
                                const profileAvatar = memberProfileEl.querySelector('.profile-avatar');
                                if (profileAvatar) profileAvatar.src = avatarDataUrl; // 更新当前显示
                                alert('头像更新成功！');
                           };
                           reader.readAsDataURL(file);
                           avatarFileInput.value = ''; // 清空，允许再次选择同个文件
                      }
                 });
             }
        }

           // 【注意】这是完整的 sendMessage 函数，请替换掉你原来的整个函数
             // 【最终修正版 v3 - sendMessage - 修正 generate 调用前的检查】
                    // 【最终修正版 v5 - sendMessage - 精确使用 Overrides 和 Injects】
        async function sendMessage() {
            const messageInput = document.getElementById('messageInput');
            const content = messageInput.value.trim(); // 玩家的输入
            const contactName = currentContact;

            if (!content || !contactName) return;

            const contact = gameState.contacts.find(c => c.name === contactName);
            if (!contact || contact.isGroup) {
                alert(contact?.isGroup ? "暂不支持向群组发送消息。" : "请先选择一个联系人。");
                return;
            }

            // === 用户消息处理和UI更新 (不变) ===
            const timeStr = formatMessageTime();
            const userMessage = { type: 'sent', content: content, time: timeStr };
            if (!contact.messages) { contact.messages = []; }
            contact.messages.push(userMessage);
            contact.lastMessage = `你: ${content}`;
            contact.lastTime = timeStr;
            window.gameStateChanged = true;
            saveChatHistory(contactName, contact.messages);
            renderChatContent(contactName); // 显示用户消息
            DataSystem.UIUpdater.updateContactText();
            messageInput.value = '';
            // === 结束 ===

            showLoadingIndicator("等待回复中...");
            disableInteractions();
            const placeholderId = `ai-response-${Date.now()}`;
            const chatMessagesEl = document.getElementById('chatMessages');
            let streamListener = null;
            let endListener = null;
            let accumulatedResponse = "";

            try {
                // 切换世界书（如果需要，聊天 CoT 可能通过 WI 设置更佳）
                // await toggleWorldBookEntries(['COT（chat）'], ['COT', '格式要求']);

                // === 构建 generate 函数的配置 ===

                // 1. 准备 Overrides (覆盖默认提示词内容)
                const overrides = {};
                //   a. 获取角色详情 (可选，放入 char_description 或 personality?)
                let charDescOverride = ""; // 可以尝试将角色详情放入描述
                let charPersonalityOverride = contact.personality || ""; // 明确性格
                try {
                    const lorebookName = "明星的诞生";
                    const targetCommentBase = `成员${contactName}的详细信息`;
                    const targetCommentNormalized = targetCommentBase.replace(/\s+/g, '').toLowerCase();
                    if (typeof getLorebookEntries === 'function') {
                        const allEntries = await getLorebookEntries(lorebookName);
                        const foundEntry = allEntries?.find(entry => entry?.comment?.replace(/\s+/g, '').toLowerCase() === targetCommentNormalized);
                        if (foundEntry?.content) {
                            // 可以将提取的详情放入描述，或者只用性格字段
                            // charDescOverride = parseEntryContent(foundEntry.content); // 可能太长，放入描述不合适
                            console.log("获取到角色详情，将用于可能的覆盖。");
                            // 可以在这里提取更精简的信息覆盖性格等
                        }
                    }
                } catch (loreError) { console.error(`获取角色详情 (${contactName}) 出错:`, loreError); }
                if (charPersonalityOverride) {
                    overrides.char_personality = charPersonalityOverride; // 覆盖性格
                }
                // if (charDescOverride) { overrides.char_description = charDescOverride; } // 谨慎使用

                //   b. 获取团队信息 (可选，放入 scenario?)
                let npcNationality = contact.nationality || '未知';
                let eraInfo = '未知';
                try {
                    const worldBookName = "明星的诞生";
                    const teamInfoRegex = /团队.*详细信息/i;
                    if (typeof getLorebookEntries === 'function') {
                        const allEntries = await getLorebookEntries(worldBookName);
                        const teamEntry = allEntries?.find(entry => entry?.comment && teamInfoRegex.test(entry.comment));
                        if (teamEntry?.content) {
                            // ... 提取 npcNationality 和 eraInfo ...
                            // 可以考虑将时代背景放入场景描述
                            // overrides.scenario = `当前场景设定在 ${eraInfo} 年的 ${npcNationality}。${gameState.story.location || ''}`;
                        }
                    }
                } catch (teamLoreError) { console.error("获取团队信息出错:", teamLoreError); }

                //   c. 构建聊天历史 (可能不需要覆盖，除非要完全自定义)
                // const historyLimit = 3;
                // const recentMessages = ...;
                // const historyPrompts = recentMessages.map(msg => ({
                //     role: msg.type === 'sent' ? 'user' : 'assistant',
                //     content: msg.content
                // }));
                // overrides.chat_history = { prompts: historyPrompts }; // 如果要完全覆盖历史记录

                // 2. 准备 Injects (注入额外的系统指令和状态)
                const injections = [];

                //   a. 注入 NPC 当前状态
                let npcStateText = "【NPC 当前状态】\n";
                const currentMood = contact.mood;
                const currentAffection = contact.affection;
                npcStateText += `- 心情: ${currentMood !== undefined && currentMood !== null ? currentMood : '未知'}\n`;
                npcStateText += `- 好感度: ${currentAffection !== undefined && currentAffection !== null ? currentAffection : '未知'}\n`;
                // 将国籍和时代作为状态注入
                npcStateText += `- 国籍背景: ${npcNationality}\n`;
                npcStateText += `- 所处时代: ${eraInfo}\n`;
                injections.push({
                    role: 'system',
                    content: npcStateText,
                    position: 'in_chat', // 尝试注入到聊天记录中（或 before_prompt）
                    depth: 0, // 或者一个较高的深度，让它靠近用户输入
                    should_scan: false
                });

                //   b. 注入核心回复指令 (引用外部 CoT)
                const coreInstructionText = `--- Instruction ---\n`+
                                           `You MUST generate a relevant reply for "${contactName}" based on the LAST user message in the chat history.\n`+
                                           `Consider the NPC's status (Mood, Affection, Background, Era) provided above.\n`+
                                           `Strictly follow the rules defined in the external \`<回复格式>\` prompt.\n`+ // 明确引用外部格式
                                           `Output ONLY the NPC's reply text enclosed within \`<message1>\` tags.`;
                injections.push({
                    role: 'system',
                    content: coreInstructionText,
                    position: 'before_prompt', // 放在最前面强调
                    depth: 0,
                    should_scan: false
                });

                // === 结束构建配置 ===

                // 添加占位符 (不变)
                const avatarSrc = (contact.avatar && typeof contact.avatar === 'string' && contact.avatar.length > 5) ? contact.avatar : 'placeholder.png';
                const placeholderHtml = `<div id="${placeholderId}" class="chat-message received ai-typing"><img src="${avatarSrc}" alt="${contactName}" class="message-avatar" onerror="this.onerror=null; this.src=PLACEHOLDER_IMG;"><div class="message-content"><div class="message-text"><i>${contactName} 正在输入...</i></div><div class="message-time"></div></div></div>`;
                if (chatMessagesEl) {
                     chatMessagesEl.insertAdjacentHTML('beforeend', placeholderHtml);
                     chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
                } else { throw new Error("聊天消息容器不存在。"); }

                // 处理流式响应 (监听器定义不变)
                accumulatedResponse = "";
                streamListener = (incrementalText) => { /* ... */ };
                endListener = (finalText) => { /* ... */ };

                // 注册监听器并调用 generate
                if (typeof eventOn !== 'function' || typeof eventOnce !== 'function' || typeof iframe_events !== 'object' || typeof generate !== 'function' || typeof eventRemoveListener !== 'function') {
                     throw new Error("聊天所需的部分 API 函数未定义或不可用。");
                }
                eventOn(iframe_events.STREAM_TOKEN_RECEIVED_INCREMENTALLY, streamListener);
                eventOnce(iframe_events.GENERATION_ENDED, endListener);

                 console.log("Calling generate with config:", {
                     user_input: content,
                     should_stream: true,
                     overrides: overrides, // 传入覆盖对象
                     injects: injections,   // 传入注入对象
                     // max_chat_history: 3 // 可以设置历史记录长度，让 generate 自动处理
                 });

                // 【修改】调用 generate 时传入 overrides 和 injects
                await generate({
                    user_input: content,        // 玩家的聊天消息
                    should_stream: true,
                    overrides: overrides,       // 使用 overrides 覆盖标准字段
                    injects: injections,        // 使用 injects 注入额外指令和状态
                    max_chat_history: 3         // 让 generate 自动处理最近3条历史记录
                                               // （这样就不需要在 injects 里手动加 chatHistoryText 了）
                });
                console.log("generate 函数调用已发起 (聊天)。");

            } catch (error) {
                console.error("调用 LLM 或处理回复时出错 (聊天):", error);
                // ... (错误处理和清理逻辑不变) ...
                 const placeholderElement = document.getElementById(placeholderId);
                 if (placeholderElement) { placeholderElement.remove(); }
                 const errorMsgHtml = `<div class="message-system"><span>抱歉，${contactName} 现在无法回复。(错误: ${error.message || '未知错误'})</span></div>`;
                 if (chatMessagesEl) { chatMessagesEl.insertAdjacentHTML('beforeend', errorMsgHtml); chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight; }
                 if (streamListener && typeof eventRemoveListener === 'function') { eventRemoveListener(iframe_events.STREAM_TOKEN_RECEIVED_INCREMENTALLY, streamListener); }
                 hideLoadingIndicator();
                 enableInteractions();
            } finally {
                 // 注意：endListener 的 finally 块负责大部分清理工作
                 console.log("sendMessage try-catch-finally finished.");
            }
        }

        function searchContacts() {
            const contactSearchInput = document.getElementById('contactSearchInput');
             if (!contactSearchInput) return;
             const query = contactSearchInput.value.trim().toLowerCase();
             const contactListEl = document.getElementById('contactList');
             if (!contactListEl) return;
             const contactItems = contactListEl.querySelectorAll('.contact-item');

             contactItems.forEach(item => {
                  const nameElement = item.querySelector('.contact-name');
                  const name = nameElement ? nameElement.textContent.toLowerCase() : '';
                  item.style.display = name.includes(query) ? 'flex' : 'none';
             });
        }

        function toggleProfileDisplay() {
             const memberProfileEl = document.getElementById('memberProfile');
             if (memberProfileEl) {
                  const isHidden = memberProfileEl.style.display === 'none';
                  memberProfileEl.style.display = isHidden ? 'block' : 'none';
                  if (isHidden) {
                       renderProfile(currentContact); // 显示时刷新内容
                  }
             }
        }

        // --- Team Page Functions ---
        function handleMemberCardClick(memberIdOrName) {
            console.log(`点击了成员卡片: ${memberIdOrName}`);
             // 查找成员数据
             const member = CharacterSystem.getCharacter(memberIdOrName) || CharacterSystem.getCharacterByName(memberIdOrName);
             if (member) {
                 // 切换到联系人页面并选中该成员
                 switchPage('contact'); // 确保调用全局切换函数
                 // 需要一点延迟确保联系人列表渲染完成
                  setTimeout(() => {
                      switchContact(member.name); // 切换到对应联系人
                  }, 100); // 100ms 延迟应该足够
             } else {
                  alert("找不到该成员的详细信息。");
             }
        }

        // --- Plan Page Functions ---
        const taskTagLabels = { 'short-term': '短期', 'long-term': '长期', 'personal-bond': '羁绊', 'training': '培训', 'song':'声乐','dance': '舞蹈', 'vocal': '声乐', 'fan-service': '粉丝营业', 'performance': '表演', 'other': '其他' };
        const priorityLabels = { 'high': '高', 'medium': '中', 'low': '低' };
        const statusLabels = { 'todo': '待处理', 'inprogress': '进行中', 'completed': '已完成' };

        function filterTasks(filterType) {
             currentFilter = filterType;
             const filterButtonsContainer = document.querySelector('.filter-buttons');
             if (filterButtonsContainer) {
                  filterButtonsContainer.querySelectorAll('.filter-btn').forEach(btn => {
                       btn.classList.toggle('active', btn.dataset.filter === filterType);
                  });
             }
             searchTasks(); // 应用过滤和搜索
        }

        function renderTaskList() {
             const taskBoard = document.getElementById('taskBoard');
             if (!taskBoard) return;
              console.log("渲染任务列表...");

             const planData = gameState.plan || [];
             // 按状态分组
             const groupedTasks = planData.reduce((acc, task) => {
                  const status = task.status || 'todo'; // 默认待处理
                  if (!acc[status]) acc[status] = [];
                   // 获取成员信息
                   const members = Array.isArray(task.memberIds)
                        ? task.memberIds.map(id => CharacterSystem.getCharacter(id)).filter(Boolean)
                        : [];
                  acc[status].push({ ...task, members });
                  return acc;
             }, { todo: [], inprogress: [], completed: [] }); // 初始化所有状态

             // 渲染每个状态列表
             Object.keys(groupedTasks).forEach(status => {
                  const taskList = taskBoard.querySelector(`.task-list[data-status="${status}"]`);
                  if (taskList) {
                       if (groupedTasks[status].length > 0) {
                            taskList.innerHTML = groupedTasks[status].map(task => {
                                  if (!task || !task.title) return ''; // 跳过无效任务
                                   const tags = Array.isArray(task.tags) ? task.tags : [];
                                   const priority = task.priority || 'medium';
                                   const deadline = task.deadline || '无期限';
                                    // 确保 avatar 是有效的 URL 或 PLACEHOLDER_IMG
                                   const memberAvatarsHtml = (task.members || []).map(member => {
                                        const avatarSrc = (member?.avatar && typeof member.avatar === 'string' && member.avatar.trim() !== '') ? member.avatar : PLACEHOLDER_IMG; // 使用常量
                                        return `<span class="member-avatar" title="${member?.name || '未知成员'}"><img src="${avatarSrc}" alt="${member?.name || ''}" onerror="this.onerror=null; this.src=PLACEHOLDER_IMG;"></span>`;
                                    }).join('');


                                  return `
                                  <div class="task-card ${tags.join(' ')} ${task.status || 'todo'}">
                                      <div class="task-header">
                                          ${tags.map(tag => `<span class="task-tag ${tag}">${taskTagLabels[tag] || tag}</span>`).join('')}
                                          <div class="task-priority ${priority}">${priorityLabels[priority] || priority}</div>
                                      </div>
                                      <div class="task-title">${task.title}</div>
                                      <div class="task-description">${task.description || ''}</div>
                                      <div class="task-footer">
                                          <div class="task-deadline"><i class="far fa-calendar-alt"></i> ${deadline}</div>
                                          <div class="task-members">${memberAvatarsHtml}</div>
                                      </div>
                                  </div>
                                  `;
                             }).join('');
                       } else {
                            taskList.innerHTML = `<p class="text-center text-muted small p-3">暂无${statusLabels[status] || status}任务</p>`;
                       }
                  }
             });
              updateTaskCounts(); // 更新计数
              filterTasks(currentFilter); // 应用当前过滤器
              console.log("任务列表渲染完成。");
        }

        function updateTaskCounts() {
            const taskBoardEl = document.getElementById('taskBoard');
            if (!taskBoardEl) return;
            const statuses = ['todo', 'inprogress', 'completed'];
            statuses.forEach(status => {
                const countElement = taskBoardEl.querySelector(`.task-column .task-count[data-status="${status}"]`);
                const taskList = taskBoardEl.querySelector(`.task-list[data-status="${status}"]`);
                 if (countElement && taskList) {
                      const visibleTasks = taskList.querySelectorAll('.task-card:not(.hidden-task)');
                      countElement.textContent = visibleTasks.length;
                 }
            });
        }

        function searchTasks() {
             const taskBoardEl = document.getElementById('taskBoard');
             if (!taskBoardEl) return;
             const taskSearchInput = document.getElementById('taskSearchInput');
              if (!taskSearchInput) return;
             const query = taskSearchInput.value.trim().toLowerCase();
             const taskCards = taskBoardEl.querySelectorAll('.task-card');

             taskCards.forEach(card => {
                  const title = card.querySelector('.task-title')?.textContent.toLowerCase() || '';
                  const description = card.querySelector('.task-description')?.textContent.toLowerCase() || '';
                   const tags = Array.from(card.classList).filter(cls => cls !== 'task-card' && cls !== 'hidden-task').map(tag => (taskTagLabels[tag] || tag).toLowerCase());
                   const priority = (priorityLabels[card.querySelector('.task-priority')?.classList[1]] || '').toLowerCase();

                   const matchesSearch = title.includes(query) || description.includes(query) || tags.some(t => t.includes(query)) || priority.includes(query);
                  let matchesFilter = (currentFilter === 'all');
                  if (!matchesFilter) {
                       matchesFilter = card.classList.contains(currentFilter);
                  }

                  card.classList.toggle('hidden-task', !(matchesSearch && matchesFilter));
             });
             updateTaskCounts(); // 搜索后更新计数
        }


        // --- Song Page Functions ---
        function renderSongOptions() {
             const mainVocalSelection = document.getElementById('mainVocalSelection');
             const subVocalSelection = document.getElementById('subVocalSelection');
             const songMembers = CharacterSystem.getSongMembersData(); // 获取歌手数据

             if (mainVocalSelection) {
                 mainVocalSelection.innerHTML = songMembers.length > 0 ? songMembers.map(member => {
                      if (!member || !member.name) return '';
                       // 确保 avatar 是有效的 URL 或 PLACEHOLDER_IMG
                       const avatarSrc = (member.avatar && typeof member.avatar === 'string' && member.avatar.trim() !== '') ? member.avatar : PLACEHOLDER_IMG; // 使用常量
                      return `
                      <div class="member-select-item" data-member="${member.name}" data-id="${member.id}">
                          <img src="${avatarSrc}" alt="${member.name}" onerror="this.onerror=null; this.src=PLACEHOLDER_IMG;">
                          <span class="member-name">${member.name}</span>
                          <div class="member-skill">声乐: ${member.skill}%</div>
                      </div>`;
                 }).join('') : '<p class="text-muted small">暂无可用成员</p>';
             }
             if (subVocalSelection) {
                  subVocalSelection.innerHTML = songMembers.length > 0 ? songMembers.map(member => {
                      if (!member || !member.name) return '';
                       // 确保 avatar 是有效的 URL 或 PLACEHOLDER_IMG
                       const avatarSrc = (member.avatar && typeof member.avatar === 'string' && member.avatar.trim() !== '') ? member.avatar : PLACEHOLDER_IMG; // 使用常量
                      return `
                       <div class="member-select-item" data-member="${member.name}" data-id="${member.id}">
                           <img src="${avatarSrc}" alt="${member.name}" onerror="this.onerror=null; this.src=PLACEHOLDER_IMG;">
                           <span class="member-name">${member.name}</span>
                           <div class="member-skill">声乐: ${member.skill}%</div>
                       </div>`;
                  }).join('') : '<p class="text-muted small">暂无可用成员</p>';
             }

             // 更新制作团队选择
             const productionTeams = gameState.song?.productionTeams || {};
             const renderTeamSelect = (selectId, teamArray) => {
                  const select = document.getElementById(selectId);
                  if (select) {
                       if (teamArray && Array.isArray(teamArray) && teamArray.length > 0) {
                            select.innerHTML = '<option value="">请选择...</option>' + teamArray.map(item => {
                                 if (!item || !item.name) return '';
                                  const cost = item.cost !== undefined ? parseInt(item.cost) || 0 : 0;
                                 return `<option value="${item.name}" data-cost="${cost}">${item.name} - ${formatCurrency(cost)} (${item.experience || '经验未知'})</option>`;
                            }).join('');
                       } else {
                            select.innerHTML = '<option value="">无可用选项</option>';
                       }
                  }
             };
             renderTeamSelect('composer', productionTeams.composers);
             renderTeamSelect('lyricist', productionTeams.lyricists);
             renderTeamSelect('arranger', productionTeams.arrangers);
             renderTeamSelect('mvDirector', productionTeams.mvDirectors);
        }

        function selectSongStyle(clickedCard) { // 这个函数似乎没被使用，因为改成了 select
             // 如果需要用卡片选择，逻辑应类似 selectSongMember
             console.warn("selectSongStyle 被调用，但可能已废弃。");
        }

        function selectSongMember(clickedItem) {
            if (!clickedItem) return;
            const container = clickedItem.closest('.member-selection');
            if (!container) return;
            if (container.classList.contains('multiple')) {
                clickedItem.classList.toggle('selected');
            } else {
                container.querySelectorAll('.member-select-item').forEach(item => item.classList.remove('selected'));
                clickedItem.classList.add('selected');
            }
            updateSongSummary(); // 选择后更新摘要
        }

        function updateSongSummary() {
            console.log("更新歌曲摘要...");
            let totalCost = 0;
            const summary = { theme: 'N/A', style: 'N/A', mainVocal: 'N/A', profit: '★★★☆☆', duration: '4-6周' };
            const budgetData = {};
             const budgetLabels = { composer: "作曲", lyricist: "作词", arranger: "编曲", recording: "录音", mv: "MV制作", total: "总计" };

             // 获取并计算成本
             const getSelectedCost = (selectId) => {
                  const select = document.getElementById(selectId);
                   const selectedOption = select ? select.options[select.selectedIndex] : null;
                   const cost = selectedOption ? parseInt(selectedOption.dataset.cost || 0) : 0;
                   const name = selectedOption ? selectedOption.text.split('-')[0].trim() : '未选择';
                   return { cost, name };
             };

             const composerInfo = getSelectedCost('composer');
             budgetData.composer = `${formatCurrency(composerInfo.cost)} (${composerInfo.name})`;
             totalCost += composerInfo.cost;

             const lyricistInfo = getSelectedCost('lyricist');
             budgetData.lyricist = `${formatCurrency(lyricistInfo.cost)} (${lyricistInfo.name})`;
             totalCost += lyricistInfo.cost;

             const arrangerInfo = getSelectedCost('arranger');
             budgetData.arranger = `${formatCurrency(arrangerInfo.cost)} (${arrangerInfo.name})`;
             totalCost += arrangerInfo.cost;

             const recordingCost = 8000; // 固定成本
             budgetData.recording = formatCurrency(recordingCost);
             totalCost += recordingCost;

             const mvInfo = getSelectedCost('mvDirector');
             budgetData.mv = `${formatCurrency(mvInfo.cost)} (${mvInfo.name})`;
             totalCost += mvInfo.cost;

             budgetData.total = formatCurrency(totalCost);

            // 更新预算表
            const budgetItemsEl = document.getElementById('budgetItems');
            if(budgetItemsEl) {
                 if (totalCost > 0 || composerInfo.cost > 0 || lyricistInfo.cost > 0 || arrangerInfo.cost > 0 || mvInfo.cost > 0) {
                     budgetItemsEl.innerHTML = Object.entries(budgetData).map(([key, value])=>`
                         <div class="budget-item ${key === 'total' ? 'total' : ''}">
                             <div class="item-name">${budgetLabels[key] || key}</div>
                             <div class="item-value" data-budget="${key}">${value}</div>
                         </div>`).join('');
                 } else {
                      budgetItemsEl.innerHTML = '<p class="text-muted small p-2">请选择制作团队以计算预算</p>';
                 }
            }

            // 更新预览信息
             const themeSelect = document.getElementById('songTheme');
             summary.theme = themeSelect ? (themeSelect.value === 'custom' ? (document.getElementById('customTheme')?.value || '自定义') : (themeSelect.options[themeSelect.selectedIndex]?.text || 'N/A')) : 'N/A';

            const styleSelect = document.getElementById('songStyle'); // 使用 Select
            summary.style = styleSelect ? (styleSelect.options[styleSelect.selectedIndex]?.text || 'N/A') : 'N/A';

            const mainVocalSelection = document.getElementById('mainVocalSelection');
            const selectedMainVocal = mainVocalSelection?.querySelector('.member-select-item.selected');
            summary.mainVocal = selectedMainVocal ? selectedMainVocal.dataset.member : '未选择';

            // 简单估算逻辑 (保持不变)
            let profitScore = 3;
            if (composerInfo.cost > 20000 || lyricistInfo.cost > 10000 || arrangerInfo.cost > 15000) profitScore++;
            if (mvInfo.cost > 100000) profitScore++;
            // if (summary.style === '电子流行' || summary.style === 'R&B流行') profitScore++; // 基于文本判断可能不准
            // if (['青春奋斗', '梦想追逐'].includes(summary.theme)) profitScore++;
            profitScore = Math.max(1, Math.min(5, profitScore)); // 确保在 1-5 星
            summary.profit = '★'.repeat(profitScore) + '☆'.repeat(5 - profitScore);

            let durationWeeks = 4;
            if (composerInfo.cost > 0) durationWeeks += 1;
            if (lyricistInfo.cost > 0) durationWeeks += 0.5;
            if (arrangerInfo.cost > 0) durationWeeks += 1;
            if (mvInfo.cost > 0) durationWeeks += 2;
            summary.duration = `${Math.ceil(durationWeeks)}-${Math.ceil(durationWeeks + 2)}周`;

            // 预览项目标签中文化
            const previewLabels = { theme: "主题", style: "风格", mainVocal: "主唱", profit: "收益预测", duration: "制作周期" };

            // 更新预览表
            const previewItemsEl = document.getElementById('previewItems');
            if (previewItemsEl) {
                 if (summary.style !== 'N/A' && summary.mainVocal !== '未选择') {
                     previewItemsEl.innerHTML = Object.entries(summary).map(([key, value]) => `
                         <div class="preview-item">
                             <div class="item-label">${previewLabels[key] || key}:</div>
                             <div class="item-value" data-preview="${key}">${value}</div>
                         </div>`).join('');
                 } else {
                      previewItemsEl.innerHTML = '<p class="text-muted small p-2">请选择风格和主唱以生成预览</p>';
                 }
            }
             console.log("歌曲摘要更新完成。");
        }

        // --- Training Page Functions ---
        function updateTrainingStats() {
             const trainingFansStatEl = document.getElementById('training-fans-stat');
             const trainingFundsStatEl = document.getElementById('training-funds-stat');
             const trainingPopStatEl = document.getElementById('training-popularity-stat');

             if (trainingFansStatEl) trainingFansStatEl.textContent = formatNumber(gameState.team?.basicInfo?.fans || 0);
             if (trainingFundsStatEl) trainingFundsStatEl.textContent = formatCurrency(gameState.story?.currentFunds || 0);
             if (trainingPopStatEl) trainingPopStatEl.textContent = formatNumber(gameState.team?.basicInfo?.popularity || 0); // 假设有 popularity
        }

        async function startTraining(buttonElement) {
            const btn = buttonElement;
            if (!btn || btn.disabled) return;

            const cost = parseInt(btn.dataset.cost || 0);
            const trainingType = btn.dataset.type;
            const card = btn.closest('.training-card');
            const trainingTitle = card?.querySelector('.training-title')?.textContent || trainingType || '未知训练';
            const costText = formatCurrency(cost); // 用于 Prompt

            console.log(`玩家触发了 ${trainingTitle} (预期花费 ${costText})`);

            showLoadingIndicator("处理训练中...");
            disableInteractions();
            if(card) card.classList.add('training-in-progress');

            try {
                await toggleWorldBookEntries(['COT', '格式要求'], ['COT（chat）']);
                await autoSaveToWorldBook();

                // 获取故事总结上下文
                let summaryContext = "\n\n【最近的故事总结回顾】\n";
                const summaries = Array.isArray(gameState.storySummary) ? gameState.storySummary : [];
                if (summaries.length > 0) {
                    const recentSummaries = summaries.slice(-3);
                    summaryContext += recentSummaries.length > 0 ? recentSummaries.map(s => `${s.id}. ${s.content}`).join('\n') : "暂无总结。";
                } else { summaryContext += "暂无总结。"; }
                summaryContext += "\n";

                // 【修改】构建注入的系统指令
                const systemInstruction = `--- CORE ACTION THIS TURN ---\n` +
                                        `**Player Character Action:** {{user}} initiated a training session:\n` +
                                        `**Action Detail:** ${trainingTitle} (Expected Cost: ${costText})\n` + // 清晰描述动作
                                        `**Instruction:** This training initiation is the ABSOLUTE FOCUS. You MUST process this request:\n` +
                                        `1. Check if conditions are met (e.g., sufficient funds: ${cost}).\n` +
                                        `2. If met, update the game state (deduct funds, increase relevant stats moderately for the team/relevant members based on '${trainingType}', potentially adjust mood).\n` +
                                        `3. Generate narrative describing the *start* or *immediate effect* of the training.\n` +
                                        `4. Output ONLY the \`<gametext>\` containing the *complete* updated game state (or reflecting the failure if conditions unmet).\n\n` +
                                        `--- Execution Context & Guidelines ---\n` +
                                        `${summaryContext}\n` +
                                        `【<回复格式> 指令】\n` + // 引用外部的 CoT/回复格式
                                        `Please strictly follow the rules defined in \`<回复格式>\` (your CoT, Thinking Format v3.0).\n`;

                console.log("System Instruction for generate:", systemInstruction);

                // 【修改】调用 generate
                const rawLLMResponse = await generate({
                    user_input: `开始进行 ${trainingTitle}`, // <--- 简化的用户意图作为 user_input
                    should_stream: false,
                    injects: [
                        {
                            role: 'system',
                            content: systemInstruction,
                            position: 'before_prompt',
                            depth: 0,
                            should_scan: false
                        }
                    ]
                    // max_chat_history: 0 // 训练通常不需要聊天历史
                });

                console.log("收到 LLM 原始响应 (训练事件):", rawLLMResponse);

                // --- (后续解析 gametext 和更新状态的逻辑不变) ---
                let newGameData = null;
                let messageToSave = rawLLMResponse;
                const extractedJsonString = extractGameText(rawLLMResponse);

                if (extractedJsonString) {
                    console.log("[解析阶段] 准备解析:", extractedJsonString);
                    try {
                        newGameData = JSON.parse(extractedJsonString);
                        messageToSave = `<gametext>${extractedJsonString}</gametext>`;
                        console.log("[解析阶段] JSON 解析成功。");
                        // 检查是否有提示信息 (如资金不足)
                        const newDialogue = newGameData.story?.dialogue;
                        if (Array.isArray(newDialogue) && newDialogue.length > 0) {
                             const lastMessage = newDialogue[newDialogue.length - 1];
                             if (lastMessage && lastMessage.speaker === '旁白' && lastMessage.content && (lastMessage.content.includes('不足') || lastMessage.content.includes('失败'))) {
                                  alert(`训练提示: ${lastMessage.content}`); // 直接 alert 提示
                             } else if (lastMessage && lastMessage.speaker === '旁白') {
                                 console.log(`训练结果/提示: ${lastMessage.content}`); // 在控制台记录成功信息
                             }
                        }
                    } catch (parseError) {
                        console.error("[解析阶段] JSON 解析失败:", parseError);
                        console.error("失败时尝试解析的字符串:", extractedJsonString);
                        alert(`解析训练结果时出错: ${parseError.message}.`);
                        newGameData = null;
                    }
                } else {
                    console.error("未能从 LLM 响应中提取有效的 <gametext>{...}</gametext> 块 (训练)。");
                     if (rawLLMResponse && !rawLLMResponse.includes('<gametext>') && !rawLLMResponse.includes('{') && rawLLMResponse.trim().length > 5) {
                         alert(`训练提示: ${rawLLMResponse.trim()}`); // 将纯文本回复视为提示
                    } else {
                        alert("处理训练请求失败：无法从回复中获取有效的游戏状态数据。");
                    }
                    newGameData = null;
                }

                if (newGameData) {
                    // 如果解析成功且 newGameData 有值（即使是表示失败的状态）
                    updateGameState(newGameData);
                    console.log("游戏状态和UI已更新 (训练)。准备静默保存...");
                    if (typeof setChatMessage === 'function') {
                        await setChatMessage({ message: messageToSave }, 0, { refresh: 'none' });
                        console.log("静默保存完成 (训练)。");
                    }
                } else {
                    console.error("由于提取或解析失败，未能生成有效的 newGameData，跳过状态更新和保存 (训练)。");
                }
                 // --- (结束) ---

            } catch (error) {
                console.error("处理训练事件时发生顶层错误:", error);
                alert(`处理训练时发生错误: ${error.message}\n请检查控制台。`);
            } finally {
                hideLoadingIndicator();
                enableInteractions();
                if (card) card.classList.remove('training-in-progress');
                console.log("startTraining finally block executed.");
            }
        }
        // --- DOMContentLoaded ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOMContentLoaded - 开始初始化应用程序");

             // 初始化核心系统
             DataSystem.init();
             TextSystem.init(); // TextSystem 也需要初始化来绑定基础事件
             console.log("DataSystem 和 TextSystem 已初始化");

             // 加载游戏数据
             loadGameDataFromChat().then(() => {
                  console.log("loadGameDataFromChat Promise 已解决");
                  // 注册 beforeunload 保存事件 (简化保存逻辑)
                   window.addEventListener('beforeunload', () => {
                        console.log("页面即将关闭，执行最终保存...");
                        saveGameState(); // 直接调用保存
                   });
                   console.log("beforeunload 保存事件已注册。");

                   // --- 设置初始页面 ---
                  const pages = document.querySelectorAll('.page');
                  const mainNav = document.getElementById('mainNav');
                   let initialPageId = 'story'; // 默认初始页面
                  if (pages.length > 0 && !document.querySelector('.page.active')) {
                       pages[0].classList.add('active'); // 确保有活动页
                  }
                   // 激活导航链接并获取初始页面 ID
                   if(mainNav){
                        const initialPageLink = mainNav.querySelector('.nav-link.active') || mainNav.querySelector('.nav-link[data-page="story"]'); // 默认 story
                        if (initialPageLink) {
                             initialPageId = initialPageLink.dataset.page;
                             // 确保链接是 active 状态
                              mainNav.querySelectorAll('.nav-link').forEach(l => l.classList.remove('active'));
                              initialPageLink.classList.add('active');
                              // 确保对应页面是 active 状态
                              document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
                              const initialPageEl = document.getElementById(initialPageId + 'Page');
                              if(initialPageEl) initialPageEl.classList.add('active');
                        }
                   }
                    console.log("确定初始活动页面 ID:", initialPageId);
                    // 调用 switchPage 来处理初始页面的渲染
                    switchPage(initialPageId);

             }).catch(error => {
                  console.error("初始化加载游戏数据时发生严重错误:", error);
                  alert("加载游戏数据失败，请检查控制台获取详细信息。");
                   // 即使加载失败，也尝试显示一个默认页面
                   switchPage('story'); // 尝试显示故事页（可能为空）
             });

            // --- 全局事件监听 ---
            // 导航栏
            const mainNavElement = document.getElementById('mainNav');
            if (mainNavElement) {
                mainNavElement.addEventListener('click', (e) => {
                    const link = e.target.closest('.nav-link');
                    if (link && link.dataset.page) {
                        e.preventDefault();
                        switchPage(link.dataset.page);
                    }
                });
            }

            // --- 页面特定事件监听 ---
            // 联系人页
             const contactListEl = document.getElementById('contactList');
             if (contactListEl) { // 使用事件委托
                 contactListEl.addEventListener('click', (e) => {
                      const targetItem = e.target.closest('.contact-item');
                      if (targetItem && targetItem.dataset.contact) {
                           switchContact(targetItem.dataset.contact);
                      }
                 });
             }
            document.getElementById('sendMessageBtn')?.addEventListener('click', sendMessage);
            document.getElementById('messageInput')?.addEventListener('keypress', (e) => {
                 if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); }
             });
            document.getElementById('contactSearchBtn')?.addEventListener('click', searchContacts);
            document.getElementById('contactSearchInput')?.addEventListener('input', searchContacts);
            document.getElementById('clearChatBtn')?.addEventListener('click', clearCurrentChat);
            document.getElementById('characterInfoBtn')?.addEventListener('click', toggleProfileDisplay);

            // 故事页
             document.getElementById('btn-show-history')?.addEventListener('click', showHistoryModal);
             document.getElementById('btn-load-save')?.addEventListener('click', openLoadSaveModal);

            // 团队页
            document.getElementById('teamMembers')?.addEventListener('click', (e) => {
                 const targetCard = e.target.closest('.member-card.horizontal'); // 选择横向卡片
                 if (targetCard && (targetCard.dataset.memberId || targetCard.dataset.member)) {
                      handleMemberCardClick(targetCard.dataset.memberId || targetCard.dataset.member); // 兼容旧 data-*
                 }
             });
             document.getElementById('dataAnalysisBtn')?.addEventListener('click', () => alert('数据分析功能正在开发中...'));
             document.getElementById('teamSettingsBtn')?.addEventListener('click', () => alert('团队设置功能正在开发中...'));

             // 计划页
              const filterButtonsContainer = document.querySelector('.filter-buttons');
              if (filterButtonsContainer) {
                   filterButtonsContainer.addEventListener('click', (e) => {
                        if (e.target.classList.contains('filter-btn') && e.target.dataset.filter) {
                            filterTasks(e.target.dataset.filter);
                        }
                   });
              }
              document.getElementById('taskSearchInput')?.addEventListener('input', searchTasks);
              document.getElementById('newTaskBtn')?.addEventListener('click', () => alert('新建任务功能正在开发中...'));

              const deleteRecordsBtn = document.getElementById('btn-delete-records');
            if (deleteRecordsBtn) {
                deleteRecordsBtn.addEventListener('click', deleteGameRecords);
                console.log("删除记录按钮事件监听器已附加。");
            } else {
                console.warn("未找到删除记录按钮 #btn-delete-records。");
            }

             // 新歌页
             document.getElementById('songTheme')?.addEventListener('change', (e) => {
                  const customContainer = document.getElementById('customThemeContainer');
                  if(customContainer) customContainer.style.display = e.target.value === 'custom' ? 'block' : 'none';
                  updateSongSummary();
             });
              document.getElementById('customTheme')?.addEventListener('input', updateSongSummary); // 自定义输入时也更新
             document.getElementById('songStyle')?.addEventListener('change', updateSongSummary);
              // 使用事件委托绑定成员选择
              document.getElementById('mainVocalSelection')?.addEventListener('click', (e) => {
                   const targetItem = e.target.closest('.member-select-item');
                   if(targetItem) selectSongMember(targetItem);
              });
              document.getElementById('subVocalSelection')?.addEventListener('click', (e) => {
                    const targetItem = e.target.closest('.member-select-item');
                    if(targetItem) selectSongMember(targetItem);
               });
              // 制作团队选择
              ['composer', 'lyricist', 'arranger', 'mvDirector'].forEach(id => {
                   document.getElementById(id)?.addEventListener('change', updateSongSummary);
              });
               document.getElementById('mvConcept')?.addEventListener('input', updateSongSummary); // MV 概念变化也更新摘要
               document.getElementById('startProductionBtn')?.addEventListener('click', async () => {
                console.log("开始制作按钮被点击");
                // --- 收集信息 (保持不变，确保健壮性) ---
                const songConfig = {
                    theme: '', style: '', mainVocal: '', subVocals: [],
                    productionTeam: { composer: '', lyricist: '', arranger: '' },
                    mv: { director: '', concept: '' }
                };
                let estimatedTotalCost = 0;
                let totalCostTextForPrompt = '无法获取';
                try {
                    const themeSelect = document.getElementById('songTheme');
                    if (themeSelect) {
                        songConfig.theme = themeSelect.value;
                        if (songConfig.theme === 'custom') {
                            const customInput = document.getElementById('customTheme');
                            songConfig.theme = customInput?.value.trim() || '自定义(未输入)';
                        }
                    }
                    const styleSelect = document.getElementById('songStyle');
                    if (styleSelect) songConfig.style = styleSelect.options[styleSelect.selectedIndex]?.text || styleSelect.value; // 获取文本或值
                    const mainVocalEl = document.getElementById('mainVocalSelection')?.querySelector('.member-select-item.selected');
                    if (mainVocalEl) songConfig.mainVocal = mainVocalEl.dataset.member;
                    const subVocalEls = document.getElementById('subVocalSelection')?.querySelectorAll('.member-select-item.selected');
                    if (subVocalEls) songConfig.subVocals = Array.from(subVocalEls).map(item => item.dataset.member);
                    const getTeamMemberName = (id) => document.getElementById(id)?.value || ''; // 简化获取
                    songConfig.productionTeam.composer = getTeamMemberName('composer');
                    songConfig.productionTeam.lyricist = getTeamMemberName('lyricist');
                    songConfig.productionTeam.arranger = getTeamMemberName('arranger');
                    songConfig.mv.director = getTeamMemberName('mvDirector');
                    songConfig.mv.concept = document.getElementById('mvConcept')?.value.trim() || '';
                    // 获取成本
                    const budgetTotalEl = document.querySelector('#budgetItems .item-value[data-budget="total"]');
                    if (budgetTotalEl) {
                        totalCostTextForPrompt = budgetTotalEl.textContent || "0";
                        const costMatch = totalCostTextForPrompt.match(/[\d,]+/);
                        if (costMatch) estimatedTotalCost = parseInt(costMatch[0].replace(/,/g, ''), 10) || 0;
                    } else {
                         console.warn("无法在摘要中找到总成本元素。将使用 0 作为估算。");
                         estimatedTotalCost = 0;
                         totalCostTextForPrompt = "0 (获取失败)";
                    }
                    console.log("收集到的歌曲配置:", songConfig, "估算成本:", estimatedTotalCost);
                    // 基本验证
                    if (!songConfig.theme || !songConfig.style || !songConfig.mainVocal ||
                        !songConfig.productionTeam.composer || !songConfig.productionTeam.lyricist || !songConfig.productionTeam.arranger) {
                        alert("请确保主题、曲风、主唱和核心制作团队（作曲、作词、编曲）都已选择！");
                        return;
                    }
                } catch (collectionError) {
                    console.error("收集歌曲配置时出错:", collectionError);
                    alert("收集歌曲信息时出错，请检查页面元素。");
                    return;
                }

                // --- UI 反馈与禁用 ---
                showLoadingIndicator("开始制作歌曲...");
           disableInteractions();
           const startBtn = document.getElementById('startProductionBtn');
           if(startBtn) startBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 处理中...';

           try {
               await toggleWorldBookEntries(['COT', '格式要求'], ['COT（chat）']);
               await autoSaveToWorldBook();

               // 获取故事总结上下文
               let summaryContext = "\n\n【最近的故事总结回顾】\n";
               // ... (获取 summaries 的逻辑不变) ...
               summaryContext += summaries.length > 0 ? summaries.map(s => `${s.id}. ${s.content}`).join('\n') : "暂无总结。";
               summaryContext += "\n";

               // 构建配置文本
               let configText = `主题: ${songConfig.theme}, 曲风: ${songConfig.style}, 主唱: ${songConfig.mainVocal}`;
               if (songConfig.subVocals.length > 0) configText += `, 和声: ${songConfig.subVocals.join(', ')}`;
               configText += `\n制作团队: 作曲-${songConfig.productionTeam.composer}, 作词-${songConfig.productionTeam.lyricist}, 编曲-${songConfig.productionTeam.arranger}`;
               if (songConfig.mv.director) configText += `\nMV计划: 导演-${songConfig.mv.director}, 概念-${songConfig.mv.concept || '未填写'}`;
               configText += `\n估算总成本: ${totalCostTextForPrompt}`; // totalCostTextForPrompt 在前面已获取

               // 【修改】构建注入的系统指令
               const systemInstruction = `--- CORE ACTION THIS TURN ---\n` +
                                        `**Player Character Action:** {{user}} initiated the production of a new song with the following configuration:\n` +
                                        `**Action Detail:**\n${configText}\n` + // 包含详细配置
                                        `**Instruction:** This song production initiation is the ABSOLUTE FOCUS. You MUST process this request:\n` +
                                        `1. Check if conditions are met (e.g., sufficient funds: ${estimatedTotalCost}).\n` +
                                        `2. If met, update the game state (deduct funds, add a new task to \`plan\` with status 'inprogress' to track production, potentially adjust mood/schedule).\n` +
                                        `3. Generate narrative describing the *initiation* of the production (e.g., meeting, reactions).\n` +
                                        `4. Output ONLY the \`<gametext>\` containing the *complete* updated game state (or reflecting failure).\n\n` +
                                        `--- Execution Context & Guidelines ---\n` +
                                        `${summaryContext}\n` +
                                        `【<回复格式> 指令】\n` + // 引用外部的 CoT/回复格式
                                        `Please strictly follow the rules defined in \`<回复格式>\` (your CoT, Thinking Format v3.0).\n`;

               console.log("System Instruction for generate:", systemInstruction);

               // 【修改】调用 generate
               const rawLLMResponse = await generate({
                   user_input: `开始制作新歌：${songConfig.theme} - ${songConfig.style}`, // <--- 简化的用户意图
                   should_stream: false,
                   injects: [
                       {
                           role: 'system',
                           content: systemInstruction,
                           position: 'before_prompt',
                           depth: 0,
                           should_scan: false
                       }
                   ]
                   // max_chat_history: 0 // 通常不需要聊天历史
               });



                    // --- JSON Processing Logic Start --- (与 selectStoryOption 完全相同)

                    // 1. 提取完整的 <gametext>...</gametext> 块
                    const fullGameTextBlock = extractGameText(rawLLMResponse);
                    console.log("[调试] 1. Extracted fullGameTextBlock:", fullGameTextBlock);

                    let newGameData = null;
                    let messageToSave = rawLLMResponse;

                    if (fullGameTextBlock) {
                        // 2. 尝试从完整块中提取 JSON 内容进行解析
                        const contentMatch = fullGameTextBlock.match(/<gametext>([\s\S]*?)<\/gametext>/i);
                        const contentToParse = contentMatch?.[1]?.trim() ?? null;
                        console.log("[调试] 2. Content extracted for parsing:", contentToParse);

                        if (contentToParse) {
                            // 3. 清理潜在的 Markdown 标记
                            let cleanedContentForParse = contentToParse.replace(/^```json\s*/, '').replace(/\s*```$/, '').trim();
                            console.log("[调试] 3. Cleaned content for parsing:", cleanedContentForParse);

                            // 4. 尝试解析 JSON
                            try {
                                console.log("[调试] 4. Attempting JSON.parse...");
                                newGameData = JSON.parse(cleanedContentForParse);
                                messageToSave = fullGameTextBlock; // 保存完整块
                                console.log("成功解析 gametext 内容。 messageToSave 将是完整块。"); // 日志 5
                                // 解析成功，检查是否有旁白提示（如资金不足）
                                const lastDialogue = newGameData?.story?.dialogue?.slice(-1)[0];
                                if (lastDialogue?.speaker === '旁白' && lastDialogue?.content?.includes('不足')) {
                                     alert(`歌曲制作提示: ${lastDialogue.content}`); // 如果有明确提示，显示它
                                } else {
                                     alert("歌曲制作请求已发送处理！"); // 通用成功提示
                                }
                            } catch (parseError) {
                                // 5. 解析失败处理
                                console.error("[调试] 6. JSON.parse FAILED:", parseError);
                                console.error("解析 gametext 内容失败:", parseError, "尝试解析的内容:", cleanedContentForParse);
                                console.warn("解析失败，将完整 <gametext> 块作为旁白/错误提示处理。");
                                newGameData = structuredClone(gameState);
                                newGameData.story.dialogue = newGameData.story.dialogue || [];
                                if (fullGameTextBlock.trim()) {
                                    newGameData.story.dialogue.push({
                                        speaker: "旁白",
                                        content: `(系统提示：收到无法解析的数据块，错误: ${parseError.message})`,
                                        style: "normal"
                                    });
                                }
                                newGameData.story.options = [];
                                messageToSave = fullGameTextBlock; // 保存原始块
                                alert(`歌曲制作失败：无法处理返回的数据。`); // 明确的失败提示
                                console.log("已将无法解析的响应块添加为错误提示。 messageToSave 仍是完整块。");
                            }
                        } else {
                            // 6. <gametext> 块内部内容提取失败
                            console.error("[调试] 7. <gametext> 块内部内容提取失败。");
                            newGameData = structuredClone(gameState);
                            newGameData.story.dialogue = newGameData.story.dialogue || [];
                            newGameData.story.dialogue.push({
                                speaker: "旁白",
                                content: `(系统提示：收到的 <gametext> 标签内部为空或无法提取内容)`,
                                style: "normal"
                            });
                            newGameData.story.options = [];
                            messageToSave = fullGameTextBlock; // 保存有问题的块
                             alert(`歌曲制作失败：返回的数据格式不正确。`);
                            console.log("已将空的或无法提取的 <gametext> 块添加为提示。");
                        }
                    } else {
                        // 7. 未找到 <gametext> 标签
                        console.error("LLM响应中未找到 <gametext> 标签:", rawLLMResponse);
                        const trimmedResponse = rawLLMResponse ? rawLLMResponse.trim() : "";
                        if (trimmedResponse && !trimmedResponse.includes('{')) {
                            console.warn("无 <gametext> 标签，尝试将整个响应作为旁白处理。");
                            newGameData = structuredClone(gameState);
                            newGameData.story.dialogue = newGameData.story.dialogue || [];
                            newGameData.story.dialogue.push({ speaker: "旁白", content: trimmedResponse, style: "normal" });
                            newGameData.story.options = [];
                            messageToSave = `<gametext>${JSON.stringify(newGameData)}</gametext>`; // 构建 gametext 保存
                            alert(`歌曲制作提示: ${trimmedResponse}`); // 显示纯文本提示
                            console.log("已将纯文本响应处理为旁白并构建 gametext 保存。");
                        } else {
                             alert(`歌曲制作失败：AI 未按预期格式返回。`);
                            throw new Error("LLM响应无效，缺少 <gametext> 标签且非纯文本。");
                        }
                    }

                    // 8. 更新状态并保存 (仅当 newGameData 被成功赋值时)
                    if (newGameData) {
                        updateGameState(newGameData);
                        console.log("游戏状态和UI已更新。准备静默保存 messageToSave...");
                        console.log("[调试] 8. messageToSave 的内容:", messageToSave);
                        if (typeof setChatMessage === 'function') {
                             await setChatMessage({ message: messageToSave }, 0, { refresh: 'none' }); // 保存 messageToSave
                             console.log("静默保存完成。");
                        } else {
                             console.warn("setChatMessage 函数不可用，无法静默保存。");
                        }
                    } else {
                        console.error("未能生成有效的 newGameData，跳过状态更新和保存。");
                        // 错误已经在上面处理并 alert 了，这里不再抛出，避免重复提示
                        // throw new Error("未能处理LLM响应以更新游戏状态。");
                    }

                    // --- JSON Processing Logic End ---

                } catch (error) {
                    console.error("处理歌曲制作时发生错误:", error);
                    // 避免重复 alert
                    // alert(`开始制作歌曲时发生错误: ${error.message}\n请检查控制台。`);
                } finally {
                    hideLoadingIndicator();
                    enableInteractions();
                    if (startBtn) startBtn.innerHTML = '<i class="fas fa-play"></i> 开始制作'; // 恢复按钮
                    console.log("歌曲制作处理流程结束 (finally)。");
                }
            });


             // 特训页
              const trainingGrid = document.getElementById('trainingPage')?.querySelector('.training-grid');
              if (trainingGrid) {
                   trainingGrid.addEventListener('click', (e) => {
                        const trainButton = e.target.closest('.btn-train');
                        if (trainButton) {
                             console.log("训练按钮被点击 (事件委托)");
                             startTraining(trainButton);
                        }
                   });
              }

            console.log("DOMContentLoaded - 事件监听器设置完成");
        });

        // --- Cleaned Up Code Ends ---

    </script>
</body>
</html>
```